<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/StompWebSocketService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/StompWebSocketService.kt" />
              <option name="originalContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyListener&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StompWebSocketService @Inject constructor(&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;StompWebSocket&quot;&#10;        private const val WS_URL = &quot;ws://10.0.2.2:8080/ws&quot;&#10;        private const val HEARTBEAT_INTERVAL = 30000L // 30 Sekunden&#10;        private const val RECONNECT_DELAY = 3000L // 3 Sekunden&#10;    }&#10;&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;    private var reconnectJob: Job? = null&#10;    private var playerId: String? = null&#10;    private var currentLobbyId: String? = null&#10;&#10;    private var lobbyListener: LobbyListener? = null&#10;&#10;    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;ConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    private val _connectionMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val connectionMessages: StateFlow&lt;List&lt;String&gt;&gt; = _connectionMessages.asStateFlow()&#10;&#10;    // Lobby-spezifische Flows&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;String&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    // Callback für Lobby-Message-Handling&#10;    private var lobbyMessageHandler: ((String) -&gt; Unit)? = null&#10;    val MESSAGE_END = &quot;\u0000&quot;&#10;&#10;    enum class ConnectionState {&#10;        DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING&#10;    }&#10;&#10;    enum class ServerStatus {&#10;        OFFLINE, ONLINE, BUSY, MAINTENANCE, UNKNOWN&#10;    }&#10;&#10;    private val _serverStatus = MutableStateFlow(ServerStatus.UNKNOWN)&#10;    val serverStatus: StateFlow&lt;ServerStatus&gt; = _serverStatus.asStateFlow()&#10;&#10;    private val _lastMessageTimestamp = MutableStateFlow(0L)&#10;    private var serverStatusCheckJob: Job? = null&#10;    &#10;    // Timeout für Server-Status-Überprüfung (10 Sekunden)&#10;    private val SERVER_STATUS_TIMEOUT = 10_000L&#10;&#10;    private val webSocketListener = object : WebSocketListener() {&#10;        override fun onOpen(webSocket: WebSocket, response: Response) {&#10;            Log.d(TAG, &quot;WebSocket connection opened&quot;)&#10;            _connectionState.value = ConnectionState.CONNECTED&#10;&#10;            // Sende STOMP CONNECT Frame&#10;            sendStompConnect()&#10;&#10;            // Starte Heartbeat&#10;            startHeartbeat()&#10;            &#10;            // Starte Server-Status-Überprüfung&#10;            startServerStatusCheck()&#10;&#10;            // Subscription zu Topics erfolgt erst nach CONNECTED-Antwort vom Server&#10;        }&#10;&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            Log.d(TAG, &quot;Received message: $text&quot;)&#10;            handleStompMessage(text)&#10;        }&#10;&#10;        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;            Log.e(TAG, &quot;WebSocket connection failed: ${t.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;            scheduleReconnect()&#10;        }&#10;&#10;        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;            Log.i(TAG, &quot;WebSocket connection closed: $reason&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;        }&#10;    }&#10;&#10;    suspend fun connect(username: String) {&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected&quot;)&#10;            return&#10;        }&#10;&#10;        playerId = username&#10;        _connectionState.value = ConnectionState.CONNECTING&#10;&#10;        try {&#10;            // Token synchron abrufen&#10;            val token = tokenStorage.getToken().first()&#10;            Log.d(TAG, &quot;Retrieved token for WebSocket connection: ${token?.take(20)}...&quot;)&#10;&#10;            val client = OkHttpClient.Builder()&#10;                .pingInterval(30, TimeUnit.SECONDS)&#10;                .build()&#10;&#10;            val requestBuilder = Request.Builder().url(WS_URL)&#10;&#10;            // Nur Authorization Header hinzufügen wenn Token verfügbar ist&#10;            token?.let {&#10;                requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $it&quot;)&#10;                Log.d(TAG, &quot;Added Authorization header to WebSocket request&quot;)&#10;            } ?: Log.w(TAG, &quot;No token available for WebSocket connection&quot;)&#10;&#10;            val request = requestBuilder.build()&#10;            webSocket = client.newWebSocket(request, webSocketListener)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to connect: ${e.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;        }&#10;    }&#10;&#10;    private fun sendStompConnect() {&#10;        val connectFrame = buildString {&#10;            append(&quot;CONNECT\n&quot;)&#10;            append(&quot;accept-version:1.0,1.1,2.0\n&quot;)&#10;            append(&quot;heart-beat:5000,5000\n&quot;)&#10;            playerId?.let { append(&quot;login:$it\n&quot;) }&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(connectFrame)&#10;        Log.d(TAG, &quot;Sent STOMP CONNECT frame&quot;)&#10;    }&#10;&#10;    private fun subscribeToTopics() {&#10;        Log.d(TAG, &quot;Subscribing to topics&quot;)&#10;        playerId?.let { id -&gt;&#10;            // Subscribe zu persönlichen Nachrichten&#10;             // 200 ms warten&#10;            val subscribeFrame2 = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-2\n&quot;)&#10;                append(&quot;destination:/topic/players\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrame2)&#10;            Log.d(TAG, &quot;Subscribed to topics&quot;)&#10;&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                delay(200)&#10;                val subscribeFrame1 = buildString {&#10;                    append(&quot;SUBSCRIBE\n&quot;)&#10;                    append(&quot;id:sub-1\n&quot;)&#10;                    append(&quot;destination:/user/queue/status\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;                webSocket?.send(subscribeFrame1)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                sendHeartbeat()&#10;                delay(HEARTBEAT_INTERVAL)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Heartbeat started&quot;)&#10;    }&#10;&#10;    private fun sendHeartbeat() {&#10;        playerId?.let { id -&gt;&#10;            val heartbeatFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/heartbeat\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;heartbeat&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(heartbeatFrame)&#10;            Log.d(TAG, &quot;Sent heartbeat for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleStompMessage(message: String) {&#10;        try {&#10;            // Auf CONNECTED Frame vom Server prüfen&#10;            if (message.startsWith(&quot;CONNECTED&quot;)) {&#10;                Log.d(TAG, &quot;Received STOMP CONNECTED frame from server&quot;)&#10;                // Jetzt erst die Subscriptions starten, wenn der Server die Verbindung bestätigt hat&#10;                subscribeToTopics()&#10;                return&#10;            }&#10;&#10;            if (message.startsWith(&quot;MESSAGE&quot;)) {&#10;                val lines = message.split(&quot;\n&quot;)&#10;                var body = &quot;&quot;&#10;                var isBody = false&#10;&#10;                for (line in lines) {&#10;                    if (isBody) {&#10;                        body += line&#10;                    } else if (line.isEmpty()) {&#10;                        isBody = true&#10;                    }&#10;                }&#10;&#10;                // Entferne Null-Terminator&#10;                body = body.replace(MESSAGE_END, &quot;&quot;)&#10;&#10;                if (body.isNotEmpty()) {&#10;                    handleMessageBody(body)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error handling STOMP message: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleMessageBody(body: String) {&#10;        try {&#10;            val json = JSONObject(body)&#10;            val type = json.optString(&quot;type&quot;)&#10;&#10;            when (type) {&#10;                &quot;status-update&quot; -&gt; {&#10;                    val status = json.optString(&quot;status&quot;)&#10;                    Log.d(TAG, &quot;Status update received: $status&quot;)&#10;                    &#10;                    // Server-Status verarbeiten&#10;                    updateServerStatus(status)&#10;                }&#10;&#10;                &quot;lobby-message&quot; -&gt; {&#10;                    // Lobby-spezifische Nachrichten verarbeiten&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val messageContent = json.optString(&quot;message&quot;)&#10;&#10;                    if (lobbyId == currentLobbyId) {&#10;                        // Nur Nachrichten für den aktuellen Lobby-Kontext weiterleiten&#10;                        _lobbyMessages.value = _lobbyMessages.value + messageContent&#10;                        Log.d(TAG, &quot;Lobby message received: $messageContent&quot;)&#10;                        // Optional: Direktes Handling der Nachricht über den Handler&#10;                        lobbyMessageHandler?.invoke(messageContent)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Füge Nachricht zur Liste hinzu&#10;            val currentMessages = _connectionMessages.value.toMutableList()&#10;            currentMessages.add(body)&#10;            if (currentMessages.size &gt; 50) { // Begrenze auf 50 Nachrichten&#10;                currentMessages.removeAt(0)&#10;            }&#10;            _connectionMessages.value = currentMessages&#10;&#10;            // Aktualisiere den Zeitstempel der letzten Nachricht&#10;            _lastMessageTimestamp.value = System.currentTimeMillis()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error parsing message body: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Aktualisiert den Server-Status basierend auf dem erhaltenen Status-String&#10;     */&#10;    private fun updateServerStatus(status: String) {&#10;        val newStatus = when (status.lowercase()) {&#10;            &quot;online&quot; -&gt; ServerStatus.ONLINE&#10;            &quot;offline&quot; -&gt; ServerStatus.OFFLINE&#10;            &quot;busy&quot; -&gt; ServerStatus.BUSY&#10;            &quot;maintenance&quot; -&gt; ServerStatus.MAINTENANCE&#10;            else -&gt; ServerStatus.UNKNOWN&#10;        }&#10;        &#10;        _serverStatus.value = newStatus&#10;        Log.d(TAG, &quot;Server status updated to: $newStatus&quot;)&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;        heartbeatJob = null&#10;        Log.d(TAG, &quot;Heartbeat stopped&quot;)&#10;    }&#10;&#10;    private fun scheduleReconnect() {&#10;        if (reconnectJob?.isActive == true) return&#10;&#10;        reconnectJob = CoroutineScope(Dispatchers.IO).launch {&#10;            delay(RECONNECT_DELAY)&#10;            playerId?.let { id -&gt;&#10;                if (_connectionState.value == ConnectionState.DISCONNECTED) {&#10;                    Log.d(TAG, &quot;Attempting to reconnect...&quot;)&#10;                    _connectionState.value = ConnectionState.RECONNECTING&#10;                    connect(id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        Log.d(TAG, &quot;Disconnecting WebSocket&quot;)&#10;        stopHeartbeat()&#10;        reconnectJob?.cancel()&#10;&#10;        // Sende App-Closing-Nachricht an Server bevor Verbindung getrennt wird&#10;        sendAppClosingMessage()&#10;&#10;        // Kurz warten damit Nachricht gesendet werden kann&#10;        Thread.sleep(100)&#10;&#10;        // Sende DISCONNECT Frame&#10;        val disconnectFrame = buildString {&#10;            append(&quot;DISCONNECT\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(disconnectFrame)&#10;        webSocket?.close(1000, &quot;Client disconnecting&quot;)&#10;        webSocket = null&#10;&#10;        _connectionState.value = ConnectionState.DISCONNECTED&#10;    }&#10;&#10;    private fun sendAppClosingMessage() {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;app-shutdown&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageSync() {&#10;        // Synchrone Version für App-Shutdown&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            sendAppClosingMessage()&#10;            Thread.sleep(200) // Etwas länger warten für synchronen Aufruf&#10;        }&#10;    }&#10;&#10;    fun leaveLobbyOnAppClosing() {&#10;        if (lobbyListener == null) {&#10;            Log.w(TAG, &quot;LobbyListener is not set. Cannot leave lobby on app closing.&quot;)&#10;        } else {&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val currentLobby = lobbyListener!!.currentLobby.value&#10;                Log.d(&quot;StompWebSocket&quot;, &quot;checking if in a lobby: current Lobby: $currentLobby&quot;)&#10;                currentLobby?.let {&#10;                    lobbyListener!!.leaveLobby(it.lobbyId)&#10;                        .onSuccess {&#10;                            Log.d(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Successfully left lobby ${currentLobby.lobbyId} during app closing&quot;&#10;                            )&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            Log.e(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Failed to leave lobby during app closing&quot;,&#10;                                exception&#10;                            )&#10;                        }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageWithReason(reason: String) {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;$reason&quot;,&quot;timestamp&quot;:&quot;${System.currentTimeMillis()}&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id with reason: $reason&quot;)&#10;&#10;            // Kurz warten damit Nachricht gesendet werden kann&#10;            Thread.sleep(150)&#10;        }&#10;    }&#10;&#10;    fun requestOnlinePlayers() {&#10;        playerId?.let { id -&gt;&#10;            val requestFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/players\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;request&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(requestFrame)&#10;            Log.d(TAG, &quot;Requested online players list&quot;)&#10;        }&#10;    }&#10;&#10;    fun setLobbyMessageHandler(handler: (String) -&gt; Unit) {&#10;        lobbyMessageHandler = handler&#10;    }&#10;&#10;    fun isConnected(): Boolean = _connectionState.value == ConnectionState.CONNECTED&#10;&#10;    // Lobby-spezifische Funktionen&#10;&#10;    fun subscribeToLobby(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu lobby-spezifischen Topics&#10;        val subscribeLobbyFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/lobby/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(subscribeLobbyFrame)&#10;        Log.d(TAG, &quot;Subscribed to lobby updates: $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromLobby() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            Log.d(&#10;                TAG,&#10;                &quot;Sending STOMP unsubscribe frame: ${unsubscribeFrame.replace(MESSAGE_END, &quot;[NULL]&quot;)}&quot;&#10;            )&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId = null&#10;    }&#10;&#10;    fun sendLobbyChat(message: String) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val chatFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/chat\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;chat&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;message&quot;:&quot;$message&quot;}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(chatFrame)&#10;                Log.d(TAG, &quot;Sent lobby chat message: $message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPlayerReady(ready: Boolean) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val readyFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/ready\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;player-ready&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;ready&quot;:$ready}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(readyFrame)&#10;                Log.d(TAG, &quot;Sent player ready status: $ready&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Legacy-Methoden für Kompatibilität (werden intern umgeleitet)&#10;    fun joinLobby(lobbyId: String) {&#10;        subscribeToLobby(lobbyId)&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        unsubscribeFromLobby()&#10;    }&#10;&#10;    fun sendLobbyMessage(message: String) {&#10;        sendLobbyChat(message)&#10;    }&#10;&#10;    /**&#10;     * Startet die periodische Überprüfung des Server-Status&#10;     */&#10;    private fun startServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                // Prüfen, ob der letzte Nachrichtenzeitpunkt zu lange her ist&#10;                val currentTime = System.currentTimeMillis()&#10;                val lastMessageTime = _lastMessageTimestamp.value&#10;                &#10;                if (lastMessageTime &gt; 0 &amp;&amp; (currentTime - lastMessageTime) &gt; SERVER_STATUS_TIMEOUT) {&#10;                    // Wenn länger als 10 Sekunden keine Nachricht empfangen wurde, Status auf OFFLINE setzen&#10;                    _serverStatus.value = ServerStatus.OFFLINE&#10;                    Log.d(TAG, &quot;Server status set to OFFLINE due to timeout (no message in ${SERVER_STATUS_TIMEOUT/1000} seconds)&quot;)&#10;                }&#10;                &#10;                delay(1000) // Alle Sekunde prüfen&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Server status check started&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Stoppt die periodische Überprüfung des Server-Status&#10;     */&#10;    private fun stopServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = null&#10;        Log.d(TAG, &quot;Server status check stopped&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyListener&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StompWebSocketService @Inject constructor(&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;StompWebSocket&quot;&#10;        private const val WS_URL = &quot;ws://10.0.2.2:8080/ws&quot;&#10;        private const val HEARTBEAT_INTERVAL = 30000L // 30 Sekunden&#10;        private const val RECONNECT_DELAY = 3000L // 3 Sekunden&#10;    }&#10;&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;    private var reconnectJob: Job? = null&#10;    private var playerId: String? = null&#10;    private var currentLobbyId: String? = null&#10;&#10;    private var lobbyListener: LobbyListener? = null&#10;&#10;    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;ConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    private val _connectionMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val connectionMessages: StateFlow&lt;List&lt;String&gt;&gt; = _connectionMessages.asStateFlow()&#10;&#10;    // Lobby-spezifische Flows&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;String&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    // Callback für Lobby-Message-Handling&#10;    private var lobbyMessageHandler: ((String) -&gt; Unit)? = null&#10;    val MESSAGE_END = &quot;\u0000&quot;&#10;&#10;    enum class ConnectionState {&#10;        DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING&#10;    }&#10;&#10;    enum class ServerStatus {&#10;        OFFLINE, ONLINE, BUSY, MAINTENANCE, UNKNOWN&#10;    }&#10;&#10;    private val _serverStatus = MutableStateFlow(ServerStatus.UNKNOWN)&#10;    val serverStatus: StateFlow&lt;ServerStatus&gt; = _serverStatus.asStateFlow()&#10;&#10;    private val _lastMessageTimestamp = MutableStateFlow(0L)&#10;    private var serverStatusCheckJob: Job? = null&#10;    &#10;    // Timeout für Server-Status-Überprüfung (10 Sekunden)&#10;    private val SERVER_STATUS_TIMEOUT = 10_000L&#10;&#10;    private val webSocketListener = object : WebSocketListener() {&#10;        override fun onOpen(webSocket: WebSocket, response: Response) {&#10;            Log.d(TAG, &quot;WebSocket connection opened&quot;)&#10;            _connectionState.value = ConnectionState.CONNECTED&#10;&#10;            // Sende STOMP CONNECT Frame&#10;            sendStompConnect()&#10;&#10;            // Starte Heartbeat&#10;            startHeartbeat()&#10;            &#10;            // Starte Server-Status-Überprüfung&#10;            startServerStatusCheck()&#10;&#10;            // Subscription zu Topics erfolgt erst nach CONNECTED-Antwort vom Server&#10;        }&#10;&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            Log.d(TAG, &quot;Received message: $text&quot;)&#10;            handleStompMessage(text)&#10;        }&#10;&#10;        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;            Log.e(TAG, &quot;WebSocket connection failed: ${t.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;            scheduleReconnect()&#10;        }&#10;&#10;        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;            Log.i(TAG, &quot;WebSocket connection closed: $reason&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;        }&#10;    }&#10;&#10;    suspend fun connect(username: String) {&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected&quot;)&#10;            return&#10;        }&#10;&#10;        playerId = username&#10;        _connectionState.value = ConnectionState.CONNECTING&#10;&#10;        try {&#10;            // Token synchron abrufen&#10;            val token = tokenStorage.getToken().first()&#10;            Log.d(TAG, &quot;Retrieved token for WebSocket connection: ${token?.take(20)}...&quot;)&#10;&#10;            val client = OkHttpClient.Builder()&#10;                .pingInterval(30, TimeUnit.SECONDS)&#10;                .build()&#10;&#10;            val requestBuilder = Request.Builder().url(WS_URL)&#10;&#10;            // Nur Authorization Header hinzufügen wenn Token verfügbar ist&#10;            token?.let {&#10;                requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $it&quot;)&#10;                Log.d(TAG, &quot;Added Authorization header to WebSocket request&quot;)&#10;            } ?: Log.w(TAG, &quot;No token available for WebSocket connection&quot;)&#10;&#10;            val request = requestBuilder.build()&#10;            webSocket = client.newWebSocket(request, webSocketListener)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to connect: ${e.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;        }&#10;    }&#10;&#10;    private fun sendStompConnect() {&#10;        val connectFrame = buildString {&#10;            append(&quot;CONNECT\n&quot;)&#10;            append(&quot;accept-version:1.0,1.1,2.0\n&quot;)&#10;            append(&quot;heart-beat:5000,5000\n&quot;)&#10;            playerId?.let { append(&quot;login:$it\n&quot;) }&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(connectFrame)&#10;        Log.d(TAG, &quot;Sent STOMP CONNECT frame&quot;)&#10;    }&#10;&#10;    private fun subscribeToTopics() {&#10;        Log.d(TAG, &quot;Subscribing to topics&quot;)&#10;        playerId?.let { id -&gt;&#10;            // Subscribe zu persönlichen Nachrichten&#10;             // 200 ms warten&#10;            val subscribeFrame2 = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-2\n&quot;)&#10;                append(&quot;destination:/topic/players\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrame2)&#10;            Log.d(TAG, &quot;Subscribed to topics&quot;)&#10;&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                delay(200)&#10;                val subscribeFrame1 = buildString {&#10;                    append(&quot;SUBSCRIBE\n&quot;)&#10;                    append(&quot;id:sub-1\n&quot;)&#10;                    append(&quot;destination:/user/queue/status\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;                webSocket?.send(subscribeFrame1)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                sendHeartbeat()&#10;                delay(HEARTBEAT_INTERVAL)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Heartbeat started&quot;)&#10;    }&#10;&#10;    private fun sendHeartbeat() {&#10;        playerId?.let { id -&gt;&#10;            val heartbeatFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/heartbeat\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;heartbeat&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(heartbeatFrame)&#10;            Log.d(TAG, &quot;Sent heartbeat for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleStompMessage(message: String) {&#10;        try {&#10;            // Auf CONNECTED Frame vom Server prüfen&#10;            if (message.startsWith(&quot;CONNECTED&quot;)) {&#10;                Log.d(TAG, &quot;Received STOMP CONNECTED frame from server&quot;)&#10;                // Jetzt erst die Subscriptions starten, wenn der Server die Verbindung bestätigt hat&#10;                subscribeToTopics()&#10;                return&#10;            }&#10;&#10;            if (message.startsWith(&quot;MESSAGE&quot;)) {&#10;                val lines = message.split(&quot;\n&quot;)&#10;                var body = &quot;&quot;&#10;                var isBody = false&#10;&#10;                for (line in lines) {&#10;                    if (isBody) {&#10;                        body += line&#10;                    } else if (line.isEmpty()) {&#10;                        isBody = true&#10;                    }&#10;                }&#10;&#10;                // Entferne Null-Terminator&#10;                body = body.replace(MESSAGE_END, &quot;&quot;)&#10;&#10;                if (body.isNotEmpty()) {&#10;                    handleMessageBody(body)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error handling STOMP message: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleMessageBody(body: String) {&#10;        try {&#10;            val json = JSONObject(body)&#10;            val type = json.optString(&quot;type&quot;)&#10;&#10;            when (type) {&#10;                &quot;status-update&quot; -&gt; {&#10;                    val status = json.optString(&quot;status&quot;)&#10;                    Log.d(TAG, &quot;Status update received: $status&quot;)&#10;                    &#10;                    // Server-Status verarbeiten&#10;                    updateServerStatus(status)&#10;                }&#10;&#10;                &quot;lobby-message&quot; -&gt; {&#10;                    // Lobby-spezifische Nachrichten verarbeiten&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val messageContent = json.optString(&quot;message&quot;)&#10;&#10;                    if (lobbyId == currentLobbyId) {&#10;                        // Nur Nachrichten für den aktuellen Lobby-Kontext weiterleiten&#10;                        _lobbyMessages.value = _lobbyMessages.value + messageContent&#10;                        Log.d(TAG, &quot;Lobby message received: $messageContent&quot;)&#10;                        // Optional: Direktes Handling der Nachricht über den Handler&#10;                        lobbyMessageHandler?.invoke(messageContent)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Füge Nachricht zur Liste hinzu&#10;            val currentMessages = _connectionMessages.value.toMutableList()&#10;            currentMessages.add(body)&#10;            if (currentMessages.size &gt; 50) { // Begrenze auf 50 Nachrichten&#10;                currentMessages.removeAt(0)&#10;            }&#10;            _connectionMessages.value = currentMessages&#10;&#10;            // Aktualisiere den Zeitstempel der letzten Nachricht&#10;            _lastMessageTimestamp.value = System.currentTimeMillis()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error parsing message body: ${e.message}&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Aktualisiert den Server-Status basierend auf dem erhaltenen Status-String&#10;     */&#10;    private fun updateServerStatus(status: String) {&#10;        val newStatus = when (status.lowercase()) {&#10;            &quot;online&quot; -&gt; ServerStatus.ONLINE&#10;            &quot;offline&quot; -&gt; ServerStatus.OFFLINE&#10;            &quot;busy&quot; -&gt; ServerStatus.BUSY&#10;            &quot;maintenance&quot; -&gt; ServerStatus.MAINTENANCE&#10;            else -&gt; ServerStatus.UNKNOWN&#10;        }&#10;        &#10;        _serverStatus.value = newStatus&#10;        Log.d(TAG, &quot;Server status updated to: $newStatus&quot;)&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;        heartbeatJob = null&#10;        Log.d(TAG, &quot;Heartbeat stopped&quot;)&#10;    }&#10;&#10;    private fun scheduleReconnect() {&#10;        if (reconnectJob?.isActive == true) return&#10;&#10;        reconnectJob = CoroutineScope(Dispatchers.IO).launch {&#10;            delay(RECONNECT_DELAY)&#10;            playerId?.let { id -&gt;&#10;                if (_connectionState.value == ConnectionState.DISCONNECTED) {&#10;                    Log.d(TAG, &quot;Attempting to reconnect...&quot;)&#10;                    _connectionState.value = ConnectionState.RECONNECTING&#10;                    connect(id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        Log.d(TAG, &quot;Disconnecting WebSocket&quot;)&#10;        stopHeartbeat()&#10;        reconnectJob?.cancel()&#10;&#10;        // Sende App-Closing-Nachricht an Server bevor Verbindung getrennt wird&#10;        sendAppClosingMessage()&#10;&#10;        // Kurz warten damit Nachricht gesendet werden kann&#10;        Thread.sleep(100)&#10;&#10;        // Sende DISCONNECT Frame&#10;        val disconnectFrame = buildString {&#10;            append(&quot;DISCONNECT\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(disconnectFrame)&#10;        webSocket?.close(1000, &quot;Client disconnecting&quot;)&#10;        webSocket = null&#10;&#10;        _connectionState.value = ConnectionState.DISCONNECTED&#10;    }&#10;&#10;    private fun sendAppClosingMessage() {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;app-shutdown&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageSync() {&#10;        // Synchrone Version für App-Shutdown&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            sendAppClosingMessage()&#10;            Thread.sleep(200) // Etwas länger warten für synchronen Aufruf&#10;        }&#10;    }&#10;&#10;    fun leaveLobbyOnAppClosing() {&#10;        if (lobbyListener == null) {&#10;            Log.w(TAG, &quot;LobbyListener is not set. Cannot leave lobby on app closing.&quot;)&#10;        } else {&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val currentLobby = lobbyListener!!.currentLobby.value&#10;                Log.d(&quot;StompWebSocket&quot;, &quot;checking if in a lobby: current Lobby: $currentLobby&quot;)&#10;                currentLobby?.let {&#10;                    lobbyListener!!.leaveLobby(it.lobbyId)&#10;                        .onSuccess {&#10;                            Log.d(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Successfully left lobby ${currentLobby.lobbyId} during app closing&quot;&#10;                            )&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            Log.e(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Failed to leave lobby during app closing&quot;,&#10;                                exception&#10;                            )&#10;                        }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageWithReason(reason: String) {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;$reason&quot;,&quot;timestamp&quot;:&quot;${System.currentTimeMillis()}&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id with reason: $reason&quot;)&#10;&#10;            // Kurz warten damit Nachricht gesendet werden kann&#10;            Thread.sleep(150)&#10;        }&#10;    }&#10;&#10;    fun requestOnlinePlayers() {&#10;        playerId?.let { id -&gt;&#10;            val requestFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/players\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;request&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(requestFrame)&#10;            Log.d(TAG, &quot;Requested online players list&quot;)&#10;        }&#10;    }&#10;&#10;    fun setLobbyMessageHandler(handler: (String) -&gt; Unit) {&#10;        lobbyMessageHandler = handler&#10;    }&#10;&#10;    fun isConnected(): Boolean = _connectionState.value == ConnectionState.CONNECTED&#10;&#10;    // Lobby-spezifische Funktionen&#10;&#10;    fun subscribeToLobby(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu lobby-spezifischen Topics&#10;        val subscribeLobbyFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/lobby/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(subscribeLobbyFrame)&#10;        Log.d(TAG, &quot;Subscribed to lobby updates: $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromLobby() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            Log.d(&#10;                TAG,&#10;                &quot;Sending STOMP unsubscribe frame: ${unsubscribeFrame.replace(MESSAGE_END, &quot;[NULL]&quot;)}&quot;&#10;            )&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId = null&#10;    }&#10;&#10;    fun sendLobbyChat(message: String) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val chatFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/chat\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;chat&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;message&quot;:&quot;$message&quot;}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(chatFrame)&#10;                Log.d(TAG, &quot;Sent lobby chat message: $message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPlayerReady(ready: Boolean) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val readyFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/ready\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;player-ready&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;ready&quot;:$ready}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(readyFrame)&#10;                Log.d(TAG, &quot;Sent player ready status: $ready&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Legacy-Methoden für Kompatibilität (werden intern umgeleitet)&#10;    fun joinLobby(lobbyId: String) {&#10;        subscribeToLobby(lobbyId)&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        unsubscribeFromLobby()&#10;    }&#10;&#10;    fun sendLobbyMessage(message: String) {&#10;        sendLobbyChat(message)&#10;    }&#10;&#10;    /**&#10;     * Startet die periodische Überprüfung des Server-Status&#10;     */&#10;    private fun startServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                // Prüfen, ob der letzte Nachrichtenzeitpunkt zu lange her ist&#10;                val currentTime = System.currentTimeMillis()&#10;                val lastMessageTime = _lastMessageTimestamp.value&#10;                &#10;                if (lastMessageTime &gt; 0 &amp;&amp; (currentTime - lastMessageTime) &gt; SERVER_STATUS_TIMEOUT) {&#10;                    // Wenn länger als 10 Sekunden keine Nachricht empfangen wurde, Status auf OFFLINE setzen&#10;                    _serverStatus.value = ServerStatus.OFFLINE&#10;                    Log.d(TAG, &quot;Server status set to OFFLINE due to timeout (no message in ${SERVER_STATUS_TIMEOUT/1000} seconds)&quot;)&#10;                }&#10;                &#10;                delay(1000) // Alle Sekunde prüfen&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Server status check started&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Stoppt die periodische Überprüfung des Server-Status&#10;     */&#10;    private fun stopServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = null&#10;        Log.d(TAG, &quot;Server status check stopped&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>