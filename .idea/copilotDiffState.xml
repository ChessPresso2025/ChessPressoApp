<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt" />
              <option name="originalContent" value="package app.chesspresso.di&#10;&#10;import android.content.Context&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.auth.data.AuthApi&#10;import app.chesspresso.data.api.AuthApi as JwtAuthApi&#10;import app.chesspresso.data.api.GameApi&#10;import app.chesspresso.data.network.AuthInterceptor&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyService&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideTokenStorage(@ApplicationContext context: Context): TokenStorage {&#10;        return TokenStorage(context)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(tokenStorage: TokenStorage): AuthInterceptor {&#10;        return AuthInterceptor(tokenStorage)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://10.0.2.2:8080/&quot;) // Android Emulator localhost&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#10;        return retrofit.create(AuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideJwtAuthApi(retrofit: Retrofit): JwtAuthApi {&#10;        return retrofit.create(JwtAuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameApi(retrofit: Retrofit): GameApi {&#10;        return retrofit.create(GameApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLobbyApiService(retrofit: Retrofit): LobbyApiService {&#10;        return retrofit.create(LobbyApiService::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGson(): Gson {&#10;        return Gson()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLobbyService(&#10;        lobbyApiService: LobbyApiService,&#10;        webSocketService: StompWebSocketService,&#10;        gson: Gson&#10;    ): LobbyService {&#10;        return LobbyService(lobbyApiService, webSocketService, gson)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApi: AuthApi,&#10;        jwtAuthApi: JwtAuthApi,&#10;        tokenStorage: TokenStorage,&#10;        @ApplicationContext context: Context,&#10;        webSocketService: StompWebSocketService&#10;    ): AuthRepository {&#10;        return AuthRepository(authApi, jwtAuthApi, tokenStorage, context, webSocketService)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideStompWebSocketService(&#10;        tokenStorage: TokenStorage&#10;    ): StompWebSocketService {&#10;        return StompWebSocketService(tokenStorage)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.di&#10;&#10;import android.content.Context&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.auth.data.AuthApi&#10;import app.chesspresso.data.api.AuthApi as JwtAuthApi&#10;import app.chesspresso.data.api.GameApi&#10;import app.chesspresso.data.network.AuthInterceptor&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyService&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideTokenStorage(@ApplicationContext context: Context): TokenStorage {&#10;        return TokenStorage(context)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(tokenStorage: TokenStorage): AuthInterceptor {&#10;        return AuthInterceptor(tokenStorage)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://10.0.2.2:8080/&quot;) // Android Emulator localhost&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#10;        return retrofit.create(AuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideJwtAuthApi(retrofit: Retrofit): JwtAuthApi {&#10;        return retrofit.create(JwtAuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameApi(retrofit: Retrofit): GameApi {&#10;        return retrofit.create(GameApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLobbyApiService(retrofit: Retrofit): LobbyApiService {&#10;        return retrofit.create(LobbyApiService::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGson(): Gson {&#10;        return Gson()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLobbyService(&#10;        lobbyApiService: LobbyApiService,&#10;        webSocketService: StompWebSocketService,&#10;        gson: Gson&#10;    ): LobbyService {&#10;        return LobbyService(lobbyApiService, webSocketService, gson)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApi: AuthApi,&#10;        jwtAuthApi: JwtAuthApi,&#10;        tokenStorage: TokenStorage,&#10;        @ApplicationContext context: Context,&#10;        webSocketService: StompWebSocketService&#10;    ): AuthRepository {&#10;        return AuthRepository(authApi, jwtAuthApi, tokenStorage, context, webSocketService)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideStompWebSocketService(&#10;        tokenStorage: TokenStorage&#10;    ): StompWebSocketService {&#10;        return StompWebSocketService(tokenStorage)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/service/LobbyService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/service/LobbyService.kt" />
              <option name="originalContent" value="package app.chesspresso.service&#10;&#10;import android.util.Log&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.model.lobby.*&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LobbyService @Inject constructor(&#10;    private val lobbyApiService: LobbyApiService,&#10;    private val webSocketService: StompWebSocketService,&#10;    private val gson: Gson&#10;) {&#10;    private val _currentLobby = MutableStateFlow&lt;Lobby?&gt;(null)&#10;    val currentLobby: StateFlow&lt;Lobby?&gt; = _currentLobby.asStateFlow()&#10;&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;LobbyMessage&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;LobbyMessage&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    private val _lobbyError = MutableStateFlow&lt;String?&gt;(null)&#10;    val lobbyError: StateFlow&lt;String?&gt; = _lobbyError.asStateFlow()&#10;&#10;    private val _isWaitingForMatch = MutableStateFlow(false)&#10;    val isWaitingForMatch: StateFlow&lt;Boolean&gt; = _isWaitingForMatch.asStateFlow()&#10;&#10;    private val _gameStarted = MutableStateFlow&lt;GameStartMessage?&gt;(null)&#10;    val gameStarted: StateFlow&lt;GameStartMessage?&gt; = _gameStarted.asStateFlow()&#10;&#10;    init {&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            handleWebSocketMessage(message)&#10;        }&#10;    }&#10;&#10;    // Quick Match beitreten&#10;    suspend fun joinQuickMatch(gameTime: GameTime): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinQuickMatch(QuickJoinRequest(gameTime))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyId = response.body()?.lobbyId ?: return Result.failure(Exception(&quot;Keine Lobby-ID erhalten&quot;))&#10;                _isWaitingForMatch.value = true&#10;                &#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyId)&#10;                &#10;                Log.d(&quot;LobbyService&quot;, &quot;Quick Match erfolgreich beigetreten: $lobbyId&quot;)&#10;                Result.success(lobbyId)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Unbekannter Fehler beim Quick Match&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Quick Match beitreten&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby erstellen&#10;    suspend fun createPrivateLobby(): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.createPrivateLobby()&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyCode = response.body()?.lobbyCode ?: return Result.failure(Exception(&quot;Kein Lobby-Code erhalten&quot;))&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Erstellen der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Erstellen der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby beitreten&#10;    suspend fun joinPrivateLobby(lobbyCode: String): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinPrivateLobby(JoinPrivateLobbyRequest(lobbyCode))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby beigetreten: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Beitreten der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Beitreten der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby verlassen&#10;    suspend fun leaveLobby(lobbyId: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Zuerst WebSocket-Subscription beenden&#10;            webSocketService.unsubscribeFromLobby()&#10;            &#10;            val response = lobbyApiService.leaveLobby(LeaveLobbyRequest(lobbyId))&#10;            if (response.isSuccessful) {&#10;                _currentLobby.value = null&#10;                _isWaitingForMatch.value = false&#10;                _lobbyMessages.value = emptyList()&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Lobby verlassen: $lobbyId&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Verlassen der Lobby&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verlassen der Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby-Info abrufen&#10;    suspend fun getLobbyInfo(lobbyId: String): Result&lt;Lobby&gt; {&#10;        return try {&#10;            val response = lobbyApiService.getLobbyInfo(lobbyId)&#10;            if (response.isSuccessful) {&#10;                val lobbyInfo = response.body() ?: return Result.failure(Exception(&quot;Keine Lobby-Daten erhalten&quot;))&#10;&#10;                // Sichere Behandlung von gameTime - kann null oder &quot;null&quot; sein&#10;                val gameTime = when {&#10;                    lobbyInfo.gameTime == null -&gt; null&#10;                    lobbyInfo.gameTime == &quot;null&quot; -&gt; null&#10;                    lobbyInfo.gameTime.isBlank() -&gt; null&#10;                    else -&gt; try {&#10;                        GameTime.valueOf(lobbyInfo.gameTime)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        Log.w(&quot;LobbyService&quot;, &quot;Unbekannte GameTime: ${lobbyInfo.gameTime}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val lobby = Lobby(&#10;                    lobbyId = lobbyInfo.lobbyId,&#10;                    lobbyType = LobbyType.valueOf(lobbyInfo.lobbyType),&#10;                    gameTime = gameTime,&#10;                    players = lobbyInfo.players,&#10;                    creator = lobbyInfo.creator,&#10;                    isGameStarted = lobbyInfo.isGameStarted,&#10;                    status = LobbyStatus.valueOf(lobbyInfo.status)&#10;                )&#10;                _currentLobby.value = lobby&#10;                Result.success(lobby)&#10;            } else {&#10;                Result.failure(Exception(&quot;Lobby nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Abrufen der Lobby-Info&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // WebSocket-Nachrichten verarbeiten&#10;    fun handleWebSocketMessage(message: String) {&#10;        try {&#10;            Log.d(&quot;LobbyService&quot;, &quot;WebSocket-Nachricht erhalten: $message&quot;)&#10;&#10;            // Parse JSON-Nachricht&#10;            val jsonObject = gson.fromJson(message, Map::class.java)&#10;            val messageType = jsonObject[&quot;type&quot;] as? String&#10;&#10;            when (messageType) {&#10;                &quot;lobby-waiting&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val waitingMessage = jsonObject[&quot;message&quot;] as? String&#10;                    _isWaitingForMatch.value = true&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Warte auf Gegner in Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-error&quot; -&gt; {&#10;                    val error = jsonObject[&quot;error&quot;] as? String ?: &quot;Unbekannter Lobby-Fehler&quot;&#10;                    _lobbyError.value = error&#10;                    _isWaitingForMatch.value = false&#10;                    Log.e(&quot;LobbyService&quot;, &quot;Lobby-Fehler: $error&quot;)&#10;                }&#10;&#10;                &quot;player-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val newPlayerId = jsonObject[&quot;newPlayerId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler beigetreten: $newPlayerId - $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val creatorId = jsonObject[&quot;creatorId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status,&#10;                                creator = creatorId ?: currentLobby.creator&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby erfolgreich beigetreten: $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-update&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val updateMessage = jsonObject[&quot;message&quot;] as? String&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby-Update: $updateMessage&quot;)&#10;                }&#10;&#10;                &quot;game-start&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String ?: &quot;&quot;&#10;                    val gameTime = jsonObject[&quot;gameTime&quot;] as? String ?: &quot;&quot;&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#10;                    val lobbyChannel = jsonObject[&quot;lobbyChannel&quot;] as? String ?: &quot;&quot;&#10;&#10;                    val gameStart = GameStartMessage(&#10;                        lobbyId = lobbyId,&#10;                        gameTime = gameTime,&#10;                        whitePlayer = whitePlayer,&#10;                        blackPlayer = blackPlayer,&#10;                        lobbyChannel = lobbyChannel&#10;                    )&#10;&#10;                    _gameStarted.value = gameStart&#10;                    _isWaitingForMatch.value = false&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spiel startet! Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-created&quot; -&gt; {&#10;                    val lobbyCode = jsonObject[&quot;lobbyCode&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode - $message&quot;)&#10;                }&#10;&#10;                &quot;PLAYER_READY&quot; -&gt; {&#10;                    val playerId = jsonObject[&quot;playerId&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler bereit: $playerId&quot;)&#10;                    // Hier könntest du den Ready-Status in der UI anzeigen&#10;                }&#10;&#10;                &quot;GAME_START&quot; -&gt; {&#10;                    // Alternative Behandlung für direktes GAME_START&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#10;                    val gameTimeObj = jsonObject[&quot;gameTime&quot;]&#10;&#10;                    // Extrahiere gameTime richtig&#10;                    val gameTime = when (gameTimeObj) {&#10;                        is String -&gt; gameTimeObj&#10;                        is Map&lt;*, *&gt; -&gt; gameTimeObj[&quot;name&quot;] as? String ?: &quot;MIDDLE&quot;&#10;                        else -&gt; &quot;MIDDLE&quot;&#10;                    }&#10;&#10;                    val gameStart = GameStartMessage(&#10;                        lobbyId = _currentLobby.value?.lobbyId ?: &quot;&quot;,&#10;                        gameTime = gameTime,&#10;                        whitePlayer = whitePlayer,&#10;                        blackPlayer = blackPlayer,&#10;                        lobbyChannel = &quot;&quot;&#10;                    )&#10;&#10;                    _gameStarted.value = gameStart&#10;                    _isWaitingForMatch.value = false&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Direkter Spielstart erkannt&quot;)&#10;                }&#10;&#10;                else -&gt; {&#10;                    // Versuche Legacy-Format zu parsen&#10;                    when {&#10;                        message.contains(&quot;\&quot;error\&quot;&quot;) -&gt; {&#10;                            val errorMsg = gson.fromJson(message, LobbyErrorMessage::class.java)&#10;                            _lobbyError.value = errorMsg.error&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;                        message.contains(&quot;\&quot;lobbyId\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;message\&quot;&quot;) -&gt; {&#10;                            val waitingMsg = gson.fromJson(message, LobbyWaitingMessage::class.java)&#10;                            _isWaitingForMatch.value = true&#10;                        }&#10;                        message.contains(&quot;\&quot;gameTime\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;whitePlayer\&quot;&quot;) -&gt; {&#10;                            val gameStart = gson.fromJson(message, GameStartMessage::class.java)&#10;                            _gameStarted.value = gameStart&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;                        else -&gt; {&#10;                            Log.w(&quot;LobbyService&quot;, &quot;Unbekannter Nachrichtentyp: $message&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verarbeiten der WebSocket-Nachricht: $message&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für Lobby-Chat-Nachrichten&#10;    fun sendLobbyMessage(lobbyId: String, content: String) {&#10;        webSocketService.sendLobbyChat(content)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Sende Chat-Nachricht in Lobby $lobbyId: $content&quot;)&#10;    }&#10;&#10;    // Neue Methode für Player-Ready-Status&#10;    fun setPlayerReady(lobbyId: String, ready: Boolean) {&#10;        webSocketService.sendPlayerReady(ready)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Setze Spieler-Status: ${if (ready) &quot;bereit&quot; else &quot;nicht bereit&quot;}&quot;)&#10;    }&#10;&#10;    // Fehler zurücksetzen&#10;    fun clearError() {&#10;        _lobbyError.value = null&#10;    }&#10;&#10;    // Spiel-Start zurücksetzen&#10;    fun clearGameStart() {&#10;        _gameStarted.value = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.service&#10;&#10;import android.util.Log&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.model.lobby.*&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LobbyService @Inject constructor(&#10;    private val lobbyApiService: LobbyApiService,&#10;    private val webSocketService: StompWebSocketService,&#10;    private val gson: Gson&#10;) {&#10;    private val _currentLobby = MutableStateFlow&lt;Lobby?&gt;(null)&#10;    val currentLobby: StateFlow&lt;Lobby?&gt; = _currentLobby.asStateFlow()&#10;&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;LobbyMessage&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;LobbyMessage&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    private val _lobbyError = MutableStateFlow&lt;String?&gt;(null)&#10;    val lobbyError: StateFlow&lt;String?&gt; = _lobbyError.asStateFlow()&#10;&#10;    private val _isWaitingForMatch = MutableStateFlow(false)&#10;    val isWaitingForMatch: StateFlow&lt;Boolean&gt; = _isWaitingForMatch.asStateFlow()&#10;&#10;    private val _gameStarted = MutableStateFlow&lt;GameStartMessage?&gt;(null)&#10;    val gameStarted: StateFlow&lt;GameStartMessage?&gt; = _gameStarted.asStateFlow()&#10;&#10;    init {&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            handleWebSocketMessage(message)&#10;        }&#10;    }&#10;&#10;    // Quick Match beitreten&#10;    suspend fun joinQuickMatch(gameTime: GameTime): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinQuickMatch(QuickJoinRequest(gameTime))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyId = response.body()?.lobbyId ?: return Result.failure(Exception(&quot;Keine Lobby-ID erhalten&quot;))&#10;                _isWaitingForMatch.value = true&#10;                &#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyId)&#10;                &#10;                Log.d(&quot;LobbyService&quot;, &quot;Quick Match erfolgreich beigetreten: $lobbyId&quot;)&#10;                Result.success(lobbyId)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Unbekannter Fehler beim Quick Match&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Quick Match beitreten&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby erstellen&#10;    suspend fun createPrivateLobby(): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.createPrivateLobby()&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyCode = response.body()?.lobbyCode ?: return Result.failure(Exception(&quot;Kein Lobby-Code erhalten&quot;))&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Erstellen der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Erstellen der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby beitreten&#10;    suspend fun joinPrivateLobby(lobbyCode: String): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinPrivateLobby(JoinPrivateLobbyRequest(lobbyCode))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby beigetreten: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Beitreten der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Beitreten der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby verlassen&#10;    suspend fun leaveLobby(lobbyId: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Zuerst WebSocket-Subscription beenden&#10;            webSocketService.unsubscribeFromLobby()&#10;            &#10;            val response = lobbyApiService.leaveLobby(LeaveLobbyRequest(lobbyId))&#10;            if (response.isSuccessful) {&#10;                _currentLobby.value = null&#10;                _isWaitingForMatch.value = false&#10;                _lobbyMessages.value = emptyList()&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Lobby verlassen: $lobbyId&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Verlassen der Lobby&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verlassen der Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby-Info abrufen&#10;    suspend fun getLobbyInfo(lobbyId: String): Result&lt;Lobby&gt; {&#10;        return try {&#10;            val response = lobbyApiService.getLobbyInfo(lobbyId)&#10;            if (response.isSuccessful) {&#10;                val lobbyInfo = response.body() ?: return Result.failure(Exception(&quot;Keine Lobby-Daten erhalten&quot;))&#10;&#10;                // Sichere Behandlung von gameTime - kann null oder &quot;null&quot; sein&#10;                val gameTime = when {&#10;                    lobbyInfo.gameTime == null -&gt; null&#10;                    lobbyInfo.gameTime == &quot;null&quot; -&gt; null&#10;                    lobbyInfo.gameTime.isBlank() -&gt; null&#10;                    else -&gt; try {&#10;                        GameTime.valueOf(lobbyInfo.gameTime)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        Log.w(&quot;LobbyService&quot;, &quot;Unbekannte GameTime: ${lobbyInfo.gameTime}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val lobby = Lobby(&#10;                    lobbyId = lobbyInfo.lobbyId,&#10;                    lobbyType = LobbyType.valueOf(lobbyInfo.lobbyType),&#10;                    gameTime = gameTime,&#10;                    players = lobbyInfo.players,&#10;                    creator = lobbyInfo.creator,&#10;                    isGameStarted = lobbyInfo.isGameStarted,&#10;                    status = LobbyStatus.valueOf(lobbyInfo.status)&#10;                )&#10;                _currentLobby.value = lobby&#10;                Result.success(lobby)&#10;            } else {&#10;                Result.failure(Exception(&quot;Lobby nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Abrufen der Lobby-Info&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // WebSocket-Nachrichten verarbeiten&#10;    fun handleWebSocketMessage(message: String) {&#10;        try {&#10;            Log.d(&quot;LobbyService&quot;, &quot;WebSocket-Nachricht erhalten: $message&quot;)&#10;&#10;            // Parse JSON-Nachricht&#10;            val jsonObject = gson.fromJson(message, Map::class.java)&#10;            val messageType = jsonObject[&quot;type&quot;] as? String&#10;&#10;            when (messageType) {&#10;                &quot;lobby-waiting&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val waitingMessage = jsonObject[&quot;message&quot;] as? String&#10;                    _isWaitingForMatch.value = true&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Warte auf Gegner in Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-error&quot; -&gt; {&#10;                    val error = jsonObject[&quot;error&quot;] as? String ?: &quot;Unbekannter Lobby-Fehler&quot;&#10;                    _lobbyError.value = error&#10;                    _isWaitingForMatch.value = false&#10;                    Log.e(&quot;LobbyService&quot;, &quot;Lobby-Fehler: $error&quot;)&#10;                }&#10;&#10;                &quot;player-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val newPlayerId = jsonObject[&quot;newPlayerId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler beigetreten: $newPlayerId - $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val creatorId = jsonObject[&quot;creatorId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status,&#10;                                creator = creatorId ?: currentLobby.creator&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby erfolgreich beigetreten: $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-update&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val updateMessage = jsonObject[&quot;message&quot;] as? String&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby-Update: $updateMessage&quot;)&#10;                }&#10;&#10;                &quot;game-start&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String ?: &quot;&quot;&#10;                    val gameTime = jsonObject[&quot;gameTime&quot;] as? String ?: &quot;&quot;&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#10;                    val lobbyChannel = jsonObject[&quot;lobbyChannel&quot;] as? String ?: &quot;&quot;&#10;&#10;                    val gameStart = GameStartMessage(&#10;                        lobbyId = lobbyId,&#10;                        gameTime = gameTime,&#10;                        whitePlayer = whitePlayer,&#10;                        blackPlayer = blackPlayer,&#10;                        lobbyChannel = lobbyChannel&#10;                    )&#10;&#10;                    _gameStarted.value = gameStart&#10;                    _isWaitingForMatch.value = false&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spiel startet! Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-created&quot; -&gt; {&#10;                    val lobbyCode = jsonObject[&quot;lobbyCode&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode - $message&quot;)&#10;                }&#10;&#10;                &quot;PLAYER_READY&quot; -&gt; {&#10;                    val playerId = jsonObject[&quot;playerId&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler bereit: $playerId&quot;)&#10;                    // Hier könntest du den Ready-Status in der UI anzeigen&#10;                }&#10;&#10;                &quot;GAME_START&quot; -&gt; {&#10;                    // Alternative Behandlung für direktes GAME_START&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#10;                    val gameTimeObj = jsonObject[&quot;gameTime&quot;]&#10;&#10;                    // Extrahiere gameTime richtig&#10;                    val gameTime = when (gameTimeObj) {&#10;                        is String -&gt; gameTimeObj&#10;                        is Map&lt;*, *&gt; -&gt; gameTimeObj[&quot;name&quot;] as? String ?: &quot;MIDDLE&quot;&#10;                        else -&gt; &quot;MIDDLE&quot;&#10;                    }&#10;&#10;                    val gameStart = GameStartMessage(&#10;                        lobbyId = _currentLobby.value?.lobbyId ?: &quot;&quot;,&#10;                        gameTime = gameTime,&#10;                        whitePlayer = whitePlayer,&#10;                        blackPlayer = blackPlayer,&#10;                        lobbyChannel = &quot;&quot;&#10;                    )&#10;&#10;                    _gameStarted.value = gameStart&#10;                    _isWaitingForMatch.value = false&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Direkter Spielstart erkannt&quot;)&#10;                }&#10;&#10;                else -&gt; {&#10;                    // Versuche Legacy-Format zu parsen&#10;                    when {&#10;                        message.contains(&quot;\&quot;error\&quot;&quot;) -&gt; {&#10;                            val errorMsg = gson.fromJson(message, LobbyErrorMessage::class.java)&#10;                            _lobbyError.value = errorMsg.error&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;                        message.contains(&quot;\&quot;lobbyId\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;message\&quot;&quot;) -&gt; {&#10;                            val waitingMsg = gson.fromJson(message, LobbyWaitingMessage::class.java)&#10;                            _isWaitingForMatch.value = true&#10;                        }&#10;                        message.contains(&quot;\&quot;gameTime\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;whitePlayer\&quot;&quot;) -&gt; {&#10;                            val gameStart = gson.fromJson(message, GameStartMessage::class.java)&#10;                            _gameStarted.value = gameStart&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;                        else -&gt; {&#10;                            Log.w(&quot;LobbyService&quot;, &quot;Unbekannter Nachrichtentyp: $message&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verarbeiten der WebSocket-Nachricht: $message&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für Lobby-Chat-Nachrichten&#10;    fun sendLobbyMessage(lobbyId: String, content: String) {&#10;        webSocketService.sendLobbyChat(content)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Sende Chat-Nachricht in Lobby $lobbyId: $content&quot;)&#10;    }&#10;&#10;    // Neue Methode für Player-Ready-Status&#10;    fun setPlayerReady(lobbyId: String, ready: Boolean) {&#10;        webSocketService.sendPlayerReady(ready)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Setze Spieler-Status: ${if (ready) &quot;bereit&quot; else &quot;nicht bereit&quot;}&quot;)&#10;    }&#10;&#10;    // Fehler zurücksetzen&#10;    fun clearError() {&#10;        _lobbyError.value = null&#10;    }&#10;&#10;    // Spiel-Start zurücksetzen&#10;    fun clearGameStart() {&#10;        _gameStarted.value = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>