<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    alias(libs.plugins.kotlin.serialization)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Base URL für API konfigurierbar&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.1&quot;&#10;    }&#10;    packagingOptions {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.material3)&#10;&#10;    // Lifecycle Process dependency für ProcessLifecycleOwner&#10;    implementation(&quot;androidx.lifecycle:lifecycle-process:2.7.0&quot;)&#10;    implementation(libs.androidx.foundation)&#10;    implementation(libs.androidx.material3.lint)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;    // DataStore für Token-Speicherung&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // STOMP WebSocket dependencies&#10;    implementation(&quot;org.java-websocket:Java-WebSocket:1.5.3&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // QR Code Scanner dependencies&#10;    implementation(&quot;com.journeyapps:zxing-android-embedded:4.3.0&quot;)&#10;    implementation(&quot;com.google.zxing:core:3.5.2&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.3.1&quot;)&#10;&#10;    // AppCompat für QRScannerActivity&#10;    implementation(&quot;androidx.appcompat:appcompat:1.6.1&quot;)&#10;&#10;    // ML Kit für QR-Code Erkennung&#10;    implementation(&quot;com.google.mlkit:barcode-scanning:17.2.0&quot;)&#10;&#10;    // Json&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3&quot;)&#10;&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.1&quot;)&#10;}" />
              <option name="updatedContent" value="plugins {&#13;&#10;    alias(libs.plugins.android.application)&#13;&#10;    alias(libs.plugins.kotlin.android)&#13;&#10;    alias(libs.plugins.kotlin.compose)&#13;&#10;    alias(libs.plugins.hilt.android)&#13;&#10;    alias(libs.plugins.kotlin.serialization)&#13;&#10;    kotlin(&quot;kapt&quot;)&#13;&#10;}&#13;&#10;&#13;&#10;android {&#13;&#10;    namespace = &quot;app.chesspresso&quot;&#13;&#10;    compileSdk = 35&#13;&#10;&#13;&#10;    defaultConfig {&#13;&#10;        applicationId = &quot;app.chesspresso&quot;&#13;&#10;        minSdk = 24&#13;&#10;        targetSdk = 35&#13;&#10;        versionCode = 1&#13;&#10;        versionName = &quot;1.0&quot;&#13;&#10;&#13;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#13;&#10;&#13;&#10;        // Base URL für API konfigurierbar&#13;&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    buildTypes {&#13;&#10;        release {&#13;&#10;            isMinifyEnabled = false&#13;&#10;            proguardFiles(&#13;&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#13;&#10;                &quot;proguard-rules.pro&quot;&#13;&#10;            )&#13;&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#13;&#10;        }&#13;&#10;        debug {&#13;&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    compileOptions {&#13;&#10;        sourceCompatibility = JavaVersion.VERSION_11&#13;&#10;        targetCompatibility = JavaVersion.VERSION_11&#13;&#10;    }&#13;&#10;    kotlinOptions {&#13;&#10;        jvmTarget = &quot;11&quot;&#13;&#10;    }&#13;&#10;    buildFeatures {&#13;&#10;        compose = true&#13;&#10;        buildConfig = true&#13;&#10;    }&#13;&#10;    composeOptions {&#13;&#10;        kotlinCompilerExtensionVersion = &quot;1.5.1&quot;&#13;&#10;    }&#13;&#10;    packagingOptions {&#13;&#10;        resources {&#13;&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;dependencies {&#13;&#10;&#13;&#10;    implementation(libs.androidx.core.ktx)&#13;&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#13;&#10;    implementation(libs.androidx.activity.compose)&#13;&#10;    implementation(platform(libs.androidx.compose.bom))&#13;&#10;    implementation(libs.androidx.ui)&#13;&#10;    implementation(libs.androidx.ui.graphics)&#13;&#10;    implementation(libs.androidx.ui.tooling.preview)&#13;&#10;    implementation(libs.androidx.material3)&#13;&#10;    implementation(libs.androidx.navigation.compose)&#13;&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#13;&#10;    implementation(libs.material3)&#13;&#10;&#13;&#10;    // Lifecycle Process dependency für ProcessLifecycleOwner&#13;&#10;    implementation(&quot;androidx.lifecycle:lifecycle-process:2.7.0&quot;)&#13;&#10;    implementation(libs.androidx.foundation)&#13;&#10;    implementation(libs.androidx.material3.lint)&#13;&#10;&#13;&#10;    testImplementation(libs.junit)&#13;&#10;    androidTestImplementation(libs.androidx.junit)&#13;&#10;    androidTestImplementation(libs.androidx.espresso.core)&#13;&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#13;&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#13;&#10;    debugImplementation(libs.androidx.ui.tooling)&#13;&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#13;&#10;&#13;&#10;    //Hilt dependencies&#13;&#10;    implementation(libs.hilt.android)&#13;&#10;    kapt(libs.dagger.hilt.compiler)&#13;&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#13;&#10;&#13;&#10;    //javax.inject&#13;&#10;    implementation(libs.javax.inject)&#13;&#10;&#13;&#10;&#13;&#10;    // Retrofit dependencies&#13;&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#13;&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#13;&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#13;&#10;&#13;&#10;    // DataStore für Token-Speicherung&#13;&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#13;&#10;&#13;&#10;    // STOMP WebSocket dependencies&#13;&#10;    implementation(&quot;org.java-websocket:Java-WebSocket:1.5.3&quot;)&#13;&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)&#13;&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)&#13;&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#13;&#10;&#13;&#10;    // QR Code Scanner dependencies&#13;&#10;    implementation(&quot;com.journeyapps:zxing-android-embedded:4.3.0&quot;)&#13;&#10;    implementation(&quot;com.google.zxing:core:3.5.2&quot;)&#13;&#10;    implementation(&quot;androidx.camera:camera-camera2:1.3.1&quot;)&#13;&#10;    implementation(&quot;androidx.camera:camera-lifecycle:1.3.1&quot;)&#13;&#10;    implementation(&quot;androidx.camera:camera-view:1.3.1&quot;)&#13;&#10;&#13;&#10;    // AppCompat für QRScannerActivity&#13;&#10;    implementation(&quot;androidx.appcompat:appcompat:1.6.1&quot;)&#13;&#10;&#13;&#10;    // ML Kit für QR-Code Erkennung&#13;&#10;    implementation(&quot;com.google.mlkit:barcode-scanning:17.2.0&quot;)&#13;&#10;&#13;&#10;    // Json&#13;&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.3&quot;)&#13;&#10;&#13;&#10;    implementation(&quot;androidx.compose.material:material-icons-extended:1.5.1&quot;)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import app.chesspresso.auth.presentation.AuthState&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import app.chesspresso.ui.theme.CoffeeTextField&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Email&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.lint.kotlin.metadata.Visibility&#10;&#10;@Composable&#10;fun LoginScreen(&#10;    navController: NavController,&#10;    authViewModel: AuthViewModel&#10;) {&#10;    val authState by authViewModel.authState.collectAsState()&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    var isRegistering by remember { mutableStateOf(false) }&#10;    var username by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;&#10;    // Vorausgefüllter Benutzername, falls vorhanden&#10;    val storedUsername = remember { authViewModel.getStoredUsername() }&#10;    if (username.isEmpty() &amp;&amp; storedUsername != null) {&#10;        username = storedUsername&#10;    }&#10;&#10;    // Navigation nach erfolgreichem Login&#10;    LaunchedEffect(authState) {&#10;        if (authState is AuthState.Success) {&#10;            navController.navigate(&quot;main&quot;) {&#10;                popUpTo(&quot;login&quot;) { inclusive = true }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Snackbar für Fehler&#10;    LaunchedEffect(authState) {&#10;        when (val state = authState) {&#10;            is AuthState.Error -&gt; {&#10;                snackbarHostState.showSnackbar(state.message)&#10;            }&#10;&#10;            else -&gt; {}&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        CoffeeCard(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp)&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                modifier = Modifier.padding(24.dp)&#10;            ) {&#10;                CoffeeHeadlineText(&#10;                    text = if (isRegistering) &quot;Registrierung&quot; else &quot;Anmeldung&quot;,&#10;                    fontSizeSp = 24&#10;                )&#10;&#10;                CoffeeTextField(&#10;                    value = username,&#10;                    onValueChange = { username = it },&#10;                    label = &quot;Benutzername&quot;,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    singleLine = true,&#10;                    enabled = authState !is AuthState.Loading,&#10;                    leadingIcon = { androidx.compose.material3.Icon(Icons.Filled.Person, contentDescription = &quot;Benutzername&quot;) }&#10;                )&#10;&#10;                if (isRegistering) {&#10;                    CoffeeTextField(&#10;                        value = email,&#10;                        onValueChange = { email = it },&#10;                        label = &quot;E-Mail&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        enabled = authState !is AuthState.Loading,&#10;                        leadingIcon = { androidx.compose.material3.Icon(Icons.Filled.Email, contentDescription = &quot;E-Mail&quot;) }&#10;                    )&#10;                }&#10;&#10;                CoffeeTextField(&#10;                    value = password,&#10;                    onValueChange = { password = it },&#10;                    label = &quot;Passwort&quot;,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    singleLine = true,&#10;                    enabled = authState !is AuthState.Loading,&#10;                    visualTransformation = if (passwordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                    leadingIcon = { androidx.compose.material3.Icon(Icons.Filled.Lock, contentDescription = &quot;Passwort&quot;) },&#10;                    trailingIcon = {&#10;                        val image = if (passwordVisible) Icons.Filled.VisibilityOff else Icons.Filled.Visibility&#10;                        val desc = if (passwordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                        androidx.compose.material3.IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                            androidx.compose.material3.Icon(image, contentDescription = desc)&#10;                        }&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CoffeeButton(&#10;                    onClick = {&#10;                        if (isRegistering) {&#10;                            if (username.isNotBlank() &amp;&amp; password.isNotBlank() &amp;&amp; email.isNotBlank()) {&#10;                                authViewModel.register(username.trim(), password, email.trim())&#10;                            } else {&#10;                                authViewModel.setErrorMessage(&quot;Alle Felder müssen ausgefüllt werden&quot;)&#10;                            }&#10;                        } else {&#10;                            if (username.isNotBlank() &amp;&amp; password.isNotBlank()) {&#10;                                authViewModel.login(username.trim(), password)&#10;                            } else {&#10;                                authViewModel.setErrorMessage(&quot;Benutzername und Passwort müssen ausgefüllt werden&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = authState !is AuthState.Loading,&#10;                    content = {&#10;                        if (authState is AuthState.Loading) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.padding(end = 8.dp)&#10;                            )&#10;                        }&#10;                        Text(text = if (isRegistering) &quot;Registrieren&quot; else &quot;Anmelden&quot;)&#10;                    }&#10;                )&#10;&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.padding(top = 20.dp)&#10;                ) {&#10;                    CoffeeText(&#10;                        text = if (isRegistering) &quot;Bereits ein Konto?&quot; else &quot;Noch kein Konto?&quot;&#10;                    )&#10;&#10;                    TextButton(&#10;                        onClick = {&#10;                            isRegistering = !isRegistering&#10;                            email = &quot;&quot;&#10;                        },&#10;                        enabled = authState !is AuthState.Loading,&#10;                        content = {&#10;                            Text(text = if (isRegistering) &quot;Anmelden&quot; else &quot;Registrieren&quot;, fontSize = 20.sp)&#10;                        }&#10;                    )&#10;                }&#10;&#10;                when (val state = authState) {&#10;                    is AuthState.Loading -&gt; CoffeeText(&#10;                        text = if (isRegistering) &quot;Registrierung läuft...&quot; else &quot;Anmeldung läuft...&quot;&#10;                    )&#10;                    is AuthState.Success -&gt; CoffeeText(&#10;                        text = &quot;Willkommen ${state.response.name}!&quot;&#10;                    )&#10;                    is AuthState.Error -&gt; CoffeeText(&#10;                        text = &quot;Fehler: ${state.message}&quot;,&#10;                        color = MaterialTheme.colorScheme.error&#10;                    )&#10;                    AuthState.Idle -&gt; CoffeeText(&#10;                        text = &quot;Bereit zur Anmeldung&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        SnackbarHost(&#10;            hostState = snackbarHostState,&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens&#10;&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.SnackbarHost&#10;import androidx.compose.material3.SnackbarHostState&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.NavController&#10;import app.chesspresso.auth.presentation.AuthState&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import app.chesspresso.ui.theme.CoffeeTextField&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Email&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.lint.kotlin.metadata.Visibility&#10;&#10;@Composable&#10;fun LoginScreen(&#10;    navController: NavController,&#10;    authViewModel: AuthViewModel&#10;) {&#10;    val authState by authViewModel.authState.collectAsState()&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    var isRegistering by remember { mutableStateOf(false) }&#10;    var username by remember { mutableStateOf(&quot;&quot;) }&#10;    var password by remember { mutableStateOf(&quot;&quot;) }&#10;    var email by remember { mutableStateOf(&quot;&quot;) }&#10;    var passwordVisible by remember { mutableStateOf(false) }&#10;&#10;    // Vorausgefüllter Benutzername, falls vorhanden&#10;    val storedUsername = remember { authViewModel.getStoredUsername() }&#10;    if (username.isEmpty() &amp;&amp; storedUsername != null) {&#10;        username = storedUsername&#10;    }&#10;&#10;    // Navigation nach erfolgreichem Login&#10;    LaunchedEffect(authState) {&#10;        if (authState is AuthState.Success) {&#10;            navController.navigate(&quot;main&quot;) {&#10;                popUpTo(&quot;login&quot;) { inclusive = true }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Snackbar für Fehler&#10;    LaunchedEffect(authState) {&#10;        when (val state = authState) {&#10;            is AuthState.Error -&gt; {&#10;                snackbarHostState.showSnackbar(state.message)&#10;            }&#10;&#10;            else -&gt; {}&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        CoffeeCard(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(32.dp)&#10;        ) {&#10;            Column(&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                modifier = Modifier.padding(24.dp)&#10;            ) {&#10;                CoffeeHeadlineText(&#10;                    text = if (isRegistering) &quot;Registrierung&quot; else &quot;Anmeldung&quot;,&#10;                    fontSizeSp = 24&#10;                )&#10;&#10;                CoffeeTextField(&#10;                    value = username,&#10;                    onValueChange = { username = it },&#10;                    label = &quot;Benutzername&quot;,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    singleLine = true,&#10;                    enabled = authState !is AuthState.Loading,&#10;                    leadingIcon = { androidx.compose.material3.Icon(Icons.Filled.Person, contentDescription = &quot;Benutzername&quot;) }&#10;                )&#10;&#10;                if (isRegistering) {&#10;                    CoffeeTextField(&#10;                        value = email,&#10;                        onValueChange = { email = it },&#10;                        label = &quot;E-Mail&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        enabled = authState !is AuthState.Loading,&#10;                        leadingIcon = { androidx.compose.material3.Icon(Icons.Filled.Email, contentDescription = &quot;E-Mail&quot;) }&#10;                    )&#10;                }&#10;&#10;                CoffeeTextField(&#10;                    value = password,&#10;                    onValueChange = { password = it },&#10;                    label = &quot;Passwort&quot;,&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    singleLine = true,&#10;                    enabled = authState !is AuthState.Loading,&#10;                    visualTransformation = if (passwordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                    leadingIcon = { androidx.compose.material3.Icon(Icons.Filled.Lock, contentDescription = &quot;Passwort&quot;) },&#10;                    trailingIcon = {&#10;                        val image = if (passwordVisible) Icons.Filled.VisibilityOff else Icons.Filled.Visibility&#10;                        val desc = if (passwordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                        androidx.compose.material3.IconButton(onClick = { passwordVisible = !passwordVisible }) {&#10;                            androidx.compose.material3.Icon(image, contentDescription = desc)&#10;                        }&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CoffeeButton(&#10;                    onClick = {&#10;                        if (isRegistering) {&#10;                            if (username.isNotBlank() &amp;&amp; password.isNotBlank() &amp;&amp; email.isNotBlank()) {&#10;                                authViewModel.register(username.trim(), password, email.trim())&#10;                            } else {&#10;                                authViewModel.setErrorMessage(&quot;Alle Felder müssen ausgefüllt werden&quot;)&#10;                            }&#10;                        } else {&#10;                            if (username.isNotBlank() &amp;&amp; password.isNotBlank()) {&#10;                                authViewModel.login(username.trim(), password)&#10;                            } else {&#10;                                authViewModel.setErrorMessage(&quot;Benutzername und Passwort müssen ausgefüllt werden&quot;)&#10;                            }&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = authState !is AuthState.Loading,&#10;                    content = {&#10;                        if (authState is AuthState.Loading) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.padding(end = 8.dp)&#10;                            )&#10;                        }&#10;                        Text(text = if (isRegistering) &quot;Registrieren&quot; else &quot;Anmelden&quot;)&#10;                    }&#10;                )&#10;&#10;                Column(&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    modifier = Modifier.padding(top = 20.dp)&#10;                ) {&#10;                    CoffeeText(&#10;                        text = if (isRegistering) &quot;Bereits ein Konto?&quot; else &quot;Noch kein Konto?&quot;&#10;                    )&#10;&#10;                    TextButton(&#10;                        onClick = {&#10;                            isRegistering = !isRegistering&#10;                            email = &quot;&quot;&#10;                        },&#10;                        enabled = authState !is AuthState.Loading,&#10;                        content = {&#10;                            Text(text = if (isRegistering) &quot;Anmelden&quot; else &quot;Registrieren&quot;, fontSize = 20.sp)&#10;                        }&#10;                    )&#10;                }&#10;&#10;                when (val state = authState) {&#10;                    is AuthState.Loading -&gt; CoffeeText(&#10;                        text = if (isRegistering) &quot;Registrierung läuft...&quot; else &quot;Anmeldung läuft...&quot;&#10;                    )&#10;                    is AuthState.Success -&gt; CoffeeText(&#10;                        text = &quot;Willkommen ${state.response.name}!&quot;&#10;                    )&#10;                    is AuthState.Error -&gt; CoffeeText(&#10;                        text = &quot;Fehler: ${state.message}&quot;,&#10;                        color = MaterialTheme.colorScheme.error&#10;                    )&#10;                    AuthState.Idle -&gt; CoffeeText(&#10;                        text = &quot;Bereit zur Anmeldung&quot;&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        SnackbarHost(&#10;            hostState = snackbarHostState,&#10;            modifier = Modifier.align(Alignment.BottomCenter)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/WelcomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/WelcomeScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.R&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;&#10;@Composable&#10;fun WelcomeScreen(&#10;    onLoginClick: () -&gt; Unit,&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            CoffeeHeadlineText(&#10;                text = &quot;Willkommen bei \nChessPresso&quot;,&#10;                textAlign = TextAlign.Center,&#10;                fontSizeSp = 36&#10;            )&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(400.dp)&#10;                    .background(&#10;                        color = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f),&#10;                        shape = RoundedCornerShape(24.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(340.dp)&#10;                        .background(&#10;                            color = MaterialTheme.colorScheme.background.copy(alpha = 0.7f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        ),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.watermark_chess),&#10;                        contentDescription = &quot;ChessPresso Logo&quot;,&#10;                        modifier = Modifier.size(300.dp),&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.onBackground)&#10;                    )&#10;                }&#10;            }&#10;&#10;            CoffeeText(&#10;                text = &quot;Chess for Coffee Lovers&quot;,&#10;                modifier = Modifier.padding(32.dp)&#10;            )&#10;&#10;            // Login Button&#10;            CoffeeButton(&#10;                onClick = onLoginClick,&#10;                content = {&#10;                    Text(&quot;Anmelden&quot;)&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.R&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;&#10;@Composable&#10;fun WelcomeScreen(&#10;    onLoginClick: () -&gt; Unit,&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .background(MaterialTheme.colorScheme.background)&#10;&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(24.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            CoffeeHeadlineText(&#10;                text = &quot;Willkommen bei \nChessPresso&quot;,&#10;                textAlign = TextAlign.Center,&#10;                fontSizeSp = 36&#10;            )&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(400.dp)&#10;                    .background(&#10;                        color = MaterialTheme.colorScheme.surface.copy(alpha = 0.8f),&#10;                        shape = RoundedCornerShape(24.dp)&#10;                    ),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(340.dp)&#10;                        .background(&#10;                            color = MaterialTheme.colorScheme.background.copy(alpha = 0.7f),&#10;                            shape = RoundedCornerShape(16.dp)&#10;                        ),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Image(&#10;                        painter = painterResource(id = R.drawable.watermark_chess),&#10;                        contentDescription = &quot;ChessPresso Logo&quot;,&#10;                        modifier = Modifier.size(300.dp),&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.onBackground)&#10;                    )&#10;                }&#10;            }&#10;&#10;            CoffeeText(&#10;                text = &quot;Chess for Coffee Lovers&quot;,&#10;                modifier = Modifier.padding(32.dp)&#10;            )&#10;&#10;            // Login Button&#10;            CoffeeButton(&#10;                onClick = onLoginClick,&#10;                content = {&#10;                    Text(&quot;Anmelden&quot;)&#10;                }&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel = hiltViewModel(),&#10;    authViewModel: AuthViewModel,&#10;    onLogout: () -&gt; Unit,&#10;    outerNavController: NavHostController&#10;) {&#10;    val usernameChangeState by viewModel.usernameChangeState.collectAsState()&#10;    val passwordChangeState by viewModel.passwordChangeState.collectAsState()&#10;    var newUsername by remember { mutableStateOf(&quot;&quot;) }&#10;    var oldPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var showUsernameConfirmDialog by remember { mutableStateOf(false) }&#10;    var showPasswordConfirmDialog by remember { mutableStateOf(false) }&#10;    var oldPasswordVisible by remember { mutableStateOf(false) }&#10;    var newPasswordVisible by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadUserProfile()&#10;    }&#10;&#10;    LaunchedEffect(usernameChangeState) {&#10;        if (usernameChangeState is UsernameChangeState.Success) {&#10;            newUsername = &quot;&quot; // Clear input after success&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(passwordChangeState) {&#10;        if (passwordChangeState is PasswordChangeState.Success) {&#10;            oldPassword = &quot;&quot;&#10;            newPassword = &quot;&quot;&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.events.collect { event -&gt;&#10;            when (event) {&#10;                is ProfileEvent.LogoutAndNavigateToLogin -&gt; {&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;login&quot;) {&#10;                        popUpTo(&quot;login&quot;) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(bottom = 16.dp), // Extra padding at the bottom if content is long&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            CoffeeText(&#10;                text = &quot;Profil&quot;,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // User Profile Info Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Meine Informationen&quot;,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                    val userProfileState = viewModel.userProfileState.collectAsState().value&#10;                    when (userProfileState) {&#10;                        is UserProfileUiState.Loading -&gt; CircularProgressIndicator()&#10;                        is UserProfileUiState.Error -&gt; CoffeeText(&#10;                            &quot;Fehler: &quot; + userProfileState.message,&#10;                            color = MaterialTheme.colorScheme.error&#10;                        )&#10;                        is UserProfileUiState.Success -&gt; {&#10;                            val profile = userProfileState.profile&#10;                            CoffeeText(&quot;Name: ${profile.username}&quot;)&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CoffeeText(&quot;E-Mail: ${profile.email}&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Username Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Benutzernamen ändern&quot;,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                    CoffeeTextField(&#10;                        value = newUsername,&#10;                        onValueChange = { newUsername = it },&#10;                        label = &quot;Neuer Benutzername&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        leadingIcon = { Icon(Icons.Default.Person, contentDescription = &quot;Benutzername&quot;) }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    CoffeeButton(&#10;                        onClick = { showUsernameConfirmDialog = true },&#10;                        enabled = usernameChangeState !is UsernameChangeState.Loading &amp;&amp; newUsername.length in 3..32,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        content = {&#10;                            Text(&quot;Benutzernamen ändern&quot;)&#10;                        }&#10;                    )&#10;                    when (val state = usernameChangeState) {&#10;                        is UsernameChangeState.Loading -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CircularProgressIndicator()&#10;                        }&#10;                        is UsernameChangeState.Success -&gt; {&#10;                            // Message handled by logout navigation&#10;                        }&#10;                        is UsernameChangeState.Error -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Password Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Passwort ändern&quot;,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                    CoffeeTextField(&#10;                        value = oldPassword,&#10;                        onValueChange = { oldPassword = it },&#10;                        label = &quot;Altes Passwort&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (oldPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                        leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Altes Passwort&quot;) },&#10;                        trailingIcon = {&#10;                            val image = if (oldPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                            val desc = if (oldPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                            IconButton(onClick = { oldPasswordVisible = !oldPasswordVisible }) {&#10;                                Icon(image, contentDescription = desc)&#10;                            }&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    CoffeeTextField(&#10;                        value = newPassword,&#10;                        onValueChange = { newPassword = it },&#10;                        label = &quot;Neues Passwort&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (newPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                        leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Neues Passwort&quot;) },&#10;                        trailingIcon = {&#10;                            val image = if (newPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                            val desc = if (newPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                            IconButton(onClick = { newPasswordVisible = !newPasswordVisible }) {&#10;                                Icon(image, contentDescription = desc)&#10;                            }&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    CoffeeButton(&#10;                        onClick = { showPasswordConfirmDialog = true },&#10;                        enabled = passwordChangeState !is PasswordChangeState.Loading &amp;&amp; oldPassword.length &gt;= 4 &amp;&amp; newPassword.length in 4..64,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        content = {&#10;                            Text(&quot;Passwort ändern&quot;)&#10;                        }&#10;                    )&#10;                    when (val state = passwordChangeState) {&#10;                        is PasswordChangeState.Loading -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CircularProgressIndicator()&#10;                        }&#10;                        is PasswordChangeState.Success -&gt; {&#10;                            // Message handled by logout navigation&#10;                        }&#10;                        is PasswordChangeState.Error -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            CoffeeButton(&#10;                onClick = onLogout,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .padding(horizontal = 32.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error&#10;                ),&#10;                content = {&#10;                    Text(&quot;Abmelden&quot;)&#10;                }&#10;            )&#10;&#10;        }&#10;    }&#10;&#10;&#10;    if (showUsernameConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showUsernameConfirmDialog = false },&#10;            title = { CoffeeText(&quot;Benutzernamen ändern&quot;) },&#10;            text = { CoffeeText(&quot;Um den Benutzernamen zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showUsernameConfirmDialog = false&#10;                    viewModel.changeUsername(newUsername)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showUsernameConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showPasswordConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPasswordConfirmDialog = false },&#10;            title = { CoffeeText(&quot;Passwort ändern&quot;) },&#10;            text = { CoffeeText(&quot;Um das Passwort zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showPasswordConfirmDialog = false&#10;                    viewModel.changePassword(oldPassword, newPassword)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showPasswordConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel = hiltViewModel(),&#10;    authViewModel: AuthViewModel,&#10;    onLogout: () -&gt; Unit,&#10;    outerNavController: NavHostController&#10;) {&#10;    val usernameChangeState by viewModel.usernameChangeState.collectAsState()&#10;    val passwordChangeState by viewModel.passwordChangeState.collectAsState()&#10;    var newUsername by remember { mutableStateOf(&quot;&quot;) }&#10;    var oldPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var showUsernameConfirmDialog by remember { mutableStateOf(false) }&#10;    var showPasswordConfirmDialog by remember { mutableStateOf(false) }&#10;    var oldPasswordVisible by remember { mutableStateOf(false) }&#10;    var newPasswordVisible by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadUserProfile()&#10;    }&#10;&#10;    LaunchedEffect(usernameChangeState) {&#10;        if (usernameChangeState is UsernameChangeState.Success) {&#10;            newUsername = &quot;&quot; // Clear input after success&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(passwordChangeState) {&#10;        if (passwordChangeState is PasswordChangeState.Success) {&#10;            oldPassword = &quot;&quot;&#10;            newPassword = &quot;&quot;&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.events.collect { event -&gt;&#10;            when (event) {&#10;                is ProfileEvent.LogoutAndNavigateToLogin -&gt; {&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;login&quot;) {&#10;                        popUpTo(&quot;login&quot;) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(bottom = 16.dp), // Extra padding at the bottom if content is long&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            CoffeeText(&#10;                text = &quot;Profil&quot;,&#10;                color = MaterialTheme.colorScheme.primary&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // User Profile Info Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Meine Informationen&quot;,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                    val userProfileState = viewModel.userProfileState.collectAsState().value&#10;                    when (userProfileState) {&#10;                        is UserProfileUiState.Loading -&gt; CircularProgressIndicator()&#10;                        is UserProfileUiState.Error -&gt; CoffeeText(&#10;                            &quot;Fehler: &quot; + userProfileState.message,&#10;                            color = MaterialTheme.colorScheme.error&#10;                        )&#10;                        is UserProfileUiState.Success -&gt; {&#10;                            val profile = userProfileState.profile&#10;                            CoffeeText(&quot;Name: ${profile.username}&quot;)&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CoffeeText(&quot;E-Mail: ${profile.email}&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Username Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Benutzernamen ändern&quot;,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                    CoffeeTextField(&#10;                        value = newUsername,&#10;                        onValueChange = { newUsername = it },&#10;                        label = &quot;Neuer Benutzername&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        leadingIcon = { Icon(Icons.Default.Person, contentDescription = &quot;Benutzername&quot;) }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    CoffeeButton(&#10;                        onClick = { showUsernameConfirmDialog = true },&#10;                        enabled = usernameChangeState !is UsernameChangeState.Loading &amp;&amp; newUsername.length in 3..32,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        content = {&#10;                            Text(&quot;Benutzernamen ändern&quot;)&#10;                        }&#10;                    )&#10;                    when (val state = usernameChangeState) {&#10;                        is UsernameChangeState.Loading -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CircularProgressIndicator()&#10;                        }&#10;                        is UsernameChangeState.Success -&gt; {&#10;                            // Message handled by logout navigation&#10;                        }&#10;                        is UsernameChangeState.Error -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Password Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .padding(16.dp)&#10;                        .fillMaxWidth(),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Passwort ändern&quot;,&#10;                        modifier = Modifier.padding(bottom = 16.dp)&#10;                    )&#10;                    CoffeeTextField(&#10;                        value = oldPassword,&#10;                        onValueChange = { oldPassword = it },&#10;                        label = &quot;Altes Passwort&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (oldPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                        leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Altes Passwort&quot;) },&#10;                        trailingIcon = {&#10;                            val image = if (oldPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                            val desc = if (oldPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                            IconButton(onClick = { oldPasswordVisible = !oldPasswordVisible }) {&#10;                                Icon(image, contentDescription = desc)&#10;                            }&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    CoffeeTextField(&#10;                        value = newPassword,&#10;                        onValueChange = { newPassword = it },&#10;                        label = &quot;Neues Passwort&quot;,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        singleLine = true,&#10;                        visualTransformation = if (newPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                        leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Neues Passwort&quot;) },&#10;                        trailingIcon = {&#10;                            val image = if (newPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                            val desc = if (newPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                            IconButton(onClick = { newPasswordVisible = !newPasswordVisible }) {&#10;                                Icon(image, contentDescription = desc)&#10;                            }&#10;                        }&#10;                    )&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;                    CoffeeButton(&#10;                        onClick = { showPasswordConfirmDialog = true },&#10;                        enabled = passwordChangeState !is PasswordChangeState.Loading &amp;&amp; oldPassword.length &gt;= 4 &amp;&amp; newPassword.length in 4..64,&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        content = {&#10;                            Text(&quot;Passwort ändern&quot;)&#10;                        }&#10;                    )&#10;                    when (val state = passwordChangeState) {&#10;                        is PasswordChangeState.Loading -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CircularProgressIndicator()&#10;                        }&#10;                        is PasswordChangeState.Success -&gt; {&#10;                            // Message handled by logout navigation&#10;                        }&#10;                        is PasswordChangeState.Error -&gt; {&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                        }&#10;                        else -&gt; {}&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            CoffeeButton(&#10;                onClick = onLogout,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 8.dp)&#10;                    .padding(horizontal = 32.dp),&#10;                colors = ButtonDefaults.buttonColors(&#10;                    containerColor = MaterialTheme.colorScheme.error&#10;                ),&#10;                content = {&#10;                    Text(&quot;Abmelden&quot;)&#10;                }&#10;            )&#10;&#10;        }&#10;    }&#10;&#10;&#10;    if (showUsernameConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showUsernameConfirmDialog = false },&#10;            title = { CoffeeText(&quot;Benutzernamen ändern&quot;) },&#10;            text = { CoffeeText(&quot;Um den Benutzernamen zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showUsernameConfirmDialog = false&#10;                    viewModel.changeUsername(newUsername)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showUsernameConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showPasswordConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPasswordConfirmDialog = false },&#10;            title = { CoffeeText(&quot;Passwort ändern&quot;) },&#10;            text = { CoffeeText(&quot;Um das Passwort zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showPasswordConfirmDialog = false&#10;                    viewModel.changePassword(oldPassword, newPassword)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showPasswordConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/theme/CoffeeComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/theme/CoffeeComponents.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.theme&#10;&#10;import android.annotation.SuppressLint&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.ColumnScope&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.RowScope&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonColors&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextFieldDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;&#10;@Composable&#10;fun CoffeeButton(&#10;    onClick: () -&gt; Unit,&#10;    @SuppressLint(&quot;ModifierParameter&quot;) modifier: Modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp),&#10;    enabled: Boolean = true,&#10;    colors: ButtonColors = ButtonDefaults.buttonColors(&#10;        containerColor = CoffeeBrownSoft, // Noch etwas kräftigerer, aber weicher Braunton für Buttons&#10;        contentColor = MaterialTheme.colorScheme.onPrimary&#10;    ),&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = modifier,&#10;        enabled = enabled,&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = colors&#10;    ) {&#10;        Row { content() }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CoffeeCard(&#10;    modifier: Modifier = Modifier,&#10;    containerColor: Color = MaterialTheme.colorScheme.surface,&#10;    contentColor: Color = MaterialTheme.colorScheme.onSurface,&#10;    content: @Composable ColumnScope.() -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(20.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = containerColor,&#10;            contentColor = contentColor&#10;        ),&#10;        content = content&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CoffeeTextField(&#10;    value: String,&#10;    onValueChange: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    label: String? = null,&#10;    isError: Boolean = false,&#10;    singleLine: Boolean = true,&#10;    enabled: Boolean = true,&#10;    visualTransformation: VisualTransformation = VisualTransformation.None,&#10;    leadingIcon: (@Composable (() -&gt; Unit))? = null,&#10;    trailingIcon: (@Composable (() -&gt; Unit))? = null&#10;) {&#10;    OutlinedTextField(&#10;        value = value,&#10;        onValueChange = onValueChange,&#10;        modifier = modifier.fillMaxWidth(),&#10;        label = label?.let { { Text(it, fontSize = 20.sp) } },&#10;        textStyle = TextStyle(fontSize = 20.sp),&#10;        singleLine = singleLine,&#10;        enabled = enabled,&#10;        isError = isError,&#10;        visualTransformation = visualTransformation,&#10;        leadingIcon = leadingIcon,&#10;        trailingIcon = trailingIcon,&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = TextFieldDefaults.colors(&#10;            focusedContainerColor = MaterialTheme.colorScheme.surface,&#10;            unfocusedContainerColor = MaterialTheme.colorScheme.surface,&#10;            disabledContainerColor = MaterialTheme.colorScheme.surface,&#10;            errorContainerColor = MaterialTheme.colorScheme.surface,&#10;            focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;            unfocusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;            disabledTextColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;            errorTextColor = MaterialTheme.colorScheme.error,&#10;            focusedIndicatorColor = MaterialTheme.colorScheme.primary,&#10;            unfocusedIndicatorColor = MaterialTheme.colorScheme.secondary,&#10;            disabledIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f),&#10;            errorIndicatorColor = MaterialTheme.colorScheme.error,&#10;            focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;            unfocusedLabelColor = MaterialTheme.colorScheme.onSurface,&#10;            disabledLabelColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;            errorLabelColor = MaterialTheme.colorScheme.error&#10;        )&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CoffeeText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    style: TextStyle = MaterialTheme.typography.bodyLarge,&#10;    color: Color = MaterialTheme.colorScheme.onSurface,&#10;    maxLines: Int = Int.MAX_VALUE,&#10;    overflow: TextOverflow = TextOverflow.Clip,&#10;    textAlign: TextAlign? = null,&#10;    fontSizeSp: Int = 20&#10;) {&#10;    Text(&#10;        text = text,&#10;        modifier = modifier,&#10;        style = style.copy(fontFamily = Montserrat),&#10;        color = color,&#10;        maxLines = maxLines,&#10;        overflow = overflow,&#10;        textAlign = textAlign,&#10;        fontSize = fontSizeSp.sp&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CoffeeHeadlineText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    fontSizeSp: Int = 28,&#10;    fontWeight: FontWeight = FontWeight.Bold,&#10;    color: Color = MaterialTheme.colorScheme.onSurface,&#10;    textAlign: TextAlign? = null,&#10;    maxLines: Int = Int.MAX_VALUE,&#10;    overflow: TextOverflow = TextOverflow.Clip&#10;) {&#10;    Text(&#10;        text = text,&#10;        modifier = modifier,&#10;        style = TextStyle(&#10;            fontFamily = Montserrat,&#10;            fontWeight = fontWeight,&#10;            fontSize = fontSizeSp.sp&#10;        ),&#10;        color = color,&#10;        textAlign = textAlign,&#10;        maxLines = maxLines,&#10;        overflow = overflow&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.theme&#10;&#10;import android.annotation.SuppressLint&#10;import androidx.compose.foundation.border&#10;import androidx.compose.foundation.layout.ColumnScope&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.RowScope&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonColors&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextFieldDefaults&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.VisualTransformation&#10;&#10;@Composable&#10;fun CoffeeButton(&#10;    onClick: () -&gt; Unit,&#10;    @SuppressLint(&quot;ModifierParameter&quot;) modifier: Modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp),&#10;    enabled: Boolean = true,&#10;    colors: ButtonColors = ButtonDefaults.buttonColors(&#10;        containerColor = CoffeeBrownSoft, // Noch etwas kräftigerer, aber weicher Braunton für Buttons&#10;        contentColor = MaterialTheme.colorScheme.onPrimary&#10;    ),&#10;    content: @Composable () -&gt; Unit&#10;) {&#10;    Button(&#10;        onClick = onClick,&#10;        modifier = modifier,&#10;        enabled = enabled,&#10;        shape = RoundedCornerShape(16.dp),&#10;        colors = colors&#10;    ) {&#10;        Row { content() }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CoffeeCard(&#10;    modifier: Modifier = Modifier,&#10;    containerColor: Color = MaterialTheme.colorScheme.surface,&#10;    contentColor: Color = MaterialTheme.colorScheme.onSurface,&#10;    content: @Composable ColumnScope.() -&gt; Unit&#10;) {&#10;    Card(&#10;        modifier = modifier,&#10;        shape = RoundedCornerShape(20.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = containerColor,&#10;            contentColor = contentColor&#10;        ),&#10;        content = content&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CoffeeTextField(&#10;    value: String,&#10;    onValueChange: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    label: String? = null,&#10;    isError: Boolean = false,&#10;    singleLine: Boolean = true,&#10;    enabled: Boolean = true,&#10;    visualTransformation: VisualTransformation = VisualTransformation.None,&#10;    leadingIcon: (@Composable (() -&gt; Unit))? = null,&#10;    trailingIcon: (@Composable (() -&gt; Unit))? = null&#10;) {&#10;    OutlinedTextField(&#10;        value = value,&#10;        onValueChange = onValueChange,&#10;        modifier = modifier.fillMaxWidth(),&#10;        label = label?.let { { Text(it, fontSize = 20.sp) } },&#10;        textStyle = TextStyle(fontSize = 20.sp),&#10;        singleLine = singleLine,&#10;        enabled = enabled,&#10;        isError = isError,&#10;        visualTransformation = visualTransformation,&#10;        leadingIcon = leadingIcon,&#10;        trailingIcon = trailingIcon,&#10;        shape = RoundedCornerShape(12.dp),&#10;        colors = TextFieldDefaults.colors(&#10;            focusedContainerColor = MaterialTheme.colorScheme.surface,&#10;            unfocusedContainerColor = MaterialTheme.colorScheme.surface,&#10;            disabledContainerColor = MaterialTheme.colorScheme.surface,&#10;            errorContainerColor = MaterialTheme.colorScheme.surface,&#10;            focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;            unfocusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;            disabledTextColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;            errorTextColor = MaterialTheme.colorScheme.error,&#10;            focusedIndicatorColor = MaterialTheme.colorScheme.primary,&#10;            unfocusedIndicatorColor = MaterialTheme.colorScheme.secondary,&#10;            disabledIndicatorColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.2f),&#10;            errorIndicatorColor = MaterialTheme.colorScheme.error,&#10;            focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;            unfocusedLabelColor = MaterialTheme.colorScheme.onSurface,&#10;            disabledLabelColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.5f),&#10;            errorLabelColor = MaterialTheme.colorScheme.error&#10;        )&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CoffeeText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    style: TextStyle = MaterialTheme.typography.bodyLarge,&#10;    color: Color = MaterialTheme.colorScheme.onSurface,&#10;    maxLines: Int = Int.MAX_VALUE,&#10;    overflow: TextOverflow = TextOverflow.Clip,&#10;    textAlign: TextAlign? = null,&#10;    fontSizeSp: Int = 20&#10;) {&#10;    Text(&#10;        text = text,&#10;        modifier = modifier,&#10;        style = style.copy(fontFamily = Montserrat),&#10;        color = color,&#10;        maxLines = maxLines,&#10;        overflow = overflow,&#10;        textAlign = textAlign,&#10;        fontSize = fontSizeSp.sp&#10;    )&#10;}&#10;&#10;@Composable&#10;fun CoffeeHeadlineText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    fontSizeSp: Int = 28,&#10;    fontWeight: FontWeight = FontWeight.Bold,&#10;    color: Color = MaterialTheme.colorScheme.onSurface,&#10;    textAlign: TextAlign? = null,&#10;    maxLines: Int = Int.MAX_VALUE,&#10;    overflow: TextOverflow = TextOverflow.Clip&#10;) {&#10;    Text(&#10;        text = text,&#10;        modifier = modifier,&#10;        style = TextStyle(&#10;            fontFamily = Montserrat,&#10;            fontWeight = fontWeight,&#10;            fontSize = fontSizeSp.sp&#10;        ),&#10;        color = color,&#10;        textAlign = textAlign,&#10;        maxLines = maxLines,&#10;        overflow = overflow&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>