<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.qr.QRScannerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.qr.QRScannerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/UserApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/UserApi.kt" />
              <option name="originalContent" value="package app.chesspresso.data.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.PATCH&#10;&#10;// Datenklasse für die Anfrage&#10;data class ChangeUsernameRequest(val newUsername: String)&#10;&#10;// Datenklasse für die Passwortänderung&#10;data class ChangePasswordRequest(&#10;    val oldPassword: String,&#10;    val newPassword: String&#10;)&#10;&#10;data class UserProfileResponse(&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;interface UserApi {&#10;    @PATCH(&quot;/user/username&quot;)&#10;    suspend fun changeUsername(@Body request: ChangeUsernameRequest): Response&lt;Unit&gt;&#10;&#10;    @PATCH(&quot;/user/password&quot;)&#10;    suspend fun changePassword(@Body request: ChangePasswordRequest): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;/user/profile&quot;)&#10;    suspend fun getProfile(): UserProfileResponse&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.data.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.PATCH&#10;&#10;// Datenklasse für die Anfrage&#10;data class ChangeUsernameRequest(val newUsername: String)&#10;&#10;// Datenklasse für die Passwortänderung&#10;data class ChangePasswordRequest(&#10;    val oldPassword: String,&#10;    val newPassword: String&#10;)&#10;&#10;data class UserProfileResponse(&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;interface UserApi {&#10;    @PATCH(&quot;/user/username&quot;)&#10;    suspend fun changeUsername(@Body request: ChangeUsernameRequest): Response&lt;Unit&gt;&#10;&#10;    @PATCH(&quot;/user/password&quot;)&#10;    suspend fun changePassword(@Body request: ChangePasswordRequest): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;/user/profile&quot;)&#10;    suspend fun getProfile(): UserProfileResponse&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/ChessGameScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/ChessGameScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.board.Board&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChessGameScreen(&#10;    gameStartResponse: GameStartResponse,&#10;    viewModel: ChessGameViewModel = hiltViewModel(),&#10;    playerId: String,&#10;    onGameEnd: (gameEndResponse: app.chesspresso.model.lobby.GameEndResponse, playerId: String) -&gt; Unit = { _, _ -&gt; }&#10;) {&#10;    val board = remember { Board() }&#10;&#10;    // Collect ViewModel states&#10;    val currentBoard by viewModel.currentBoard.collectAsState()&#10;    val currentPlayer by viewModel.currentPlayer.collectAsState()&#10;    val currentGameState by viewModel.currentGameState.collectAsState()&#10;    val whiteTime by viewModel.whiteTime.collectAsState()&#10;    val blackTime by viewModel.blackTime.collectAsState()&#10;    val myColor by viewModel.myColor.collectAsState()&#10;    val possibleMoves by viewModel.possibleMoves.collectAsState()&#10;    val promotionRequest by viewModel.promotionRequest.collectAsState()&#10;    val gameEndEvent by viewModel.gameEndEvent.collectAsState()&#10;&#10;    // Determine which board state to use (current or initial)&#10;    val boardToDisplay = currentBoard.ifEmpty { gameStartResponse.board }&#10;    val activePlayer = currentPlayer ?: TeamColor.WHITE&#10;&#10;    // Initialize game when component first loads&#10;    LaunchedEffect(gameStartResponse) {&#10;        viewModel.initializeGame(gameStartResponse)&#10;    }&#10;&#10;    // Navigation zum GameOverScreen, wenn das Spiel beendet ist&#10;    LaunchedEffect(gameEndEvent) {&#10;        if (gameEndEvent != null) {&#10;            onGameEnd(gameEndEvent!!, playerId)&#10;        }&#10;    }&#10;&#10;    // ModalNavigationDrawer entfernt, Drawer wird jetzt zentral im MainScaffoldScreen verwaltet&#10;    Scaffold(&#10;        // TopAppBar entfernt, damit sie nur noch im MainScaffoldScreen angezeigt wird&#10;        content = { paddingValues -&gt;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .padding(horizontal = 8.dp, vertical = 4.dp), // Weniger vertikaler Abstand&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Spieler und Uhren&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(IntrinsicSize.Min),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    if (myColor == TeamColor.WHITE) {&#10;                        // Eigener Spieler (Weiß) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Schwarz) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                    } else if (myColor == TeamColor.BLACK) {&#10;                        // Eigener Spieler (Schwarz) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Weiß) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Schachbrett - verwende den aktuellen Spielbrett-Zustand&#10;                board.BoardContent(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 8.dp),&#10;                    boardState = boardToDisplay,&#10;                    lobbyId = gameStartResponse.lobbyId,&#10;                    onPositionRequest = { positionRequest -&gt;&#10;                        viewModel.sendPositionRequest(&#10;                            gameStartResponse.lobbyId,&#10;                            positionRequest.position&#10;                        )&#10;                    },&#10;                    isFlipped = (myColor == TeamColor.BLACK),&#10;                    possibleMoves = if (myColor == currentPlayer) possibleMoves else emptyList(),&#10;                    nextPlayer = currentPlayer ?: TeamColor.WHITE,&#10;                    myColor = myColor,&#10;                    isCheck = currentGameState?.isCheck ?: &quot;&quot;,&#10;                    onGameMove = { from, to -&gt;&#10;                        val color = myColor&#10;                        if (color != null) {&#10;                            viewModel.sendGameMoveMessage(&#10;                                gameStartResponse.lobbyId,&#10;                                from,&#10;                                to,&#10;                                color&#10;                            )&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // --- Promotion Auswahl unter dem Brett ---&#10;                if (promotionRequest != null &amp;&amp; promotionRequest!!.activeTeam == myColor) {&#10;                    val promotionPosition = promotionRequest!!.position&#10;                    val promotionFrom = promotionRequest!!.from&#10;                    val promotionOptions = listOf(&#10;                        app.chesspresso.model.PieceType.QUEEN,&#10;                        app.chesspresso.model.PieceType.ROOK,&#10;                        app.chesspresso.model.PieceType.BISHOP,&#10;                        app.chesspresso.model.PieceType.KNIGHT&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 8.dp),&#10;                        elevation = CardDefaults.cardElevation(4.dp)&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(12.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&quot;Wähle die Figur für die Umwandlung:&quot;, style = MaterialTheme.typography.titleMedium)&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Row(&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .heightIn(min = 48.dp)&#10;                            ) {&#10;                                promotionOptions.forEach { pieceType -&gt;&#10;                                    val drawableRes = when (pieceType) {&#10;                                        app.chesspresso.model.PieceType.QUEEN -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.queen_white else app.chesspresso.R.drawable.queen_black&#10;                                        app.chesspresso.model.PieceType.ROOK -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.rook_white else app.chesspresso.R.drawable.rook_black&#10;                                        app.chesspresso.model.PieceType.BISHOP -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.bishop_white else app.chesspresso.R.drawable.bishop_black&#10;                                        app.chesspresso.model.PieceType.KNIGHT -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.knight_white else app.chesspresso.R.drawable.knight_black&#10;                                        else -&gt; 0&#10;                                    }&#10;                                    if (drawableRes != 0) {&#10;                                        Image(&#10;                                            painter = painterResource(id = drawableRes),&#10;                                            contentDescription = pieceType.name,&#10;                                            modifier = Modifier&#10;                                                .size(48.dp)&#10;                                                .padding(horizontal = 6.dp)&#10;                                                .clickable {&#10;                                                    // Sende jetzt eine MoveMessage mit promotedPiece&#10;                                                    viewModel.sendGameMoveMessage(&#10;                                                        gameStartResponse.lobbyId,&#10;                                                        promotionFrom,&#10;                                                        promotionPosition,&#10;                                                        myColor!!,&#10;                                                        pieceType&#10;                                                    )&#10;                                                }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        })&#10;}&#10;&#10;@Composable&#10;fun PlayerClock(&#10;    playerName: String,&#10;    remainingTime: String,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            Text(&#10;                text = remainingTime,&#10;                style = MaterialTheme.typography.headlineLarge,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun pieceToUnicode(piece: app.chesspresso.model.game.PieceInfo): String {&#10;    return when (piece.type.name) {&#10;        &quot;KING&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;        &quot;QUEEN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;        &quot;ROOK&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;        &quot;BISHOP&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;        &quot;KNIGHT&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;        &quot;PAWN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;        else -&gt; &quot;?&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CapturedPieces(captured: List&lt;app.chesspresso.model.game.PieceInfo&gt;) {&#10;    if (captured.isEmpty()) return&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(50.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Kein Text mehr, nur Icons anzeigen&#10;            captured.forEach { piece -&gt;&#10;                Text(text = pieceToUnicode(piece), fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatSecondsToTimeString(seconds: Int): String {&#10;    val min = seconds / 60&#10;    val sec = seconds % 60&#10;    return &quot;%02d:%02d&quot;.format(min, sec)&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.board.Board&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChessGameScreen(&#10;    gameStartResponse: GameStartResponse,&#10;    viewModel: ChessGameViewModel = hiltViewModel(),&#10;    playerId: String,&#10;    onGameEnd: (gameEndResponse: app.chesspresso.model.lobby.GameEndResponse, playerId: String) -&gt; Unit = { _, _ -&gt; }&#10;) {&#10;    val board = remember { Board() }&#10;&#10;    // Collect ViewModel states&#10;    val currentBoard by viewModel.currentBoard.collectAsState()&#10;    val currentPlayer by viewModel.currentPlayer.collectAsState()&#10;    val currentGameState by viewModel.currentGameState.collectAsState()&#10;    val whiteTime by viewModel.whiteTime.collectAsState()&#10;    val blackTime by viewModel.blackTime.collectAsState()&#10;    val myColor by viewModel.myColor.collectAsState()&#10;    val possibleMoves by viewModel.possibleMoves.collectAsState()&#10;    val promotionRequest by viewModel.promotionRequest.collectAsState()&#10;    val gameEndEvent by viewModel.gameEndEvent.collectAsState()&#10;&#10;    // Determine which board state to use (current or initial)&#10;    val boardToDisplay = currentBoard.ifEmpty { gameStartResponse.board }&#10;    val activePlayer = currentPlayer ?: TeamColor.WHITE&#10;&#10;    // Initialize game when component first loads&#10;    LaunchedEffect(gameStartResponse) {&#10;        viewModel.initializeGame(gameStartResponse)&#10;    }&#10;&#10;    // Navigation zum GameOverScreen, wenn das Spiel beendet ist&#10;    LaunchedEffect(gameEndEvent) {&#10;        if (gameEndEvent != null) {&#10;            onGameEnd(gameEndEvent!!, playerId)&#10;        }&#10;    }&#10;&#10;    // ModalNavigationDrawer entfernt, Drawer wird jetzt zentral im MainScaffoldScreen verwaltet&#10;    Scaffold(&#10;        // TopAppBar entfernt, damit sie nur noch im MainScaffoldScreen angezeigt wird&#10;        content = { paddingValues -&gt;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .padding(horizontal = 8.dp, vertical = 4.dp), // Weniger vertikaler Abstand&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Spieler und Uhren&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(IntrinsicSize.Min),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    if (myColor == TeamColor.WHITE) {&#10;                        // Eigener Spieler (Weiß) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Schwarz) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                    } else if (myColor == TeamColor.BLACK) {&#10;                        // Eigener Spieler (Schwarz) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Weiß) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Schachbrett - verwende den aktuellen Spielbrett-Zustand&#10;                board.BoardContent(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 8.dp),&#10;                    boardState = boardToDisplay,&#10;                    lobbyId = gameStartResponse.lobbyId,&#10;                    onPositionRequest = { positionRequest -&gt;&#10;                        viewModel.sendPositionRequest(&#10;                            gameStartResponse.lobbyId,&#10;                            positionRequest.position&#10;                        )&#10;                    },&#10;                    isFlipped = (myColor == TeamColor.BLACK),&#10;                    possibleMoves = if (myColor == currentPlayer) possibleMoves else emptyList(),&#10;                    nextPlayer = currentPlayer ?: TeamColor.WHITE,&#10;                    myColor = myColor,&#10;                    isCheck = currentGameState?.isCheck ?: &quot;&quot;,&#10;                    onGameMove = { from, to -&gt;&#10;                        val color = myColor&#10;                        if (color != null) {&#10;                            viewModel.sendGameMoveMessage(&#10;                                gameStartResponse.lobbyId,&#10;                                from,&#10;                                to,&#10;                                color&#10;                            )&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // --- Promotion Auswahl unter dem Brett ---&#10;                if (promotionRequest != null &amp;&amp; promotionRequest!!.activeTeam == myColor) {&#10;                    val promotionPosition = promotionRequest!!.position&#10;                    val promotionFrom = promotionRequest!!.from&#10;                    val promotionOptions = listOf(&#10;                        app.chesspresso.model.PieceType.QUEEN,&#10;                        app.chesspresso.model.PieceType.ROOK,&#10;                        app.chesspresso.model.PieceType.BISHOP,&#10;                        app.chesspresso.model.PieceType.KNIGHT&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 8.dp),&#10;                        elevation = CardDefaults.cardElevation(4.dp)&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(12.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&quot;Wähle die Figur für die Umwandlung:&quot;, style = MaterialTheme.typography.titleMedium)&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Row(&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .heightIn(min = 48.dp)&#10;                            ) {&#10;                                promotionOptions.forEach { pieceType -&gt;&#10;                                    val drawableRes = when (pieceType) {&#10;                                        app.chesspresso.model.PieceType.QUEEN -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.queen_white else app.chesspresso.R.drawable.queen_black&#10;                                        app.chesspresso.model.PieceType.ROOK -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.rook_white else app.chesspresso.R.drawable.rook_black&#10;                                        app.chesspresso.model.PieceType.BISHOP -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.bishop_white else app.chesspresso.R.drawable.bishop_black&#10;                                        app.chesspresso.model.PieceType.KNIGHT -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.knight_white else app.chesspresso.R.drawable.knight_black&#10;                                        else -&gt; 0&#10;                                    }&#10;                                    if (drawableRes != 0) {&#10;                                        Image(&#10;                                            painter = painterResource(id = drawableRes),&#10;                                            contentDescription = pieceType.name,&#10;                                            modifier = Modifier&#10;                                                .size(48.dp)&#10;                                                .padding(horizontal = 6.dp)&#10;                                                .clickable {&#10;                                                    // Sende jetzt eine MoveMessage mit promotedPiece&#10;                                                    viewModel.sendGameMoveMessage(&#10;                                                        gameStartResponse.lobbyId,&#10;                                                        promotionFrom,&#10;                                                        promotionPosition,&#10;                                                        myColor!!,&#10;                                                        pieceType&#10;                                                    )&#10;                                                }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        })&#10;}&#10;&#10;@Composable&#10;fun PlayerClock(&#10;    playerName: String,&#10;    remainingTime: String,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            Text(&#10;                text = remainingTime,&#10;                style = MaterialTheme.typography.headlineLarge,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun pieceToUnicode(piece: app.chesspresso.model.game.PieceInfo): String {&#10;    return when (piece.type.name) {&#10;        &quot;KING&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;        &quot;QUEEN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;        &quot;ROOK&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;        &quot;BISHOP&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;        &quot;KNIGHT&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;        &quot;PAWN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;        else -&gt; &quot;?&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CapturedPieces(captured: List&lt;app.chesspresso.model.game.PieceInfo&gt;) {&#10;    if (captured.isEmpty()) return&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(50.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Kein Text mehr, nur Icons anzeigen&#10;            captured.forEach { piece -&gt;&#10;                Text(text = pieceToUnicode(piece), fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatSecondsToTimeString(seconds: Int): String {&#10;    val min = seconds / 60&#10;    val sec = seconds % 60&#10;    return &quot;%02d:%02d&quot;.format(min, sec)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/GameOverScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/GameOverScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.screens.main.NavRoutes&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;&#10;@Composable&#10;fun GameOverScreen(&#10;    gameEndResponse: GameEndResponse,&#10;    playerId: String,&#10;    navController: NavHostController&#10;) {&#10;    val viewModel: ChessGameViewModel = hiltViewModel()&#10;    val ergebnisText = when {&#10;        gameEndResponse.draw == true -&gt; &quot;Unentschieden&quot;&#10;        playerId == gameEndResponse.winner -&gt; &quot;Gewonnen&quot;&#10;        playerId == gameEndResponse.loser -&gt; &quot;Verloren&quot;&#10;        else -&gt; &quot;Unbekannt&quot;&#10;    }&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp),&#10;        horizontalAlignment = androidx.compose.ui.Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&quot;Spiel beendet&quot;, style = MaterialTheme.typography.headlineMedium)&#10;        Text(&quot;Lobby-ID: ${gameEndResponse.lobbyId}&quot;)&#10;        Text(&quot;Ergebnis: $ergebnisText&quot;)&#10;        Text(&quot;Endstellung:&quot;)&#10;&#10;&#10;        Button(onClick = {&#10;            viewModel.resetGameState()&#10;            navController.navigate(NavRoutes.HOME) {&#10;                popUpTo(0) { inclusive = true }&#10;            }&#10;        }) {&#10;            Text(&quot;Zurück&quot;)&#10;        }&#10;        Button(onClick = { /* TODO: Rematch-Logik */ }) {&#10;            Text(&quot;Rematch&quot;)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens.game&#13;&#10;&#13;&#10;import androidx.compose.foundation.layout.Arrangement&#13;&#10;import androidx.compose.foundation.layout.Column&#13;&#10;import androidx.compose.foundation.layout.fillMaxSize&#13;&#10;import androidx.compose.foundation.layout.fillMaxWidth&#13;&#10;import androidx.compose.foundation.layout.padding&#13;&#10;import androidx.compose.foundation.lazy.LazyColumn&#13;&#10;import androidx.compose.foundation.lazy.items&#13;&#10;import androidx.compose.material3.Button&#13;&#10;import androidx.compose.material3.MaterialTheme&#13;&#10;import androidx.compose.material3.Text&#13;&#10;import androidx.compose.runtime.Composable&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.navigation.NavHostController&#13;&#10;import app.chesspresso.model.lobby.GameEndResponse&#13;&#10;import app.chesspresso.screens.main.NavRoutes&#13;&#10;import androidx.hilt.navigation.compose.hiltViewModel&#13;&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun GameOverScreen(&#13;&#10;    gameEndResponse: GameEndResponse,&#13;&#10;    playerId: String,&#13;&#10;    navController: NavHostController&#13;&#10;) {&#13;&#10;    val viewModel: ChessGameViewModel = hiltViewModel()&#13;&#10;    val ergebnisText = when {&#13;&#10;        gameEndResponse.draw == true -&gt; &quot;Unentschieden&quot;&#13;&#10;        playerId == gameEndResponse.winner -&gt; &quot;Gewonnen&quot;&#13;&#10;        playerId == gameEndResponse.loser -&gt; &quot;Verloren&quot;&#13;&#10;        else -&gt; &quot;Unbekannt&quot;&#13;&#10;    }&#13;&#10;    Column(&#13;&#10;        modifier = Modifier&#13;&#10;            .fillMaxSize()&#13;&#10;            .padding(24.dp),&#13;&#10;        verticalArrangement = Arrangement.spacedBy(16.dp),&#13;&#10;        horizontalAlignment = androidx.compose.ui.Alignment.CenterHorizontally&#13;&#10;    ) {&#13;&#10;        Text(&quot;Spiel beendet&quot;, style = MaterialTheme.typography.headlineMedium)&#13;&#10;        Text(&quot;Lobby-ID: ${gameEndResponse.lobbyId}&quot;)&#13;&#10;        Text(&quot;Ergebnis: $ergebnisText&quot;)&#13;&#10;        Text(&quot;Endstellung:&quot;)&#13;&#10;&#13;&#10;&#13;&#10;        Button(onClick = {&#13;&#10;            viewModel.resetGameState()&#13;&#10;            navController.navigate(NavRoutes.HOME) {&#13;&#10;                popUpTo(0) { inclusive = true }&#13;&#10;            }&#13;&#10;        }) {&#13;&#10;            Text(&quot;Zurück&quot;)&#13;&#10;        }&#13;&#10;        Button(onClick = { /* TODO: Rematch-Logik */ }) {&#13;&#10;            Text(&quot;Rematch&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/service/LobbyService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/service/LobbyService.kt" />
              <option name="originalContent" value="package app.chesspresso.service&#10;&#10;import android.util.Log&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.model.game.GameStartMessage&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.model.lobby.JoinPrivateLobbyRequest&#10;import app.chesspresso.model.lobby.LeaveLobbyRequest&#10;import app.chesspresso.model.lobby.Lobby&#10;import app.chesspresso.model.lobby.LobbyErrorMessage&#10;import app.chesspresso.model.lobby.LobbyMessage&#10;import app.chesspresso.model.lobby.LobbyStatus&#10;import app.chesspresso.model.lobby.LobbyType&#10;import app.chesspresso.model.lobby.LobbyWaitingMessage&#10;import app.chesspresso.model.lobby.QuickJoinRequest&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LobbyService @Inject constructor(&#10;    private val lobbyApiService: LobbyApiService,&#10;    private val webSocketService: StompWebSocketService,&#10;    private val gson: Gson&#10;) : LobbyListener {&#10;    private val _currentLobby = MutableStateFlow&lt;Lobby?&gt;(null)&#10;    override val currentLobby: StateFlow&lt;Lobby?&gt; = _currentLobby.asStateFlow()&#10;&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;LobbyMessage&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;LobbyMessage&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    private val _lobbyError = MutableStateFlow&lt;String?&gt;(null)&#10;    val lobbyError: StateFlow&lt;String?&gt; = _lobbyError.asStateFlow()&#10;&#10;    private val _isWaitingForMatch = MutableStateFlow(false)&#10;    val isWaitingForMatch: StateFlow&lt;Boolean&gt; = _isWaitingForMatch.asStateFlow()&#10;&#10;    private val _gameStarted = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val gameStarted: StateFlow&lt;GameStartResponse?&gt; = _gameStarted.asStateFlow()&#10;    val lobbyLeft = MutableSharedFlow&lt;Unit&gt;()&#10;&#10;    init {&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            handleWebSocketMessage(message)&#10;        }&#10;        webSocketService.setLobbyListener(this)&#10;        // Subscription auf /user/queue/lobby-update für QuickMatch und PrivateLobby&#10;        subscribeToLobbyUpdate()&#10;        // GameStarted-Event aus WebSocketService übernehmen&#10;        kotlinx.coroutines.GlobalScope.launch {&#10;            webSocketService.gameStartedEvent.collectLatest { response -&gt;&#10;                if (response != null) {&#10;                    _gameStarted.value = response&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Game started Event empfangen: $response&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun subscribeToLobbyUpdate() {&#10;        webSocketService.subscribeToTopic(&quot;/user/queue/lobby-update&quot;, &quot;lobby-update&quot;)&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            // Prüfe, ob es sich um eine LOBBY_UPDATE-Nachricht handelt&#10;            try {&#10;                val json = gson.fromJson(message, Map::class.java)&#10;                if (json[&quot;type&quot;] == &quot;LOBBY_UPDATE&quot; &amp;&amp; json[&quot;lobbyId&quot;] is String) {&#10;                    val lobbyId = json[&quot;lobbyId&quot;] as String&#10;                    // Jetzt auf das Lobby-Topic subscriben&#10;                    webSocketService.subscribeToLobby(lobbyId)&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Auf Lobby-Topic subscribed: $lobbyId nach LOBBY_UPDATE&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Parsen der LOBBY_UPDATE-Nachricht&quot;, e)&#10;            }&#10;            // Weiterleitung an bestehendes Handling&#10;            handleWebSocketMessage(message)&#10;        }&#10;    }&#10;&#10;    // Quick Match beitreten&#10;    suspend fun joinQuickMatch(gameTime: GameTime): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinQuickMatch(QuickJoinRequest(gameTime))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyId = response.body()?.lobbyId&#10;                    ?: return Result.failure(Exception(&quot;Keine Lobby-ID erhalten&quot;))&#10;                _isWaitingForMatch.value = true&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyId)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Quick Match erfolgreich beigetreten: $lobbyId&quot;)&#10;                Result.success(lobbyId)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Unbekannter Fehler beim Quick Match&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Quick Match beitreten&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby erstellen&#10;    suspend fun createPrivateLobby(): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.createPrivateLobby()&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyCode = response.body()?.lobbyCode&#10;                    ?: return Result.failure(Exception(&quot;Kein Lobby-Code erhalten&quot;))&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Erstellen der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Erstellen der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby beitreten&#10;    suspend fun joinPrivateLobby(lobbyCode: String): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinPrivateLobby(JoinPrivateLobbyRequest(lobbyCode))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby beigetreten: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Beitreten der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Beitreten der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby verlassen&#10;    override suspend fun leaveLobby(lobbyId: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Zuerst WebSocket-Subscription beenden&#10;            webSocketService.unsubscribeFromLobby()&#10;&#10;            Log.d(&quot;LobbyService&quot;, &quot;Sende Leave-Request an API: LeaveLobbyRequest(lobbyId=$lobbyId)&quot;)&#10;            val response = lobbyApiService.leaveLobby(LeaveLobbyRequest(lobbyId))&#10;            if (response.isSuccessful) {&#10;                _currentLobby.value = null&#10;                _isWaitingForMatch.value = false&#10;                _lobbyMessages.value = emptyList()&#10;                lobbyLeft.emit(Unit)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Lobby verlassen: $lobbyId&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Verlassen der Lobby&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verlassen der Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun startGame(gameStartMessage: GameStartMessage): Result&lt;Unit&gt; {&#10;        return try {&#10;            webSocketService.sendStartGame(gameStartMessage)&#10;            Log.d(&quot;LobbyService&quot;, &quot;Spiel gestartet mit: $gameStartMessage&quot;)&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Starten des Spiels&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby-Info abrufen&#10;    suspend fun getLobbyInfo(lobbyId: String): Result&lt;Lobby&gt; {&#10;        return try {&#10;            val response = lobbyApiService.getLobbyInfo(lobbyId)&#10;            if (response.isSuccessful) {&#10;                val lobbyInfo = response.body()&#10;                    ?: return Result.failure(Exception(&quot;Keine Lobby-Daten erhalten&quot;))&#10;&#10;                // Sichere Behandlung von gameTime - kann null oder &quot;null&quot; sein&#10;                val gameTime = when {&#10;                    lobbyInfo.gameTime == null -&gt; null&#10;                    lobbyInfo.gameTime == &quot;null&quot; -&gt; null&#10;                    lobbyInfo.gameTime.isBlank() -&gt; null&#10;                    else -&gt; try {&#10;                        GameTime.valueOf(lobbyInfo.gameTime)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        Log.w(&quot;LobbyService&quot;, &quot;Unbekannte GameTime: ${lobbyInfo.gameTime}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val lobby = Lobby(&#10;                    lobbyId = lobbyInfo.lobbyId,&#10;                    lobbyType = LobbyType.valueOf(lobbyInfo.lobbyType),&#10;                    gameTime = gameTime,&#10;                    players = lobbyInfo.players,&#10;                    creator = lobbyInfo.creator,&#10;                    isGameStarted = lobbyInfo.isGameStarted,&#10;                    status = LobbyStatus.valueOf(lobbyInfo.status)&#10;                )&#10;                _currentLobby.value = lobby&#10;                Result.success(lobby)&#10;            } else {&#10;                Result.failure(Exception(&quot;Lobby nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Abrufen der Lobby-Info&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // WebSocket-Nachrichten verarbeiten&#10;    fun handleWebSocketMessage(message: String) {&#10;        try {&#10;            Log.d(&quot;LobbyService&quot;, &quot;WebSocket-Nachricht erhalten: $message&quot;)&#10;&#10;            // Parse JSON-Nachricht&#10;            val jsonObject = gson.fromJson(message, Map::class.java)&#10;            val messageType = jsonObject[&quot;type&quot;] as? String&#10;&#10;            when (messageType) {&#10;                &quot;lobby-waiting&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val waitingMessage = jsonObject[&quot;message&quot;] as? String&#10;                    _isWaitingForMatch.value = true&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Warte auf Gegner in Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-error&quot; -&gt; {&#10;                    val error = jsonObject[&quot;error&quot;] as? String ?: &quot;Unbekannter Lobby-Fehler&quot;&#10;                    _lobbyError.value = error&#10;                    _isWaitingForMatch.value = false&#10;                    Log.e(&quot;LobbyService&quot;, &quot;Lobby-Fehler: $error&quot;)&#10;                }&#10;&#10;                &quot;player-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val newPlayerId = jsonObject[&quot;newPlayerId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) }&#10;                                    ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler beigetreten: $newPlayerId - $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val creatorId = jsonObject[&quot;creatorId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) }&#10;                                    ?: currentLobby.status,&#10;                                creator = creatorId ?: currentLobby.creator&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby erfolgreich beigetreten: $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-update&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val updateMessage = jsonObject[&quot;message&quot;] as? String&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) }&#10;                                    ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby-Update: $updateMessage&quot;)&#10;                }&#10;&#10;                &quot;lobby-created&quot; -&gt; {&#10;                    val lobbyCode = jsonObject[&quot;lobbyCode&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode - $message&quot;)&#10;                }&#10;&#10;                &quot;PLAYER_READY&quot; -&gt; {&#10;                    val playerId = jsonObject[&quot;playerId&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler bereit: $playerId&quot;)&#10;                    // Hier könntest du den Ready-Status in der UI anzeigen&#10;                }&#10;&#10;                else -&gt; {&#10;                    // Versuche Legacy-Format zu parsen&#10;                    when {&#10;                        message.contains(&quot;\&quot;error\&quot;&quot;) -&gt; {&#10;                            val errorMsg = gson.fromJson(message, LobbyErrorMessage::class.java)&#10;                            _lobbyError.value = errorMsg.error&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;&#10;                        message.contains(&quot;\&quot;lobbyId\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;message\&quot;&quot;) -&gt; {&#10;                            val waitingMsg = gson.fromJson(message, LobbyWaitingMessage::class.java)&#10;                            _isWaitingForMatch.value = true&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            Log.w(&quot;LobbyService&quot;, &quot;Unbekannter Nachrichtentyp: $message&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verarbeiten der WebSocket-Nachricht: $message&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für Lobby-Chat-Nachrichten&#10;    fun sendLobbyMessage(lobbyId: String, content: String) {&#10;        webSocketService.sendLobbyChat(content)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Sende Chat-Nachricht in Lobby $lobbyId: $content&quot;)&#10;    }&#10;&#10;    // Neue Methode für Player-Ready-Status&#10;    fun setPlayerReady(lobbyId: String, ready: Boolean) {&#10;        webSocketService.sendPlayerReady(ready)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Setze Spieler-Status: ${if (ready) &quot;bereit&quot; else &quot;nicht bereit&quot;}&quot;)&#10;    }&#10;&#10;    // Fehler zurücksetzen&#10;    fun clearError() {&#10;        _lobbyError.value = null&#10;    }&#10;&#10;    // Spiel-Start zurücksetzen&#10;    fun clearGameStart() {&#10;        _gameStarted.value = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.service&#10;&#10;import android.util.Log&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.model.game.GameStartMessage&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.model.lobby.JoinPrivateLobbyRequest&#10;import app.chesspresso.model.lobby.LeaveLobbyRequest&#10;import app.chesspresso.model.lobby.Lobby&#10;import app.chesspresso.model.lobby.LobbyErrorMessage&#10;import app.chesspresso.model.lobby.LobbyMessage&#10;import app.chesspresso.model.lobby.LobbyStatus&#10;import app.chesspresso.model.lobby.LobbyType&#10;import app.chesspresso.model.lobby.LobbyWaitingMessage&#10;import app.chesspresso.model.lobby.QuickJoinRequest&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.MutableSharedFlow&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LobbyService @Inject constructor(&#10;    private val lobbyApiService: LobbyApiService,&#10;    private val webSocketService: StompWebSocketService,&#10;    private val gson: Gson&#10;) : LobbyListener {&#10;    private val _currentLobby = MutableStateFlow&lt;Lobby?&gt;(null)&#10;    override val currentLobby: StateFlow&lt;Lobby?&gt; = _currentLobby.asStateFlow()&#10;&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;LobbyMessage&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;LobbyMessage&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    private val _lobbyError = MutableStateFlow&lt;String?&gt;(null)&#10;    val lobbyError: StateFlow&lt;String?&gt; = _lobbyError.asStateFlow()&#10;&#10;    private val _isWaitingForMatch = MutableStateFlow(false)&#10;    val isWaitingForMatch: StateFlow&lt;Boolean&gt; = _isWaitingForMatch.asStateFlow()&#10;&#10;    private val _gameStarted = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val gameStarted: StateFlow&lt;GameStartResponse?&gt; = _gameStarted.asStateFlow()&#10;    val lobbyLeft = MutableSharedFlow&lt;Unit&gt;()&#10;&#10;    init {&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            handleWebSocketMessage(message)&#10;        }&#10;        webSocketService.setLobbyListener(this)&#10;        // Subscription auf /user/queue/lobby-update für QuickMatch und PrivateLobby&#10;        subscribeToLobbyUpdate()&#10;        // GameStarted-Event aus WebSocketService übernehmen&#10;        kotlinx.coroutines.GlobalScope.launch {&#10;            webSocketService.gameStartedEvent.collectLatest { response -&gt;&#10;                if (response != null) {&#10;                    _gameStarted.value = response&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Game started Event empfangen: $response&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun subscribeToLobbyUpdate() {&#10;        webSocketService.subscribeToTopic(&quot;/user/queue/lobby-update&quot;, &quot;lobby-update&quot;)&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            // Prüfe, ob es sich um eine LOBBY_UPDATE-Nachricht handelt&#10;            try {&#10;                val json = gson.fromJson(message, Map::class.java)&#10;                if (json[&quot;type&quot;] == &quot;LOBBY_UPDATE&quot; &amp;&amp; json[&quot;lobbyId&quot;] is String) {&#10;                    val lobbyId = json[&quot;lobbyId&quot;] as String&#10;                    // Jetzt auf das Lobby-Topic subscriben&#10;                    webSocketService.subscribeToLobby(lobbyId)&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Auf Lobby-Topic subscribed: $lobbyId nach LOBBY_UPDATE&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Parsen der LOBBY_UPDATE-Nachricht&quot;, e)&#10;            }&#10;            // Weiterleitung an bestehendes Handling&#10;            handleWebSocketMessage(message)&#10;        }&#10;    }&#10;&#10;    // Quick Match beitreten&#10;    suspend fun joinQuickMatch(gameTime: GameTime): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinQuickMatch(QuickJoinRequest(gameTime))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyId = response.body()?.lobbyId&#10;                    ?: return Result.failure(Exception(&quot;Keine Lobby-ID erhalten&quot;))&#10;                _isWaitingForMatch.value = true&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyId)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Quick Match erfolgreich beigetreten: $lobbyId&quot;)&#10;                Result.success(lobbyId)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Unbekannter Fehler beim Quick Match&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Quick Match beitreten&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby erstellen&#10;    suspend fun createPrivateLobby(): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.createPrivateLobby()&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyCode = response.body()?.lobbyCode&#10;                    ?: return Result.failure(Exception(&quot;Kein Lobby-Code erhalten&quot;))&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Erstellen der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Erstellen der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby beitreten&#10;    suspend fun joinPrivateLobby(lobbyCode: String): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinPrivateLobby(JoinPrivateLobbyRequest(lobbyCode))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby beigetreten: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Beitreten der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Beitreten der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby verlassen&#10;    override suspend fun leaveLobby(lobbyId: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Zuerst WebSocket-Subscription beenden&#10;            webSocketService.unsubscribeFromLobby()&#10;&#10;            Log.d(&quot;LobbyService&quot;, &quot;Sende Leave-Request an API: LeaveLobbyRequest(lobbyId=$lobbyId)&quot;)&#10;            val response = lobbyApiService.leaveLobby(LeaveLobbyRequest(lobbyId))&#10;            if (response.isSuccessful) {&#10;                _currentLobby.value = null&#10;                _isWaitingForMatch.value = false&#10;                _lobbyMessages.value = emptyList()&#10;                lobbyLeft.emit(Unit)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Lobby verlassen: $lobbyId&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Verlassen der Lobby&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verlassen der Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun startGame(gameStartMessage: GameStartMessage): Result&lt;Unit&gt; {&#10;        return try {&#10;            webSocketService.sendStartGame(gameStartMessage)&#10;            Log.d(&quot;LobbyService&quot;, &quot;Spiel gestartet mit: $gameStartMessage&quot;)&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Starten des Spiels&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby-Info abrufen&#10;    suspend fun getLobbyInfo(lobbyId: String): Result&lt;Lobby&gt; {&#10;        return try {&#10;            val response = lobbyApiService.getLobbyInfo(lobbyId)&#10;            if (response.isSuccessful) {&#10;                val lobbyInfo = response.body()&#10;                    ?: return Result.failure(Exception(&quot;Keine Lobby-Daten erhalten&quot;))&#10;&#10;                // Sichere Behandlung von gameTime - kann null oder &quot;null&quot; sein&#10;                val gameTime = when {&#10;                    lobbyInfo.gameTime == null -&gt; null&#10;                    lobbyInfo.gameTime == &quot;null&quot; -&gt; null&#10;                    lobbyInfo.gameTime.isBlank() -&gt; null&#10;                    else -&gt; try {&#10;                        GameTime.valueOf(lobbyInfo.gameTime)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        Log.w(&quot;LobbyService&quot;, &quot;Unbekannte GameTime: ${lobbyInfo.gameTime}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val lobby = Lobby(&#10;                    lobbyId = lobbyInfo.lobbyId,&#10;                    lobbyType = LobbyType.valueOf(lobbyInfo.lobbyType),&#10;                    gameTime = gameTime,&#10;                    players = lobbyInfo.players,&#10;                    creator = lobbyInfo.creator,&#10;                    isGameStarted = lobbyInfo.isGameStarted,&#10;                    status = LobbyStatus.valueOf(lobbyInfo.status)&#10;                )&#10;                _currentLobby.value = lobby&#10;                Result.success(lobby)&#10;            } else {&#10;                Result.failure(Exception(&quot;Lobby nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Abrufen der Lobby-Info&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // WebSocket-Nachrichten verarbeiten&#10;    fun handleWebSocketMessage(message: String) {&#10;        try {&#10;            Log.d(&quot;LobbyService&quot;, &quot;WebSocket-Nachricht erhalten: $message&quot;)&#10;&#10;            // Parse JSON-Nachricht&#10;            val jsonObject = gson.fromJson(message, Map::class.java)&#10;            val messageType = jsonObject[&quot;type&quot;] as? String&#10;&#10;            when (messageType) {&#10;                &quot;lobby-waiting&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val waitingMessage = jsonObject[&quot;message&quot;] as? String&#10;                    _isWaitingForMatch.value = true&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Warte auf Gegner in Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-error&quot; -&gt; {&#10;                    val error = jsonObject[&quot;error&quot;] as? String ?: &quot;Unbekannter Lobby-Fehler&quot;&#10;                    _lobbyError.value = error&#10;                    _isWaitingForMatch.value = false&#10;                    Log.e(&quot;LobbyService&quot;, &quot;Lobby-Fehler: $error&quot;)&#10;                }&#10;&#10;                &quot;player-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val newPlayerId = jsonObject[&quot;newPlayerId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) }&#10;                                    ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler beigetreten: $newPlayerId - $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val creatorId = jsonObject[&quot;creatorId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) }&#10;                                    ?: currentLobby.status,&#10;                                creator = creatorId ?: currentLobby.creator&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby erfolgreich beigetreten: $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-update&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val updateMessage = jsonObject[&quot;message&quot;] as? String&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) }&#10;                                    ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby-Update: $updateMessage&quot;)&#10;                }&#10;&#10;                &quot;lobby-created&quot; -&gt; {&#10;                    val lobbyCode = jsonObject[&quot;lobbyCode&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode - $message&quot;)&#10;                }&#10;&#10;                &quot;PLAYER_READY&quot; -&gt; {&#10;                    val playerId = jsonObject[&quot;playerId&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler bereit: $playerId&quot;)&#10;                    // Hier könntest du den Ready-Status in der UI anzeigen&#10;                }&#10;&#10;                else -&gt; {&#10;                    // Versuche Legacy-Format zu parsen&#10;                    when {&#10;                        message.contains(&quot;\&quot;error\&quot;&quot;) -&gt; {&#10;                            val errorMsg = gson.fromJson(message, LobbyErrorMessage::class.java)&#10;                            _lobbyError.value = errorMsg.error&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;&#10;                        message.contains(&quot;\&quot;lobbyId\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;message\&quot;&quot;) -&gt; {&#10;                            val waitingMsg = gson.fromJson(message, LobbyWaitingMessage::class.java)&#10;                            _isWaitingForMatch.value = true&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            Log.w(&quot;LobbyService&quot;, &quot;Unbekannter Nachrichtentyp: $message&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verarbeiten der WebSocket-Nachricht: $message&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für Lobby-Chat-Nachrichten&#10;    fun sendLobbyMessage(lobbyId: String, content: String) {&#10;        webSocketService.sendLobbyChat(content)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Sende Chat-Nachricht in Lobby $lobbyId: $content&quot;)&#10;    }&#10;&#10;    // Neue Methode für Player-Ready-Status&#10;    fun setPlayerReady(lobbyId: String, ready: Boolean) {&#10;        webSocketService.sendPlayerReady(ready)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Setze Spieler-Status: ${if (ready) &quot;bereit&quot; else &quot;nicht bereit&quot;}&quot;)&#10;    }&#10;&#10;    // Fehler zurücksetzen&#10;    fun clearError() {&#10;        _lobbyError.value = null&#10;    }&#10;&#10;    // Spiel-Start zurücksetzen&#10;    fun clearGameStart() {&#10;        _gameStarted.value = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.EndType&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.GameEndMessage&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChessGameViewModel @Inject constructor(&#10;    val webSocketService: StompWebSocketService&#10;) : ViewModel() {&#10;&#10;    private val _currentGameState = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val currentGameState: StateFlow&lt;GameMoveResponse?&gt; = _currentGameState.asStateFlow()&#10;&#10;    private val _initialGameData = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val initialGameData: StateFlow&lt;GameStartResponse?&gt; = _initialGameData.asStateFlow()&#10;&#10;    private val _currentBoard = MutableStateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyMap())&#10;    val currentBoard: StateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt; = _currentBoard.asStateFlow()&#10;&#10;    private val _currentPlayer = MutableStateFlow&lt;app.chesspresso.model.TeamColor?&gt;(null)&#10;    val currentPlayer: StateFlow&lt;app.chesspresso.model.TeamColor?&gt; = _currentPlayer.asStateFlow()&#10;&#10;    private val _whiteTime = MutableStateFlow(0)&#10;    val whiteTime: StateFlow&lt;Int&gt; = _whiteTime.asStateFlow()&#10;    private val _blackTime = MutableStateFlow(0)&#10;    val blackTime: StateFlow&lt;Int&gt; = _blackTime.asStateFlow()&#10;&#10;    private val _myColor = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val myColor: StateFlow&lt;TeamColor?&gt; = _myColor.asStateFlow()&#10;&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    private val _capturedWhitePieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedWhitePieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedWhitePieces.asStateFlow()&#10;    private val _capturedBlackPieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedBlackPieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedBlackPieces.asStateFlow()&#10;    private val _promotionRequest = MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; = _promotionRequest.asStateFlow()&#10;&#10;    private val _gameEndEvent = MutableStateFlow&lt;GameEndResponse?&gt;(null)&#10;    val gameEndEvent: StateFlow&lt;GameEndResponse?&gt; = _gameEndEvent&#10;&#10;    private val _moveHistory = MutableStateFlow&lt;List&lt;GameMoveResponse&gt;&gt;(emptyList())&#10;    val moveHistory: StateFlow&lt;List&lt;GameMoveResponse&gt;&gt; = _moveHistory.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var lastActivePlayer: TeamColor? = null&#10;    private var timeoutSent = false // Neu: Flag, um Mehrfachsendung zu verhindern&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            webSocketService.gameStartedEvent.collect { event -&gt;&#10;                event?.let { initializeGame(it) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.possibleMoves.collect { moves -&gt;&#10;                _possibleMoves.value = moves&#10;            }&#10;        }&#10;        // GameMoveResponse-Listener nur einmalig im init-Block registrieren!&#10;        viewModelScope.launch {&#10;            webSocketService.gameMoveUpdates.collect { gameMoveResponse -&gt;&#10;                gameMoveResponse?.let { response -&gt;&#10;                    val captured = response.move.captured&#10;                    if (captured != null &amp;&amp; captured.type != null &amp;&amp; captured.color != null) {&#10;                        val capturedPiece = app.chesspresso.model.game.PieceInfo(&#10;                            type = captured.type,&#10;                            color = captured.color&#10;                        )&#10;                        when (captured.color) {&#10;                            TeamColor.WHITE -&gt; _capturedWhitePieces.value = _capturedWhitePieces.value + capturedPiece&#10;                            TeamColor.BLACK -&gt; _capturedBlackPieces.value = _capturedBlackPieces.value + capturedPiece&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                    val newBoard = response.board&#10;                    _currentGameState.value = response&#10;                    _currentBoard.value = newBoard&#10;                    _possibleMoves.value = emptyList()&#10;                    if (response.nextPlayer != lastActivePlayer) {&#10;                        startTimer(response.nextPlayer)&#10;                        lastActivePlayer = response.nextPlayer&#10;                    }&#10;                    _currentPlayer.value = response.nextPlayer&#10;                    // Promotion-UI ausblenden, sobald ein Zug vom Server kommt&#10;                    _promotionRequest.value = null&#10;                    // Zug zur History hinzufügen&#10;                    _moveHistory.value = _moveHistory.value + response&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.promotionRequest.collect { request -&gt;&#10;                _promotionRequest.value = request&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.gameEndEvent.collect { event -&gt;&#10;                _gameEndEvent.value = event&#10;            }&#10;        }&#10;    }&#10;&#10;    fun initializeGame(gameStartResponse: GameStartResponse) {&#10;        viewModelScope.launch {&#10;            // Warte, bis playerId gesetzt ist&#10;            var myId = webSocketService.playerId&#10;            var retry = 0&#10;            while (myId == null &amp;&amp; retry &lt; 50) { // max. 5 Sekunden warten&#10;                delay(100)&#10;                myId = webSocketService.playerId&#10;                retry++&#10;            }&#10;            if (myId == null) {&#10;                // Fehlerfall: ID konnte nicht ermittelt werden&#10;                android.util.Log.e(&quot;ChessGameViewModel&quot;, &quot;playerId ist nach 5 Sekunden immer noch null!&quot;)&#10;            }&#10;            _currentGameState.value = null&#10;            _initialGameData.value = gameStartResponse&#10;            _currentBoard.value = gameStartResponse.board&#10;            _currentPlayer.value = TeamColor.WHITE // Weiß beginnt immer&#10;&#10;            // Eigene Farbe bestimmen&#10;            android.util.Log.d(&quot;ChessGameViewModel&quot;, &quot;myId: $myId, whitePlayer: ${gameStartResponse.whitePlayer}, blackPlayer: ${gameStartResponse.blackPlayer}&quot;)&#10;            _myColor.value = when (myId) {&#10;                gameStartResponse.whitePlayer -&gt; TeamColor.WHITE&#10;                gameStartResponse.blackPlayer -&gt; TeamColor.BLACK&#10;                else -&gt; null&#10;            }&#10;&#10;            // Zeit direkt aus gameTime (jetzt Int in Sekunden)&#10;            _whiteTime.value = gameStartResponse.gameTime.seconds&#10;            _blackTime.value = gameStartResponse.gameTime.seconds&#10;            lastActivePlayer = TeamColor.WHITE&#10;            startTimer(TeamColor.WHITE)&#10;&#10;            // Subscribe zu Spiel-Updates für diese Lobby&#10;            webSocketService.subscribeToGame(gameStartResponse.lobbyId)&#10;        }&#10;    }&#10;&#10;    private fun startTimer(activePlayer: TeamColor) {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            timeoutSent = false // Timer-Start: Reset Flag&#10;            while (true) {&#10;                delay(1000)&#10;                if (activePlayer == TeamColor.WHITE) {&#10;                    if (_whiteTime.value &gt; 0) {&#10;                        _whiteTime.value = _whiteTime.value - 1&#10;                        if (_whiteTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.WHITE) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.WHITE)&#10;                        }&#10;                    }&#10;                } else {&#10;                    if (_blackTime.value &gt; 0) {&#10;                        _blackTime.value = _blackTime.value - 1&#10;                        if (_blackTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.BLACK) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.BLACK)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendTimeoutEndMessage(teamColor: TeamColor) {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.TIMEOUT&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun sendPositionRequest(lobbyId: String, position: String) {&#10;        viewModelScope.launch {&#10;            val message = app.chesspresso.model.game.PositionRequestMessage(lobbyId, position)&#10;            webSocketService.sendPositionRequest(message)&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(lobbyId: String, from: String, to: String, teamColor: TeamColor, promotedPiece: PieceType? = null) {&#10;        val message = app.chesspresso.model.game.GameMoveMessage(&#10;            lobbyId = lobbyId,&#10;            from = from,&#10;            to = to,&#10;            teamColor = teamColor,&#10;            promotedPiece = promotedPiece&#10;        )&#10;        webSocketService.sendGameMoveMessage(message)&#10;    }&#10;&#10;    fun resignGame(teamColor: TeamColor, lobbyId: String) {&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.RESIGNATION&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun resetGameState() {&#10;        timerJob?.cancel()&#10;        timeoutSent = false&#10;        lastActivePlayer = null&#10;        _currentGameState.value = null&#10;        _initialGameData.value = null&#10;        _currentBoard.value = emptyMap()&#10;        _currentPlayer.value = null&#10;        _whiteTime.value = 0&#10;        _blackTime.value = 0&#10;        _myColor.value = null&#10;        _possibleMoves.value = emptyList()&#10;        _capturedWhitePieces.value = emptyList()&#10;        _capturedBlackPieces.value = emptyList()&#10;        _promotionRequest.value = null&#10;        _gameEndEvent.value = null&#10;        _moveHistory.value = emptyList()&#10;        webSocketService.unsubscribeFromGame()&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        webSocketService.unsubscribeFromGame()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.EndType&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.GameEndMessage&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChessGameViewModel @Inject constructor(&#10;    val webSocketService: StompWebSocketService&#10;) : ViewModel() {&#10;&#10;    private val _currentGameState = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val currentGameState: StateFlow&lt;GameMoveResponse?&gt; = _currentGameState.asStateFlow()&#10;&#10;    private val _initialGameData = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val initialGameData: StateFlow&lt;GameStartResponse?&gt; = _initialGameData.asStateFlow()&#10;&#10;    private val _currentBoard = MutableStateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyMap())&#10;    val currentBoard: StateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt; = _currentBoard.asStateFlow()&#10;&#10;    private val _currentPlayer = MutableStateFlow&lt;app.chesspresso.model.TeamColor?&gt;(null)&#10;    val currentPlayer: StateFlow&lt;app.chesspresso.model.TeamColor?&gt; = _currentPlayer.asStateFlow()&#10;&#10;    private val _whiteTime = MutableStateFlow(0)&#10;    val whiteTime: StateFlow&lt;Int&gt; = _whiteTime.asStateFlow()&#10;    private val _blackTime = MutableStateFlow(0)&#10;    val blackTime: StateFlow&lt;Int&gt; = _blackTime.asStateFlow()&#10;&#10;    private val _myColor = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val myColor: StateFlow&lt;TeamColor?&gt; = _myColor.asStateFlow()&#10;&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    private val _capturedWhitePieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedWhitePieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedWhitePieces.asStateFlow()&#10;    private val _capturedBlackPieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedBlackPieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedBlackPieces.asStateFlow()&#10;    private val _promotionRequest = MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; = _promotionRequest.asStateFlow()&#10;&#10;    private val _gameEndEvent = MutableStateFlow&lt;GameEndResponse?&gt;(null)&#10;    val gameEndEvent: StateFlow&lt;GameEndResponse?&gt; = _gameEndEvent&#10;&#10;    private val _moveHistory = MutableStateFlow&lt;List&lt;GameMoveResponse&gt;&gt;(emptyList())&#10;    val moveHistory: StateFlow&lt;List&lt;GameMoveResponse&gt;&gt; = _moveHistory.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var lastActivePlayer: TeamColor? = null&#10;    private var timeoutSent = false // Neu: Flag, um Mehrfachsendung zu verhindern&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            webSocketService.gameStartedEvent.collect { event -&gt;&#10;                event?.let { initializeGame(it) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.possibleMoves.collect { moves -&gt;&#10;                _possibleMoves.value = moves&#10;            }&#10;        }&#10;        // GameMoveResponse-Listener nur einmalig im init-Block registrieren!&#10;        viewModelScope.launch {&#10;            webSocketService.gameMoveUpdates.collect { gameMoveResponse -&gt;&#10;                gameMoveResponse?.let { response -&gt;&#10;                    val captured = response.move.captured&#10;                    if (captured != null &amp;&amp; captured.type != null &amp;&amp; captured.color != null) {&#10;                        val capturedPiece = app.chesspresso.model.game.PieceInfo(&#10;                            type = captured.type,&#10;                            color = captured.color&#10;                        )&#10;                        when (captured.color) {&#10;                            TeamColor.WHITE -&gt; _capturedWhitePieces.value = _capturedWhitePieces.value + capturedPiece&#10;                            TeamColor.BLACK -&gt; _capturedBlackPieces.value = _capturedBlackPieces.value + capturedPiece&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                    val newBoard = response.board&#10;                    _currentGameState.value = response&#10;                    _currentBoard.value = newBoard&#10;                    _possibleMoves.value = emptyList()&#10;                    if (response.nextPlayer != lastActivePlayer) {&#10;                        startTimer(response.nextPlayer)&#10;                        lastActivePlayer = response.nextPlayer&#10;                    }&#10;                    _currentPlayer.value = response.nextPlayer&#10;                    // Promotion-UI ausblenden, sobald ein Zug vom Server kommt&#10;                    _promotionRequest.value = null&#10;                    // Zug zur History hinzufügen&#10;                    _moveHistory.value = _moveHistory.value + response&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.promotionRequest.collect { request -&gt;&#10;                _promotionRequest.value = request&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.gameEndEvent.collect { event -&gt;&#10;                _gameEndEvent.value = event&#10;            }&#10;        }&#10;    }&#10;&#10;    fun initializeGame(gameStartResponse: GameStartResponse) {&#10;        viewModelScope.launch {&#10;            // Warte, bis playerId gesetzt ist&#10;            var myId = webSocketService.playerId&#10;            var retry = 0&#10;            while (myId == null &amp;&amp; retry &lt; 50) { // max. 5 Sekunden warten&#10;                delay(100)&#10;                myId = webSocketService.playerId&#10;                retry++&#10;            }&#10;            if (myId == null) {&#10;                // Fehlerfall: ID konnte nicht ermittelt werden&#10;                android.util.Log.e(&quot;ChessGameViewModel&quot;, &quot;playerId ist nach 5 Sekunden immer noch null!&quot;)&#10;            }&#10;            _currentGameState.value = null&#10;            _initialGameData.value = gameStartResponse&#10;            _currentBoard.value = gameStartResponse.board&#10;            _currentPlayer.value = TeamColor.WHITE // Weiß beginnt immer&#10;&#10;            // Eigene Farbe bestimmen&#10;            android.util.Log.d(&quot;ChessGameViewModel&quot;, &quot;myId: $myId, whitePlayer: ${gameStartResponse.whitePlayer}, blackPlayer: ${gameStartResponse.blackPlayer}&quot;)&#10;            _myColor.value = when (myId) {&#10;                gameStartResponse.whitePlayer -&gt; TeamColor.WHITE&#10;                gameStartResponse.blackPlayer -&gt; TeamColor.BLACK&#10;                else -&gt; null&#10;            }&#10;&#10;            // Zeit direkt aus gameTime (jetzt Int in Sekunden)&#10;            _whiteTime.value = gameStartResponse.gameTime.seconds&#10;            _blackTime.value = gameStartResponse.gameTime.seconds&#10;            lastActivePlayer = TeamColor.WHITE&#10;            startTimer(TeamColor.WHITE)&#10;&#10;            // Subscribe zu Spiel-Updates für diese Lobby&#10;            webSocketService.subscribeToGame(gameStartResponse.lobbyId)&#10;        }&#10;    }&#10;&#10;    private fun startTimer(activePlayer: TeamColor) {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            timeoutSent = false // Timer-Start: Reset Flag&#10;            while (true) {&#10;                delay(1000)&#10;                if (activePlayer == TeamColor.WHITE) {&#10;                    if (_whiteTime.value &gt; 0) {&#10;                        _whiteTime.value = _whiteTime.value - 1&#10;                        if (_whiteTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.WHITE) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.WHITE)&#10;                        }&#10;                    }&#10;                } else {&#10;                    if (_blackTime.value &gt; 0) {&#10;                        _blackTime.value = _blackTime.value - 1&#10;                        if (_blackTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.BLACK) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.BLACK)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun sendTimeoutEndMessage(teamColor: TeamColor) {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.TIMEOUT&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun sendPositionRequest(lobbyId: String, position: String) {&#10;        viewModelScope.launch {&#10;            val message = app.chesspresso.model.game.PositionRequestMessage(lobbyId, position)&#10;            webSocketService.sendPositionRequest(message)&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(lobbyId: String, from: String, to: String, teamColor: TeamColor, promotedPiece: PieceType? = null) {&#10;        val message = app.chesspresso.model.game.GameMoveMessage(&#10;            lobbyId = lobbyId,&#10;            from = from,&#10;            to = to,&#10;            teamColor = teamColor,&#10;            promotedPiece = promotedPiece&#10;        )&#10;        webSocketService.sendGameMoveMessage(message)&#10;    }&#10;&#10;    fun resignGame(teamColor: TeamColor, lobbyId: String) {&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.RESIGNATION&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun resetGameState() {&#10;        timerJob?.cancel()&#10;        timeoutSent = false&#10;        lastActivePlayer = null&#10;        _currentGameState.value = null&#10;        _initialGameData.value = null&#10;        _currentBoard.value = emptyMap()&#10;        _currentPlayer.value = null&#10;        _whiteTime.value = 0&#10;        _blackTime.value = 0&#10;        _myColor.value = null&#10;        _possibleMoves.value = emptyList()&#10;        _capturedWhitePieces.value = emptyList()&#10;        _capturedBlackPieces.value = emptyList()&#10;        _promotionRequest.value = null&#10;        _gameEndEvent.value = null&#10;        _moveHistory.value = emptyList()&#10;        webSocketService.unsubscribeFromGame()&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        webSocketService.unsubscribeFromGame()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/StompWebSocketService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/StompWebSocketService.kt" />
              <option name="originalContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.model.game.GameMoveMessage&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.game.GameStartMessage&#10;import app.chesspresso.model.game.PawnPromotionMessage&#10;import app.chesspresso.model.game.PieceInfo&#10;import app.chesspresso.model.game.PositionRequestMessage&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.GameEndMessage&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.service.LobbyListener&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.serialization.encodeToString&#10;import kotlinx.serialization.json.Json&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StompWebSocketService @Inject constructor(&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;StompWebSocket&quot;&#10;        private const val WS_URL = &quot;ws://10.0.2.2:8080/ws&quot;&#10;        private const val HEARTBEAT_INTERVAL = 30000L // 30 Sekunden&#10;        private const val RECONNECT_DELAY = 3000L // 3 Sekunden&#10;    }&#10;&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;    private var reconnectJob: Job? = null&#10;    private var _playerId: String? = null&#10;    val playerId: String?&#10;        get() = _playerId&#10;    private var currentLobbyId: String? = null&#10;&#10;    private var lobbyListener: LobbyListener? = null&#10;&#10;    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;ConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    private val _connectionMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val connectionMessages: StateFlow&lt;List&lt;String&gt;&gt; = _connectionMessages.asStateFlow()&#10;&#10;    // Lobby-spezifische Flows&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;String&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    // Spiel-spezifische Flows&#10;    private val _gameMoveUpdates = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val gameMoveUpdates: StateFlow&lt;GameMoveResponse?&gt; = _gameMoveUpdates.asStateFlow()&#10;&#10;    // Callback für Lobby-Message-Handling&#10;    private var lobbyMessageHandler: ((String) -&gt; Unit)? = null&#10;    val MESSAGE_END = &quot;\u0000&quot;&#10;&#10;    private val json = Json { ignoreUnknownKeys = true }&#10;    private val gson = Gson()&#10;    private val _gameStartedEvent = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val gameStartedEvent: StateFlow&lt;GameStartResponse?&gt; = _gameStartedEvent.asStateFlow()&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    // Promotion-Flow&#10;    private val _promotionRequest = MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; = _promotionRequest.asStateFlow()&#10;&#10;    // Game End Flow&#10;    private val _gameEndEvent = MutableStateFlow&lt;GameEndResponse?&gt;(null)&#10;    val gameEndEvent: StateFlow&lt;GameEndResponse?&gt; = _gameEndEvent&#10;&#10;    enum class ConnectionState {&#10;        DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING&#10;    }&#10;&#10;    enum class ServerStatus {&#10;        OFFLINE, ONLINE, BUSY, MAINTENANCE, UNKNOWN&#10;    }&#10;&#10;    fun setLobbyListener(listener: LobbyListener) {&#10;        this.lobbyListener = listener&#10;    }&#10;&#10;    private val _serverStatus = MutableStateFlow(ServerStatus.UNKNOWN)&#10;    val serverStatus: StateFlow&lt;ServerStatus&gt; = _serverStatus.asStateFlow()&#10;&#10;    private val _lastMessageTimestamp = MutableStateFlow(0L)&#10;    private var serverStatusCheckJob: Job? = null&#10;&#10;    // Timeout für Server-Status-Überprüfung (10 Sekunden)&#10;    private val SERVER_STATUS_TIMEOUT = 10_000L&#10;&#10;    private val webSocketListener = object : WebSocketListener() {&#10;        override fun onOpen(webSocket: WebSocket, response: Response) {&#10;            Log.d(TAG, &quot;WebSocket connection opened&quot;)&#10;            _connectionState.value = ConnectionState.CONNECTED&#10;&#10;            // Sende STOMP CONNECT Frame&#10;            sendStompConnect()&#10;&#10;            // Starte Heartbeat&#10;            startHeartbeat()&#10;&#10;            // Starte Server-Status-Überprüfung&#10;            startServerStatusCheck()&#10;&#10;            // Subscription zu Topics erfolgt erst nach CONNECTED-Antwort vom Server&#10;        }&#10;&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            Log.d(TAG, &quot;Received message: $text&quot;)&#10;            handleStompMessage(text)&#10;        }&#10;&#10;        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;            Log.e(TAG, &quot;WebSocket connection failed: ${t.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;            scheduleReconnect()&#10;        }&#10;&#10;        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;            Log.i(TAG, &quot;WebSocket connection closed: $reason&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;        }&#10;    }&#10;&#10;    suspend fun connect(username: String) {&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected&quot;)&#10;            return&#10;        }&#10;&#10;        _playerId = username&#10;        _connectionState.value = ConnectionState.CONNECTING&#10;&#10;        try {&#10;            // Token synchron abrufen&#10;            val token = tokenStorage.getToken().first()&#10;            Log.d(TAG, &quot;Retrieved token for WebSocket connection: ${token?.take(20)}...&quot;)&#10;&#10;            val client = OkHttpClient.Builder()&#10;                .pingInterval(30, TimeUnit.SECONDS)&#10;                .build()&#10;&#10;            val requestBuilder = Request.Builder().url(WS_URL)&#10;&#10;            // Nur Authorization Header hinzufügen wenn Token verfügbar ist&#10;            token?.let {&#10;                requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $it&quot;)&#10;                Log.d(TAG, &quot;Added Authorization header to WebSocket request&quot;)&#10;            } ?: Log.w(TAG, &quot;No token available for WebSocket connection&quot;)&#10;&#10;            val request = requestBuilder.build()&#10;            webSocket = client.newWebSocket(request, webSocketListener)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to connect: ${e.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;        }&#10;    }&#10;&#10;    private fun sendStompConnect() {&#10;        val connectFrame = buildString {&#10;            append(&quot;CONNECT\n&quot;)&#10;            append(&quot;accept-version:1.0,1.1,2.0\n&quot;)&#10;            append(&quot;heart-beat:5000,5000\n&quot;)&#10;            _playerId?.let { append(&quot;login:$it\n&quot;) }&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(connectFrame)&#10;        Log.d(TAG, &quot;Sent STOMP CONNECT frame&quot;)&#10;    }&#10;&#10;    private fun subscribeToTopics() {&#10;        Log.d(TAG, &quot;Subscribing to topics&quot;)&#10;        _playerId?.let { id -&gt;&#10;            // Subscribe zu persönlichen Nachrichten&#10;            // 200 ms warten&#10;            val subscribeFrame2 = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-2\n&quot;)&#10;                append(&quot;destination:/topic/players\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrame2)&#10;            Log.d(TAG, &quot;Subscribed to topics&quot;)&#10;&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                delay(200)&#10;                val subscribeFrame1 = buildString {&#10;                    append(&quot;SUBSCRIBE\n&quot;)&#10;                    append(&quot;id:sub-1\n&quot;)&#10;                    append(&quot;destination:/user/queue/status\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;                webSocket?.send(subscribeFrame1)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                sendHeartbeat()&#10;                delay(HEARTBEAT_INTERVAL)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Heartbeat started&quot;)&#10;    }&#10;&#10;    private fun sendHeartbeat() {&#10;        _playerId?.let { id -&gt;&#10;            val heartbeatFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/heartbeat\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;heartbeat&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(heartbeatFrame)&#10;            Log.d(TAG, &quot;Sent heartbeat for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleStompMessage(message: String) {&#10;        try {&#10;            // Auf CONNECTED Frame vom Server prüfen&#10;            if (message.startsWith(&quot;CONNECTED&quot;)) {&#10;                Log.d(TAG, &quot;Received STOMP CONNECTED frame from server&quot;)&#10;                // Jetzt erst die Subscriptions starten, wenn der Server die Verbindung bestätigt hat&#10;                subscribeToTopics()&#10;                return&#10;            }&#10;&#10;            if (message.startsWith(&quot;MESSAGE&quot;)) {&#10;                val lines = message.split(&quot;\n&quot;)&#10;                var body = &quot;&quot;&#10;                var isBody = false&#10;&#10;                for (line in lines) {&#10;                    if (isBody) {&#10;                        body += line&#10;                    } else if (line.isEmpty()) {&#10;                        isBody = true&#10;                    }&#10;                }&#10;&#10;                // Entferne Null-Terminator&#10;                body = body.replace(MESSAGE_END, &quot;&quot;)&#10;&#10;                if (body.isNotEmpty()) {&#10;                    handleMessageBody(body)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error handling STOMP message: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleMessageBody(body: String) {&#10;        try {&#10;            val json = JSONObject(body)&#10;            val type = json.optString(&quot;type&quot;)&#10;&#10;            when (type) {&#10;                &quot;status-update&quot; -&gt; {&#10;                    val status = json.optString(&quot;status&quot;)&#10;                    Log.d(TAG, &quot;Status update received: $status&quot;)&#10;&#10;                    // Server-Status verarbeiten&#10;                    updateServerStatus(status)&#10;                }&#10;                &quot;lobby-message&quot; -&gt; {&#10;                    // Lobby-spezifische Nachrichten verarbeiten&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val messageContent = json.optString(&quot;message&quot;)&#10;&#10;                    if (lobbyId == currentLobbyId) {&#10;                        // Nur Nachrichten für den aktuellen Lobby-Kontext weiterleiten&#10;                        _lobbyMessages.value = _lobbyMessages.value + messageContent&#10;                        Log.d(TAG, &quot;Lobby message received: $messageContent&quot;)&#10;                        // Optional: Direktes Handling der Nachricht über den Handler&#10;                        lobbyMessageHandler?.invoke(messageContent)&#10;                    }&#10;                }&#10;&#10;                &quot;gameStarted&quot; -&gt; {&#10;                    val boardMap: Map&lt;String, PieceInfo&gt;? = if (json.isNull(&quot;board&quot;)) {&#10;                        null&#10;                    } else {&#10;                        val boardJson = json.getJSONObject(&quot;board&quot;).toString()&#10;                        val boardType = object : TypeToken&lt;Map&lt;String, PieceInfo&gt;&gt;() {}.type&#10;                        gson.fromJson&lt;Map&lt;String, PieceInfo&gt;&gt;(boardJson, boardType)&#10;                    }&#10;                    val rawSuccess = json.opt(&quot;success&quot;)&#10;                    Log.d(TAG, &quot;[DEBUG] gameStarted: rawSuccess=$rawSuccess, type=${rawSuccess?.javaClass?.name}&quot;)&#10;                    val success = when (rawSuccess) {&#10;                        is Boolean -&gt; rawSuccess&#10;                        is String -&gt; rawSuccess.equals(&quot;true&quot;, ignoreCase = true)&#10;                        is Number -&gt; rawSuccess.toInt() != 0&#10;                        else -&gt; false&#10;                    }&#10;                    // GameTime als Enum direkt aus JSON parsen&#10;                    val gameTimeEnum = try {&#10;                        gson.fromJson(json.get(&quot;gameTime&quot;).toString(), app.chesspresso.model.lobby.GameTime::class.java)&#10;                    } catch (e: Exception) {&#10;                        app.chesspresso.model.lobby.GameTime.SHORT // Fallback auf 5 Minuten&#10;                    }&#10;                    val response = GameStartResponse(&#10;                        lobbyId = json.optString(&quot;lobbyId&quot;),&#10;                        gameTime = gameTimeEnum,&#10;                        whitePlayer = json.optString(&quot;whitePlayer&quot;),&#10;                        blackPlayer = json.optString(&quot;blackPlayer&quot;),&#10;                        board = boardMap ?: emptyMap(),&#10;                        success = success,&#10;                        lobbyChannel = json.optString(&quot;lobbyChannel&quot;),&#10;                        error = if (json.has(&quot;error&quot;)) json.optString(&quot;error&quot;) else null&#10;                    )&#10;                    _gameStartedEvent.value = response&#10;                    Log.d(TAG, &quot;Game started event empfangen: $response&quot;)&#10;                }&#10;&#10;                &quot;move&quot; -&gt; {&#10;                    // GameMoveResponse verarbeiten&#10;                    try {&#10;                        val gameMoveResponse = this.json.decodeFromString&lt;GameMoveResponse&gt;(body)&#10;                        _gameMoveUpdates.value = gameMoveResponse&#10;                        Log.d(TAG, &quot;Received move response update: $gameMoveResponse&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error parsing GameMoveResponse: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;possible-moves&quot; -&gt; {&#10;                    val movesArray = json.optJSONArray(&quot;possibleMoves&quot;)&#10;                    val moves = mutableListOf&lt;String&gt;()&#10;                    if (movesArray != null) {&#10;                        for (i in 0 until movesArray.length()) {&#10;                            moves.add(movesArray.getString(i))&#10;                        }&#10;                    }&#10;                    _possibleMoves.value = moves&#10;                    Log.d(TAG, &quot;Possible moves empfangen: $moves&quot;)&#10;                }&#10;&#10;                &quot;promotion&quot; -&gt; {&#10;                    // PromotionRequest verarbeiten&#10;                    try {&#10;                        val promotionRequest = gson.fromJson(body, app.chesspresso.model.game.PromotionRequest::class.java)&#10;                        _promotionRequest.value = promotionRequest&#10;                        Log.d(TAG, &quot;Received promotion request: $promotionRequest&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error parsing PromotionRequest: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;game-end&quot; -&gt; {&#10;                    // Parse GameEndResponse&#10;                    val winner = json.optString(&quot;winner&quot;)&#10;                    val loser = json.optString(&quot;loser&quot;)&#10;                    val draw = json.optBoolean(&quot;draw&quot;)&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val typeStr = json.optString(&quot;type&quot;)&#10;                    val event = GameEndResponse(winner, loser, draw, lobbyId, typeStr)&#10;                    _gameEndEvent.value = event&#10;                    Log.d(TAG, &quot;Received game-end event: $event&quot;)&#10;                }&#10;&#10;                else -&gt; {&#10;                    Log.w(TAG, &quot;Unknown message type received: $type&quot;)&#10;                }&#10;            }&#10;&#10;            // Füge Nachricht zur Liste hinzu&#10;            val currentMessages = _connectionMessages.value.toMutableList()&#10;            currentMessages.add(body)&#10;            if (currentMessages.size &gt; 50) { // Begrenze auf 50 Nachrichten&#10;                currentMessages.removeAt(0)&#10;            }&#10;            _connectionMessages.value = currentMessages&#10;&#10;            // Aktualisiere den Zeitstempel der letzten Nachricht&#10;            _lastMessageTimestamp.value = System.currentTimeMillis()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error parsing message body: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateServerStatus(status: String) {&#10;        val newStatus = when (status.lowercase()) {&#10;            &quot;online&quot; -&gt; ServerStatus.ONLINE&#10;            &quot;offline&quot; -&gt; ServerStatus.OFFLINE&#10;            &quot;busy&quot; -&gt; ServerStatus.BUSY&#10;            &quot;maintenance&quot; -&gt; ServerStatus.MAINTENANCE&#10;            else -&gt; ServerStatus.UNKNOWN&#10;        }&#10;&#10;        _serverStatus.value = newStatus&#10;        Log.d(TAG, &quot;Server status updated to: $newStatus&quot;)&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;        heartbeatJob = null&#10;        Log.d(TAG, &quot;Heartbeat stopped&quot;)&#10;    }&#10;&#10;    private fun scheduleReconnect() {&#10;        if (reconnectJob?.isActive == true) return&#10;&#10;        reconnectJob = CoroutineScope(Dispatchers.IO).launch {&#10;            delay(RECONNECT_DELAY)&#10;            _playerId?.let { id -&gt;&#10;                if (_connectionState.value == ConnectionState.DISCONNECTED) {&#10;                    Log.d(TAG, &quot;Attempting to reconnect...&quot;)&#10;                    _connectionState.value = ConnectionState.RECONNECTING&#10;                    connect(id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        Log.d(TAG, &quot;Disconnecting WebSocket&quot;)&#10;        stopHeartbeat()&#10;        reconnectJob?.cancel()&#10;&#10;        // Sende App-Closing-Nachricht an Server bevor Verbindung getrennt wird&#10;        sendAppClosingMessage()&#10;&#10;        // Kurz warten damit Nachricht gesendet werden kann&#10;        Thread.sleep(100)&#10;&#10;        // Sende DISCONNECT Frame&#10;        val disconnectFrame = buildString {&#10;            append(&quot;DISCONNECT\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(disconnectFrame)&#10;        webSocket?.close(1000, &quot;Client disconnecting&quot;)&#10;        webSocket = null&#10;&#10;        _connectionState.value = ConnectionState.DISCONNECTED&#10;    }&#10;&#10;    private fun sendAppClosingMessage() {&#10;        leaveLobbyOnAppClosing()&#10;        _playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;app-shutdown&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageSync() {&#10;        // Synchrone Version für App-Shutdown&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            sendAppClosingMessage()&#10;            Thread.sleep(200) // Etwas länger warten für synchronen Aufruf&#10;        }&#10;    }&#10;&#10;    fun leaveLobbyOnAppClosing() {&#10;        if (lobbyListener == null) {&#10;            Log.w(TAG, &quot;LobbyListener is not set. Cannot leave lobby on app closing.&quot;)&#10;        } else {&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val currentLobby = lobbyListener!!.currentLobby.value&#10;                Log.d(&quot;StompWebSocket&quot;, &quot;checking if in a lobby: current Lobby: $currentLobby&quot;)&#10;                currentLobby?.let {&#10;                    lobbyListener!!.leaveLobby(it.lobbyId)&#10;                        .onSuccess {&#10;                            Log.d(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Successfully left lobby ${currentLobby.lobbyId} during app closing&quot;&#10;                            )&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            Log.e(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Failed to leave lobby during app closing&quot;,&#10;                                exception&#10;                            )&#10;                        }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageWithReason(reason: String) {&#10;        leaveLobbyOnAppClosing()&#10;        _playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;$reason&quot;,&quot;timestamp&quot;:&quot;${System.currentTimeMillis()}&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id with reason: $reason&quot;)&#10;&#10;            // Kurz warten damit Nachricht gesendet werden kann&#10;            Thread.sleep(150)&#10;        }&#10;    }&#10;&#10;    fun requestOnlinePlayers() {&#10;        _playerId?.let { id -&gt;&#10;            val requestFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/players\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;request&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(requestFrame)&#10;            Log.d(TAG, &quot;Requested online players list&quot;)&#10;        }&#10;    }&#10;&#10;    fun setLobbyMessageHandler(handler: (String) -&gt; Unit) {&#10;        lobbyMessageHandler = handler&#10;    }&#10;&#10;    fun isConnected(): Boolean = _connectionState.value == ConnectionState.CONNECTED&#10;&#10;    // Lobby-spezifische Funktionen&#10;&#10;    fun subscribeToLobby(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu lobby-spezifischen Topics&#10;        val subscribeLobbyFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/lobby/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(subscribeLobbyFrame)&#10;        Log.d(TAG, &quot;Subscribed to lobby updates: $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromLobby() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            Log.d(&#10;                TAG,&#10;                &quot;Sending STOMP unsubscribe frame: ${&#10;                    unsubscribeFrame.replace(&#10;                        MESSAGE_END,&#10;                        &quot;[NULL]&quot;&#10;                    )&#10;                }&quot;&#10;            )&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId = null&#10;    }&#10;&#10;    fun sendLobbyChat(message: String) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val chatFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/chat\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;chat&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;message&quot;:&quot;$message&quot;}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(chatFrame)&#10;                Log.d(TAG, &quot;Sent lobby chat message: $message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPlayerReady(ready: Boolean) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val readyFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/ready\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;player-ready&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;ready&quot;:$ready}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(readyFrame)&#10;                Log.d(TAG, &quot;Sent player ready status: $ready&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Legacy-Methoden für Kompatibilität (werden intern umgeleitet)&#10;    fun joinLobby(lobbyId: String) {&#10;        subscribeToLobby(lobbyId)&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        unsubscribeFromLobby()&#10;    }&#10;&#10;    fun sendLobbyMessage(message: String) {&#10;        sendLobbyChat(message)&#10;    }&#10;&#10;    fun subscribeToGame(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu Spiel-Updates für diese Lobby&#10;        val subscribeFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:game-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/game/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(subscribeFrame)&#10;        Log.d(TAG, &quot;Subscribed to game updates for lobby: $lobbyId&quot;)&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-3\n&quot;)&#10;                append(&quot;destination:/topic/game/$lobbyId/possible-moves\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Subscribed to possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-4\n&quot;)&#10;                append(&quot;destination:/topic/game/$lobbyId/move\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Subscribed to possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;&#10;        // Subscription für Promotion-Topic&#10;        val subscribePromotion = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-promotion\n&quot;)&#10;            append(&quot;destination:/topic/game/$lobbyId/move/promotion\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(subscribePromotion)&#10;        Log.d(TAG, &quot;Subscribed to promotion topic for lobby $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromGame() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:game-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from game updates for lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-3\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Unsubscribed from possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-4\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Subscribed to possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;&#10;        val unsubscribePromotion = buildString {&#10;            append(&quot;UNSUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-promotion\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(unsubscribePromotion)&#10;&#10;        currentLobbyId = null&#10;    }&#10;&#10;    private fun startServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                // Prüfen, ob der letzte Nachrichtenzeitpunkt zu lange her ist&#10;                val currentTime = System.currentTimeMillis()&#10;                val lastMessageTime = _lastMessageTimestamp.value&#10;&#10;                if (lastMessageTime &gt; 0 &amp;&amp; (currentTime - lastMessageTime) &gt; SERVER_STATUS_TIMEOUT) {&#10;                    // Wenn länger als 10 Sekunden keine Nachricht empfangen wurde, Status auf OFFLINE setzen&#10;                    _serverStatus.value = ServerStatus.OFFLINE&#10;                    Log.d(&#10;                        TAG,&#10;                        &quot;Server status set to OFFLINE due to timeout (no message in ${SERVER_STATUS_TIMEOUT / 1000} seconds)&quot;&#10;                    )&#10;                }&#10;&#10;                delay(1000) // Alle Sekunde prüfen&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Server status check started&quot;)&#10;    }&#10;&#10;    private fun stopServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = null&#10;        Log.d(TAG, &quot;Server status check stopped&quot;)&#10;    }&#10;&#10;    fun sendStartGame(gameStartMessage: GameStartMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val messageJson = json.encodeToString(gameStartMessage)&#10;                val startGameFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/game/start\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(messageJson)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(startGameFrame)&#10;                Log.d(TAG, &quot;Sent start game message: $messageJson&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(gameMoveMessage: GameMoveMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val messageJson = json.encodeToString(gameMoveMessage)&#10;                val moveFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/game/move\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(messageJson)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(moveFrame)&#10;                Log.d(TAG, &quot;Sent game move message: $messageJson&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPositionRequest(positionRequestMessage: PositionRequestMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val messageJson = json.encodeToString(positionRequestMessage)&#10;                val positionFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/game/position-request\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(messageJson)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(positionFrame)&#10;                Log.d(TAG, &quot;Sent position request message: $messageJson&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPawnPromotionMessage(message: PawnPromotionMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val messageJson = gson.toJson(message)&#10;            val promotionFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/game/promotion\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(messageJson)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(promotionFrame)&#10;            Log.d(TAG, &quot;Sent pawn promotion message: $messageJson&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendEndGameMessage(gameEndMessage: GameEndMessage) {&#10;        val messageJson = json.encodeToString(GameEndMessage.serializer(), gameEndMessage)&#10;        val resignFrame = buildString {&#10;            append(&quot;SEND\n&quot;)&#10;            append(&quot;destination:/app/game/end\n&quot;)&#10;            append(&quot;content-type:application/json\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(messageJson)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(resignFrame)&#10;        Log.d(TAG, &quot;Sent end message: $messageJson&quot;)&#10;    }&#10;&#10;    fun subscribeToTopic(topic: String, id: String = java.util.UUID.randomUUID().toString()) {&#10;        val subscribeFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-$id\n&quot;)&#10;            append(&quot;destination:$topic\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(subscribeFrame)&#10;        Log.d(TAG, &quot;Subscribed to topic: $topic with id: sub-$id&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.model.game.GameMoveMessage&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.game.GameStartMessage&#10;import app.chesspresso.model.game.PawnPromotionMessage&#10;import app.chesspresso.model.game.PieceInfo&#10;import app.chesspresso.model.game.PositionRequestMessage&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.GameEndMessage&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.service.LobbyListener&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import kotlinx.serialization.encodeToString&#10;import kotlinx.serialization.json.Json&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StompWebSocketService @Inject constructor(&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;StompWebSocket&quot;&#10;        private const val WS_URL = &quot;ws://10.0.2.2:8080/ws&quot;&#10;        private const val HEARTBEAT_INTERVAL = 30000L // 30 Sekunden&#10;        private const val RECONNECT_DELAY = 3000L // 3 Sekunden&#10;    }&#10;&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;    private var reconnectJob: Job? = null&#10;    private var _playerId: String? = null&#10;    val playerId: String?&#10;        get() = _playerId&#10;    private var currentLobbyId: String? = null&#10;&#10;    private var lobbyListener: LobbyListener? = null&#10;&#10;    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;ConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    private val _connectionMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val connectionMessages: StateFlow&lt;List&lt;String&gt;&gt; = _connectionMessages.asStateFlow()&#10;&#10;    // Lobby-spezifische Flows&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;String&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    // Spiel-spezifische Flows&#10;    private val _gameMoveUpdates = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val gameMoveUpdates: StateFlow&lt;GameMoveResponse?&gt; = _gameMoveUpdates.asStateFlow()&#10;&#10;    // Callback für Lobby-Message-Handling&#10;    private var lobbyMessageHandler: ((String) -&gt; Unit)? = null&#10;    val MESSAGE_END = &quot;\u0000&quot;&#10;&#10;    private val json = Json { ignoreUnknownKeys = true }&#10;    private val gson = Gson()&#10;    private val _gameStartedEvent = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val gameStartedEvent: StateFlow&lt;GameStartResponse?&gt; = _gameStartedEvent.asStateFlow()&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    // Promotion-Flow&#10;    private val _promotionRequest = MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; = _promotionRequest.asStateFlow()&#10;&#10;    // Game End Flow&#10;    private val _gameEndEvent = MutableStateFlow&lt;GameEndResponse?&gt;(null)&#10;    val gameEndEvent: StateFlow&lt;GameEndResponse?&gt; = _gameEndEvent&#10;&#10;    enum class ConnectionState {&#10;        DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING&#10;    }&#10;&#10;    enum class ServerStatus {&#10;        OFFLINE, ONLINE, BUSY, MAINTENANCE, UNKNOWN&#10;    }&#10;&#10;    fun setLobbyListener(listener: LobbyListener) {&#10;        this.lobbyListener = listener&#10;    }&#10;&#10;    private val _serverStatus = MutableStateFlow(ServerStatus.UNKNOWN)&#10;    val serverStatus: StateFlow&lt;ServerStatus&gt; = _serverStatus.asStateFlow()&#10;&#10;    private val _lastMessageTimestamp = MutableStateFlow(0L)&#10;    private var serverStatusCheckJob: Job? = null&#10;&#10;    // Timeout für Server-Status-Überprüfung (10 Sekunden)&#10;    private val SERVER_STATUS_TIMEOUT = 10_000L&#10;&#10;    private val webSocketListener = object : WebSocketListener() {&#10;        override fun onOpen(webSocket: WebSocket, response: Response) {&#10;            Log.d(TAG, &quot;WebSocket connection opened&quot;)&#10;            _connectionState.value = ConnectionState.CONNECTED&#10;&#10;            // Sende STOMP CONNECT Frame&#10;            sendStompConnect()&#10;&#10;            // Starte Heartbeat&#10;            startHeartbeat()&#10;&#10;            // Starte Server-Status-Überprüfung&#10;            startServerStatusCheck()&#10;&#10;            // Subscription zu Topics erfolgt erst nach CONNECTED-Antwort vom Server&#10;        }&#10;&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            Log.d(TAG, &quot;Received message: $text&quot;)&#10;            handleStompMessage(text)&#10;        }&#10;&#10;        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;            Log.e(TAG, &quot;WebSocket connection failed: ${t.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;            scheduleReconnect()&#10;        }&#10;&#10;        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;            Log.i(TAG, &quot;WebSocket connection closed: $reason&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;        }&#10;    }&#10;&#10;    suspend fun connect(username: String) {&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected&quot;)&#10;            return&#10;        }&#10;&#10;        _playerId = username&#10;        _connectionState.value = ConnectionState.CONNECTING&#10;&#10;        try {&#10;            // Token synchron abrufen&#10;            val token = tokenStorage.getToken().first()&#10;            Log.d(TAG, &quot;Retrieved token for WebSocket connection: ${token?.take(20)}...&quot;)&#10;&#10;            val client = OkHttpClient.Builder()&#10;                .pingInterval(30, TimeUnit.SECONDS)&#10;                .build()&#10;&#10;            val requestBuilder = Request.Builder().url(WS_URL)&#10;&#10;            // Nur Authorization Header hinzufügen wenn Token verfügbar ist&#10;            token?.let {&#10;                requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $it&quot;)&#10;                Log.d(TAG, &quot;Added Authorization header to WebSocket request&quot;)&#10;            } ?: Log.w(TAG, &quot;No token available for WebSocket connection&quot;)&#10;&#10;            val request = requestBuilder.build()&#10;            webSocket = client.newWebSocket(request, webSocketListener)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to connect: ${e.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;        }&#10;    }&#10;&#10;    private fun sendStompConnect() {&#10;        val connectFrame = buildString {&#10;            append(&quot;CONNECT\n&quot;)&#10;            append(&quot;accept-version:1.0,1.1,2.0\n&quot;)&#10;            append(&quot;heart-beat:5000,5000\n&quot;)&#10;            _playerId?.let { append(&quot;login:$it\n&quot;) }&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(connectFrame)&#10;        Log.d(TAG, &quot;Sent STOMP CONNECT frame&quot;)&#10;    }&#10;&#10;    private fun subscribeToTopics() {&#10;        Log.d(TAG, &quot;Subscribing to topics&quot;)&#10;        _playerId?.let { id -&gt;&#10;            // Subscribe zu persönlichen Nachrichten&#10;            // 200 ms warten&#10;            val subscribeFrame2 = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-2\n&quot;)&#10;                append(&quot;destination:/topic/players\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrame2)&#10;            Log.d(TAG, &quot;Subscribed to topics&quot;)&#10;&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                delay(200)&#10;                val subscribeFrame1 = buildString {&#10;                    append(&quot;SUBSCRIBE\n&quot;)&#10;                    append(&quot;id:sub-1\n&quot;)&#10;                    append(&quot;destination:/user/queue/status\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;                webSocket?.send(subscribeFrame1)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                sendHeartbeat()&#10;                delay(HEARTBEAT_INTERVAL)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Heartbeat started&quot;)&#10;    }&#10;&#10;    private fun sendHeartbeat() {&#10;        _playerId?.let { id -&gt;&#10;            val heartbeatFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/heartbeat\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;heartbeat&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(heartbeatFrame)&#10;            Log.d(TAG, &quot;Sent heartbeat for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleStompMessage(message: String) {&#10;        try {&#10;            // Auf CONNECTED Frame vom Server prüfen&#10;            if (message.startsWith(&quot;CONNECTED&quot;)) {&#10;                Log.d(TAG, &quot;Received STOMP CONNECTED frame from server&quot;)&#10;                // Jetzt erst die Subscriptions starten, wenn der Server die Verbindung bestätigt hat&#10;                subscribeToTopics()&#10;                return&#10;            }&#10;&#10;            if (message.startsWith(&quot;MESSAGE&quot;)) {&#10;                val lines = message.split(&quot;\n&quot;)&#10;                var body = &quot;&quot;&#10;                var isBody = false&#10;&#10;                for (line in lines) {&#10;                    if (isBody) {&#10;                        body += line&#10;                    } else if (line.isEmpty()) {&#10;                        isBody = true&#10;                    }&#10;                }&#10;&#10;                // Entferne Null-Terminator&#10;                body = body.replace(MESSAGE_END, &quot;&quot;)&#10;&#10;                if (body.isNotEmpty()) {&#10;                    handleMessageBody(body)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error handling STOMP message: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleMessageBody(body: String) {&#10;        try {&#10;            val json = JSONObject(body)&#10;            val type = json.optString(&quot;type&quot;)&#10;&#10;            when (type) {&#10;                &quot;status-update&quot; -&gt; {&#10;                    val status = json.optString(&quot;status&quot;)&#10;                    Log.d(TAG, &quot;Status update received: $status&quot;)&#10;&#10;                    // Server-Status verarbeiten&#10;                    updateServerStatus(status)&#10;                }&#10;                &quot;lobby-message&quot; -&gt; {&#10;                    // Lobby-spezifische Nachrichten verarbeiten&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val messageContent = json.optString(&quot;message&quot;)&#10;&#10;                    if (lobbyId == currentLobbyId) {&#10;                        // Nur Nachrichten für den aktuellen Lobby-Kontext weiterleiten&#10;                        _lobbyMessages.value = _lobbyMessages.value + messageContent&#10;                        Log.d(TAG, &quot;Lobby message received: $messageContent&quot;)&#10;                        // Optional: Direktes Handling der Nachricht über den Handler&#10;                        lobbyMessageHandler?.invoke(messageContent)&#10;                    }&#10;                }&#10;&#10;                &quot;gameStarted&quot; -&gt; {&#10;                    val boardMap: Map&lt;String, PieceInfo&gt;? = if (json.isNull(&quot;board&quot;)) {&#10;                        null&#10;                    } else {&#10;                        val boardJson = json.getJSONObject(&quot;board&quot;).toString()&#10;                        val boardType = object : TypeToken&lt;Map&lt;String, PieceInfo&gt;&gt;() {}.type&#10;                        gson.fromJson&lt;Map&lt;String, PieceInfo&gt;&gt;(boardJson, boardType)&#10;                    }&#10;                    val rawSuccess = json.opt(&quot;success&quot;)&#10;                    Log.d(TAG, &quot;[DEBUG] gameStarted: rawSuccess=$rawSuccess, type=${rawSuccess?.javaClass?.name}&quot;)&#10;                    val success = when (rawSuccess) {&#10;                        is Boolean -&gt; rawSuccess&#10;                        is String -&gt; rawSuccess.equals(&quot;true&quot;, ignoreCase = true)&#10;                        is Number -&gt; rawSuccess.toInt() != 0&#10;                        else -&gt; false&#10;                    }&#10;                    // GameTime als Enum direkt aus JSON parsen&#10;                    val gameTimeEnum = try {&#10;                        gson.fromJson(json.get(&quot;gameTime&quot;).toString(), app.chesspresso.model.lobby.GameTime::class.java)&#10;                    } catch (e: Exception) {&#10;                        app.chesspresso.model.lobby.GameTime.SHORT // Fallback auf 5 Minuten&#10;                    }&#10;                    val response = GameStartResponse(&#10;                        lobbyId = json.optString(&quot;lobbyId&quot;),&#10;                        gameTime = gameTimeEnum,&#10;                        whitePlayer = json.optString(&quot;whitePlayer&quot;),&#10;                        blackPlayer = json.optString(&quot;blackPlayer&quot;),&#10;                        board = boardMap ?: emptyMap(),&#10;                        success = success,&#10;                        lobbyChannel = json.optString(&quot;lobbyChannel&quot;),&#10;                        error = if (json.has(&quot;error&quot;)) json.optString(&quot;error&quot;) else null&#10;                    )&#10;                    _gameStartedEvent.value = response&#10;                    Log.d(TAG, &quot;Game started event empfangen: $response&quot;)&#10;                }&#10;&#10;                &quot;move&quot; -&gt; {&#10;                    // GameMoveResponse verarbeiten&#10;                    try {&#10;                        val gameMoveResponse = this.json.decodeFromString&lt;GameMoveResponse&gt;(body)&#10;                        _gameMoveUpdates.value = gameMoveResponse&#10;                        Log.d(TAG, &quot;Received move response update: $gameMoveResponse&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error parsing GameMoveResponse: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;possible-moves&quot; -&gt; {&#10;                    val movesArray = json.optJSONArray(&quot;possibleMoves&quot;)&#10;                    val moves = mutableListOf&lt;String&gt;()&#10;                    if (movesArray != null) {&#10;                        for (i in 0 until movesArray.length()) {&#10;                            moves.add(movesArray.getString(i))&#10;                        }&#10;                    }&#10;                    _possibleMoves.value = moves&#10;                    Log.d(TAG, &quot;Possible moves empfangen: $moves&quot;)&#10;                }&#10;&#10;                &quot;promotion&quot; -&gt; {&#10;                    // PromotionRequest verarbeiten&#10;                    try {&#10;                        val promotionRequest = gson.fromJson(body, app.chesspresso.model.game.PromotionRequest::class.java)&#10;                        _promotionRequest.value = promotionRequest&#10;                        Log.d(TAG, &quot;Received promotion request: $promotionRequest&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;Error parsing PromotionRequest: ${e.message}&quot;)&#10;                    }&#10;                }&#10;&#10;                &quot;game-end&quot; -&gt; {&#10;                    // Parse GameEndResponse&#10;                    val winner = json.optString(&quot;winner&quot;)&#10;                    val loser = json.optString(&quot;loser&quot;)&#10;                    val draw = json.optBoolean(&quot;draw&quot;)&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val typeStr = json.optString(&quot;type&quot;)&#10;                    val event = GameEndResponse(winner, loser, draw, lobbyId, typeStr)&#10;                    _gameEndEvent.value = event&#10;                    Log.d(TAG, &quot;Received game-end event: $event&quot;)&#10;                }&#10;&#10;                else -&gt; {&#10;                    Log.w(TAG, &quot;Unknown message type received: $type&quot;)&#10;                }&#10;            }&#10;&#10;            // Füge Nachricht zur Liste hinzu&#10;            val currentMessages = _connectionMessages.value.toMutableList()&#10;            currentMessages.add(body)&#10;            if (currentMessages.size &gt; 50) { // Begrenze auf 50 Nachrichten&#10;                currentMessages.removeAt(0)&#10;            }&#10;            _connectionMessages.value = currentMessages&#10;&#10;            // Aktualisiere den Zeitstempel der letzten Nachricht&#10;            _lastMessageTimestamp.value = System.currentTimeMillis()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error parsing message body: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun updateServerStatus(status: String) {&#10;        val newStatus = when (status.lowercase()) {&#10;            &quot;online&quot; -&gt; ServerStatus.ONLINE&#10;            &quot;offline&quot; -&gt; ServerStatus.OFFLINE&#10;            &quot;busy&quot; -&gt; ServerStatus.BUSY&#10;            &quot;maintenance&quot; -&gt; ServerStatus.MAINTENANCE&#10;            else -&gt; ServerStatus.UNKNOWN&#10;        }&#10;&#10;        _serverStatus.value = newStatus&#10;        Log.d(TAG, &quot;Server status updated to: $newStatus&quot;)&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;        heartbeatJob = null&#10;        Log.d(TAG, &quot;Heartbeat stopped&quot;)&#10;    }&#10;&#10;    private fun scheduleReconnect() {&#10;        if (reconnectJob?.isActive == true) return&#10;&#10;        reconnectJob = CoroutineScope(Dispatchers.IO).launch {&#10;            delay(RECONNECT_DELAY)&#10;            _playerId?.let { id -&gt;&#10;                if (_connectionState.value == ConnectionState.DISCONNECTED) {&#10;                    Log.d(TAG, &quot;Attempting to reconnect...&quot;)&#10;                    _connectionState.value = ConnectionState.RECONNECTING&#10;                    connect(id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        Log.d(TAG, &quot;Disconnecting WebSocket&quot;)&#10;        stopHeartbeat()&#10;        reconnectJob?.cancel()&#10;&#10;        // Sende App-Closing-Nachricht an Server bevor Verbindung getrennt wird&#10;        sendAppClosingMessage()&#10;&#10;        // Kurz warten damit Nachricht gesendet werden kann&#10;        Thread.sleep(100)&#10;&#10;        // Sende DISCONNECT Frame&#10;        val disconnectFrame = buildString {&#10;            append(&quot;DISCONNECT\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(disconnectFrame)&#10;        webSocket?.close(1000, &quot;Client disconnecting&quot;)&#10;        webSocket = null&#10;&#10;        _connectionState.value = ConnectionState.DISCONNECTED&#10;    }&#10;&#10;    private fun sendAppClosingMessage() {&#10;        leaveLobbyOnAppClosing()&#10;        _playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;app-shutdown&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageSync() {&#10;        // Synchrone Version für App-Shutdown&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            sendAppClosingMessage()&#10;            Thread.sleep(200) // Etwas länger warten für synchronen Aufruf&#10;        }&#10;    }&#10;&#10;    fun leaveLobbyOnAppClosing() {&#10;        if (lobbyListener == null) {&#10;            Log.w(TAG, &quot;LobbyListener is not set. Cannot leave lobby on app closing.&quot;)&#10;        } else {&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val currentLobby = lobbyListener!!.currentLobby.value&#10;                Log.d(&quot;StompWebSocket&quot;, &quot;checking if in a lobby: current Lobby: $currentLobby&quot;)&#10;                currentLobby?.let {&#10;                    lobbyListener!!.leaveLobby(it.lobbyId)&#10;                        .onSuccess {&#10;                            Log.d(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Successfully left lobby ${currentLobby.lobbyId} during app closing&quot;&#10;                            )&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            Log.e(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Failed to leave lobby during app closing&quot;,&#10;                                exception&#10;                            )&#10;                        }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageWithReason(reason: String) {&#10;        leaveLobbyOnAppClosing()&#10;        _playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;$reason&quot;,&quot;timestamp&quot;:&quot;${System.currentTimeMillis()}&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id with reason: $reason&quot;)&#10;&#10;            // Kurz warten damit Nachricht gesendet werden kann&#10;            Thread.sleep(150)&#10;        }&#10;    }&#10;&#10;    fun requestOnlinePlayers() {&#10;        _playerId?.let { id -&gt;&#10;            val requestFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/players\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;request&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(requestFrame)&#10;            Log.d(TAG, &quot;Requested online players list&quot;)&#10;        }&#10;    }&#10;&#10;    fun setLobbyMessageHandler(handler: (String) -&gt; Unit) {&#10;        lobbyMessageHandler = handler&#10;    }&#10;&#10;    fun isConnected(): Boolean = _connectionState.value == ConnectionState.CONNECTED&#10;&#10;    // Lobby-spezifische Funktionen&#10;&#10;    fun subscribeToLobby(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu lobby-spezifischen Topics&#10;        val subscribeLobbyFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/lobby/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(subscribeLobbyFrame)&#10;        Log.d(TAG, &quot;Subscribed to lobby updates: $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromLobby() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            Log.d(&#10;                TAG,&#10;                &quot;Sending STOMP unsubscribe frame: ${&#10;                    unsubscribeFrame.replace(&#10;                        MESSAGE_END,&#10;                        &quot;[NULL]&quot;&#10;                    )&#10;                }&quot;&#10;            )&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId = null&#10;    }&#10;&#10;    fun sendLobbyChat(message: String) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val chatFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/chat\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;chat&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;message&quot;:&quot;$message&quot;}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(chatFrame)&#10;                Log.d(TAG, &quot;Sent lobby chat message: $message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPlayerReady(ready: Boolean) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val readyFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/ready\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;player-ready&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;ready&quot;:$ready}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(readyFrame)&#10;                Log.d(TAG, &quot;Sent player ready status: $ready&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Legacy-Methoden für Kompatibilität (werden intern umgeleitet)&#10;    fun joinLobby(lobbyId: String) {&#10;        subscribeToLobby(lobbyId)&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        unsubscribeFromLobby()&#10;    }&#10;&#10;    fun sendLobbyMessage(message: String) {&#10;        sendLobbyChat(message)&#10;    }&#10;&#10;    fun subscribeToGame(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu Spiel-Updates für diese Lobby&#10;        val subscribeFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:game-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/game/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(subscribeFrame)&#10;        Log.d(TAG, &quot;Subscribed to game updates for lobby: $lobbyId&quot;)&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-3\n&quot;)&#10;                append(&quot;destination:/topic/game/$lobbyId/possible-moves\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Subscribed to possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-4\n&quot;)&#10;                append(&quot;destination:/topic/game/$lobbyId/move\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Subscribed to possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;&#10;        // Subscription für Promotion-Topic&#10;        val subscribePromotion = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-promotion\n&quot;)&#10;            append(&quot;destination:/topic/game/$lobbyId/move/promotion\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(subscribePromotion)&#10;        Log.d(TAG, &quot;Subscribed to promotion topic for lobby $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromGame() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:game-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from game updates for lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-3\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Unsubscribed from possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val subscribeFrameMoves = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-4\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrameMoves)&#10;            Log.d(TAG, &quot;Subscribed to possible-moves for lobby $lobbyId&quot;)&#10;        }&#10;&#10;        val unsubscribePromotion = buildString {&#10;            append(&quot;UNSUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-promotion\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(unsubscribePromotion)&#10;&#10;        currentLobbyId = null&#10;    }&#10;&#10;    private fun startServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                // Prüfen, ob der letzte Nachrichtenzeitpunkt zu lange her ist&#10;                val currentTime = System.currentTimeMillis()&#10;                val lastMessageTime = _lastMessageTimestamp.value&#10;&#10;                if (lastMessageTime &gt; 0 &amp;&amp; (currentTime - lastMessageTime) &gt; SERVER_STATUS_TIMEOUT) {&#10;                    // Wenn länger als 10 Sekunden keine Nachricht empfangen wurde, Status auf OFFLINE setzen&#10;                    _serverStatus.value = ServerStatus.OFFLINE&#10;                    Log.d(&#10;                        TAG,&#10;                        &quot;Server status set to OFFLINE due to timeout (no message in ${SERVER_STATUS_TIMEOUT / 1000} seconds)&quot;&#10;                    )&#10;                }&#10;&#10;                delay(1000) // Alle Sekunde prüfen&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Server status check started&quot;)&#10;    }&#10;&#10;    private fun stopServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = null&#10;        Log.d(TAG, &quot;Server status check stopped&quot;)&#10;    }&#10;&#10;    fun sendStartGame(gameStartMessage: GameStartMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val messageJson = json.encodeToString(gameStartMessage)&#10;                val startGameFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/game/start\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(messageJson)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(startGameFrame)&#10;                Log.d(TAG, &quot;Sent start game message: $messageJson&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(gameMoveMessage: GameMoveMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val messageJson = json.encodeToString(gameMoveMessage)&#10;                val moveFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/game/move\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(messageJson)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(moveFrame)&#10;                Log.d(TAG, &quot;Sent game move message: $messageJson&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPositionRequest(positionRequestMessage: PositionRequestMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            _playerId?.let { id -&gt;&#10;                val messageJson = json.encodeToString(positionRequestMessage)&#10;                val positionFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/game/position-request\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(messageJson)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(positionFrame)&#10;                Log.d(TAG, &quot;Sent position request message: $messageJson&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPawnPromotionMessage(message: PawnPromotionMessage) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val messageJson = gson.toJson(message)&#10;            val promotionFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/game/promotion\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(messageJson)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(promotionFrame)&#10;            Log.d(TAG, &quot;Sent pawn promotion message: $messageJson&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendEndGameMessage(gameEndMessage: GameEndMessage) {&#10;        val messageJson = json.encodeToString(GameEndMessage.serializer(), gameEndMessage)&#10;        val resignFrame = buildString {&#10;            append(&quot;SEND\n&quot;)&#10;            append(&quot;destination:/app/game/end\n&quot;)&#10;            append(&quot;content-type:application/json\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(messageJson)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(resignFrame)&#10;        Log.d(TAG, &quot;Sent end message: $messageJson&quot;)&#10;    }&#10;&#10;    fun subscribeToTopic(topic: String, id: String = java.util.UUID.randomUUID().toString()) {&#10;        val subscribeFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-$id\n&quot;)&#10;            append(&quot;destination:$topic\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;        webSocket?.send(subscribeFrame)&#10;        Log.d(TAG, &quot;Subscribed to topic: $topic with id: sub-$id&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>