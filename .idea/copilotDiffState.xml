<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/service/LobbyService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/service/LobbyService.kt" />
              <option name="originalContent" value="package app.chesspresso.service&#10;&#10;import android.util.Log&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.model.lobby.*&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class LobbyService @Inject constructor(&#10;    private val lobbyApiService: LobbyApiService,&#10;    private val webSocketService: StompWebSocketService,&#10;    private val gson: Gson&#10;) {&#10;    private val _currentLobby = MutableStateFlow&lt;Lobby?&gt;(null)&#10;    val currentLobby: StateFlow&lt;Lobby?&gt; = _currentLobby.asStateFlow()&#10;&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;LobbyMessage&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;LobbyMessage&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    private val _lobbyError = MutableStateFlow&lt;String?&gt;(null)&#10;    val lobbyError: StateFlow&lt;String?&gt; = _lobbyError.asStateFlow()&#10;&#10;    private val _isWaitingForMatch = MutableStateFlow(false)&#10;    val isWaitingForMatch: StateFlow&lt;Boolean&gt; = _isWaitingForMatch.asStateFlow()&#10;&#10;    private val _gameStarted = MutableStateFlow&lt;GameStartMessage?&gt;(null)&#10;    val gameStarted: StateFlow&lt;GameStartMessage?&gt; = _gameStarted.asStateFlow()&#10;&#10;    init {&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#10;            handleWebSocketMessage(message)&#10;        }&#10;    }&#10;&#10;    // Quick Match beitreten&#10;    suspend fun joinQuickMatch(gameTime: GameTime): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinQuickMatch(QuickJoinRequest(gameTime))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyId = response.body()?.lobbyId ?: return Result.failure(Exception(&quot;Keine Lobby-ID erhalten&quot;))&#10;                _isWaitingForMatch.value = true&#10;                &#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyId)&#10;                &#10;                Log.d(&quot;LobbyService&quot;, &quot;Quick Match erfolgreich beigetreten: $lobbyId&quot;)&#10;                Result.success(lobbyId)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Unbekannter Fehler beim Quick Match&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Quick Match beitreten&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby erstellen&#10;    suspend fun createPrivateLobby(): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.createPrivateLobby()&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;                val lobbyCode = response.body()?.lobbyCode ?: return Result.failure(Exception(&quot;Kein Lobby-Code erhalten&quot;))&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Erstellen der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Erstellen der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Private Lobby beitreten&#10;    suspend fun joinPrivateLobby(lobbyCode: String): Result&lt;String&gt; {&#10;        return try {&#10;            val response = lobbyApiService.joinPrivateLobby(JoinPrivateLobbyRequest(lobbyCode))&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#10;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#10;                webSocketService.subscribeToLobby(lobbyCode)&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby beigetreten: $lobbyCode&quot;)&#10;                Result.success(lobbyCode)&#10;            } else {&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Beitreten der Lobby&quot;&#10;                Result.failure(Exception(errorMsg))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Beitreten der Private Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby verlassen&#10;    suspend fun leaveLobby(lobbyId: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            // Zuerst WebSocket-Subscription beenden&#10;            webSocketService.unsubscribeFromLobby()&#10;            &#10;            Log.d(&quot;LobbyService&quot;, &quot;Sende Leave-Request an API: LeaveLobbyRequest(lobbyId=$lobbyId)&quot;)&#10;            val response = lobbyApiService.leaveLobby(LeaveLobbyRequest(lobbyId))&#10;            if (response.isSuccessful) {&#10;                _currentLobby.value = null&#10;                _isWaitingForMatch.value = false&#10;                _lobbyMessages.value = emptyList()&#10;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Lobby verlassen: $lobbyId&quot;)&#10;                Result.success(Unit)&#10;            } else {&#10;                Result.failure(Exception(&quot;Fehler beim Verlassen der Lobby&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verlassen der Lobby&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // Lobby-Info abrufen&#10;    suspend fun getLobbyInfo(lobbyId: String): Result&lt;Lobby&gt; {&#10;        return try {&#10;            val response = lobbyApiService.getLobbyInfo(lobbyId)&#10;            if (response.isSuccessful) {&#10;                val lobbyInfo = response.body() ?: return Result.failure(Exception(&quot;Keine Lobby-Daten erhalten&quot;))&#10;&#10;                // Sichere Behandlung von gameTime - kann null oder &quot;null&quot; sein&#10;                val gameTime = when {&#10;                    lobbyInfo.gameTime == null -&gt; null&#10;                    lobbyInfo.gameTime == &quot;null&quot; -&gt; null&#10;                    lobbyInfo.gameTime.isBlank() -&gt; null&#10;                    else -&gt; try {&#10;                        GameTime.valueOf(lobbyInfo.gameTime)&#10;                    } catch (e: IllegalArgumentException) {&#10;                        Log.w(&quot;LobbyService&quot;, &quot;Unbekannte GameTime: ${lobbyInfo.gameTime}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                val lobby = Lobby(&#10;                    lobbyId = lobbyInfo.lobbyId,&#10;                    lobbyType = LobbyType.valueOf(lobbyInfo.lobbyType),&#10;                    gameTime = gameTime,&#10;                    players = lobbyInfo.players,&#10;                    creator = lobbyInfo.creator,&#10;                    isGameStarted = lobbyInfo.isGameStarted,&#10;                    status = LobbyStatus.valueOf(lobbyInfo.status)&#10;                )&#10;                _currentLobby.value = lobby&#10;                Result.success(lobby)&#10;            } else {&#10;                Result.failure(Exception(&quot;Lobby nicht gefunden&quot;))&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Abrufen der Lobby-Info&quot;, e)&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    // WebSocket-Nachrichten verarbeiten&#10;    fun handleWebSocketMessage(message: String) {&#10;        try {&#10;            Log.d(&quot;LobbyService&quot;, &quot;WebSocket-Nachricht erhalten: $message&quot;)&#10;&#10;            // Parse JSON-Nachricht&#10;            val jsonObject = gson.fromJson(message, Map::class.java)&#10;            val messageType = jsonObject[&quot;type&quot;] as? String&#10;&#10;            when (messageType) {&#10;                &quot;lobby-waiting&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val waitingMessage = jsonObject[&quot;message&quot;] as? String&#10;                    _isWaitingForMatch.value = true&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Warte auf Gegner in Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-error&quot; -&gt; {&#10;                    val error = jsonObject[&quot;error&quot;] as? String ?: &quot;Unbekannter Lobby-Fehler&quot;&#10;                    _lobbyError.value = error&#10;                    _isWaitingForMatch.value = false&#10;                    Log.e(&quot;LobbyService&quot;, &quot;Lobby-Fehler: $error&quot;)&#10;                }&#10;&#10;                &quot;player-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val newPlayerId = jsonObject[&quot;newPlayerId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler beigetreten: $newPlayerId - $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-joined&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val creatorId = jsonObject[&quot;creatorId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status,&#10;                                creator = creatorId ?: currentLobby.creator&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby erfolgreich beigetreten: $message&quot;)&#10;                }&#10;&#10;                &quot;lobby-update&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#10;                    val updateMessage = jsonObject[&quot;message&quot;] as? String&#10;&#10;                    // Aktualisiere die aktuelle Lobby&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#10;                            val updatedLobby = currentLobby.copy(&#10;                                players = players,&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#10;                            )&#10;                            _currentLobby.value = updatedLobby&#10;                        }&#10;                    }&#10;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby-Update: $updateMessage&quot;)&#10;                }&#10;&#10;                &quot;game-start&quot; -&gt; {&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String ?: &quot;&quot;&#10;                    val gameTime = jsonObject[&quot;gameTime&quot;] as? String ?: &quot;&quot;&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#10;                    val lobbyChannel = jsonObject[&quot;lobbyChannel&quot;] as? String ?: &quot;&quot;&#10;&#10;                    val gameStart = GameStartMessage(&#10;                        lobbyId = lobbyId,&#10;                        gameTime = gameTime,&#10;                        whitePlayer = whitePlayer,&#10;                        blackPlayer = blackPlayer,&#10;                        lobbyChannel = lobbyChannel&#10;                    )&#10;&#10;                    _gameStarted.value = gameStart&#10;                    _isWaitingForMatch.value = false&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spiel startet! Lobby: $lobbyId&quot;)&#10;                }&#10;&#10;                &quot;lobby-created&quot; -&gt; {&#10;                    val lobbyCode = jsonObject[&quot;lobbyCode&quot;] as? String&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode - $message&quot;)&#10;                }&#10;&#10;                &quot;PLAYER_READY&quot; -&gt; {&#10;                    val playerId = jsonObject[&quot;playerId&quot;] as? String&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler bereit: $playerId&quot;)&#10;                    // Hier könntest du den Ready-Status in der UI anzeigen&#10;                }&#10;&#10;                &quot;GAME_START&quot; -&gt; {&#10;                    // Alternative Behandlung für direktes GAME_START&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#10;                    val gameTimeObj = jsonObject[&quot;gameTime&quot;]&#10;&#10;                    // Extrahiere gameTime richtig&#10;                    val gameTime = when (gameTimeObj) {&#10;                        is String -&gt; gameTimeObj&#10;                        is Map&lt;*, *&gt; -&gt; gameTimeObj[&quot;name&quot;] as? String ?: &quot;MIDDLE&quot;&#10;                        else -&gt; &quot;MIDDLE&quot;&#10;                    }&#10;&#10;                    val gameStart = GameStartMessage(&#10;                        lobbyId = _currentLobby.value?.lobbyId ?: &quot;&quot;,&#10;                        gameTime = gameTime,&#10;                        whitePlayer = whitePlayer,&#10;                        blackPlayer = blackPlayer,&#10;                        lobbyChannel = &quot;&quot;&#10;                    )&#10;&#10;                    _gameStarted.value = gameStart&#10;                    _isWaitingForMatch.value = false&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Direkter Spielstart erkannt&quot;)&#10;                }&#10;&#10;                else -&gt; {&#10;                    // Versuche Legacy-Format zu parsen&#10;                    when {&#10;                        message.contains(&quot;\&quot;error\&quot;&quot;) -&gt; {&#10;                            val errorMsg = gson.fromJson(message, LobbyErrorMessage::class.java)&#10;                            _lobbyError.value = errorMsg.error&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;                        message.contains(&quot;\&quot;lobbyId\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;message\&quot;&quot;) -&gt; {&#10;                            val waitingMsg = gson.fromJson(message, LobbyWaitingMessage::class.java)&#10;                            _isWaitingForMatch.value = true&#10;                        }&#10;                        message.contains(&quot;\&quot;gameTime\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;whitePlayer\&quot;&quot;) -&gt; {&#10;                            val gameStart = gson.fromJson(message, GameStartMessage::class.java)&#10;                            _gameStarted.value = gameStart&#10;                            _isWaitingForMatch.value = false&#10;                        }&#10;                        else -&gt; {&#10;                            Log.w(&quot;LobbyService&quot;, &quot;Unbekannter Nachrichtentyp: $message&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verarbeiten der WebSocket-Nachricht: $message&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Neue Methode für Lobby-Chat-Nachrichten&#10;    fun sendLobbyMessage(lobbyId: String, content: String) {&#10;        webSocketService.sendLobbyChat(content)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Sende Chat-Nachricht in Lobby $lobbyId: $content&quot;)&#10;    }&#10;&#10;    // Neue Methode für Player-Ready-Status&#10;    fun setPlayerReady(lobbyId: String, ready: Boolean) {&#10;        webSocketService.sendPlayerReady(ready)&#10;        Log.d(&quot;LobbyService&quot;, &quot;Setze Spieler-Status: ${if (ready) &quot;bereit&quot; else &quot;nicht bereit&quot;}&quot;)&#10;    }&#10;&#10;    // Fehler zurücksetzen&#10;    fun clearError() {&#10;        _lobbyError.value = null&#10;    }&#10;&#10;    // Spiel-Start zurücksetzen&#10;    fun clearGameStart() {&#10;        _gameStarted.value = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.service&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import app.chesspresso.api.LobbyApiService&#13;&#10;import app.chesspresso.model.lobby.*&#13;&#10;import app.chesspresso.websocket.StompWebSocketService&#13;&#10;import com.google.gson.Gson&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;@Singleton&#13;&#10;class LobbyService @Inject constructor(&#13;&#10;    private val lobbyApiService: LobbyApiService,&#13;&#10;    private val webSocketService: StompWebSocketService,&#13;&#10;    private val gson: Gson&#13;&#10;) {&#13;&#10;    private val _currentLobby = MutableStateFlow&lt;Lobby?&gt;(null)&#13;&#10;    val currentLobby: StateFlow&lt;Lobby?&gt; = _currentLobby.asStateFlow()&#13;&#10;&#13;&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;LobbyMessage&gt;&gt;(emptyList())&#13;&#10;    val lobbyMessages: StateFlow&lt;List&lt;LobbyMessage&gt;&gt; = _lobbyMessages.asStateFlow()&#13;&#10;&#13;&#10;    private val _lobbyError = MutableStateFlow&lt;String?&gt;(null)&#13;&#10;    val lobbyError: StateFlow&lt;String?&gt; = _lobbyError.asStateFlow()&#13;&#10;&#13;&#10;    private val _isWaitingForMatch = MutableStateFlow(false)&#13;&#10;    val isWaitingForMatch: StateFlow&lt;Boolean&gt; = _isWaitingForMatch.asStateFlow()&#13;&#10;&#13;&#10;    private val _gameStarted = MutableStateFlow&lt;GameStartMessage?&gt;(null)&#13;&#10;    val gameStarted: StateFlow&lt;GameStartMessage?&gt; = _gameStarted.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        webSocketService.setLobbyMessageHandler { message -&gt;&#13;&#10;            handleWebSocketMessage(message)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Quick Match beitreten&#13;&#10;    suspend fun joinQuickMatch(gameTime: GameTime): Result&lt;String&gt; {&#13;&#10;        return try {&#13;&#10;            val response = lobbyApiService.joinQuickMatch(QuickJoinRequest(gameTime))&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;                val lobbyId = response.body()?.lobbyId ?: return Result.failure(Exception(&quot;Keine Lobby-ID erhalten&quot;))&#13;&#10;                _isWaitingForMatch.value = true&#13;&#10;                &#13;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#13;&#10;                webSocketService.subscribeToLobby(lobbyId)&#13;&#10;                &#13;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Quick Match erfolgreich beigetreten: $lobbyId&quot;)&#13;&#10;                Result.success(lobbyId)&#13;&#10;            } else {&#13;&#10;                val errorMsg = response.body()?.error ?: &quot;Unbekannter Fehler beim Quick Match&quot;&#13;&#10;                Result.failure(Exception(errorMsg))&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Quick Match beitreten&quot;, e)&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Private Lobby erstellen&#13;&#10;    suspend fun createPrivateLobby(): Result&lt;String&gt; {&#13;&#10;        return try {&#13;&#10;            val response = lobbyApiService.createPrivateLobby()&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;                val lobbyCode = response.body()?.lobbyCode ?: return Result.failure(Exception(&quot;Kein Lobby-Code erhalten&quot;))&#13;&#10;&#13;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#13;&#10;                webSocketService.subscribeToLobby(lobbyCode)&#13;&#10;&#13;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode&quot;)&#13;&#10;                Result.success(lobbyCode)&#13;&#10;            } else {&#13;&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Erstellen der Lobby&quot;&#13;&#10;                Result.failure(Exception(errorMsg))&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Erstellen der Private Lobby&quot;, e)&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Private Lobby beitreten&#13;&#10;    suspend fun joinPrivateLobby(lobbyCode: String): Result&lt;String&gt; {&#13;&#10;        return try {&#13;&#10;            val response = lobbyApiService.joinPrivateLobby(JoinPrivateLobbyRequest(lobbyCode))&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body()?.success == true) {&#13;&#10;&#13;&#10;                // Nach erfolgreichem REST-Call: WebSocket-Lobby beitreten für Real-time Updates&#13;&#10;                webSocketService.subscribeToLobby(lobbyCode)&#13;&#10;&#13;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Private Lobby beigetreten: $lobbyCode&quot;)&#13;&#10;                Result.success(lobbyCode)&#13;&#10;            } else {&#13;&#10;                val errorMsg = response.body()?.error ?: &quot;Fehler beim Beitreten der Lobby&quot;&#13;&#10;                Result.failure(Exception(errorMsg))&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Beitreten der Private Lobby&quot;, e)&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Lobby verlassen&#13;&#10;    suspend fun leaveLobby(lobbyId: String): Result&lt;Unit&gt; {&#13;&#10;        return try {&#13;&#10;            // Zuerst WebSocket-Subscription beenden&#13;&#10;            webSocketService.unsubscribeFromLobby()&#13;&#10;            &#13;&#10;            Log.d(&quot;LobbyService&quot;, &quot;Sende Leave-Request an API: LeaveLobbyRequest(lobbyId=$lobbyId)&quot;)&#13;&#10;            val response = lobbyApiService.leaveLobby(LeaveLobbyRequest(lobbyId))&#13;&#10;            if (response.isSuccessful) {&#13;&#10;                _currentLobby.value = null&#13;&#10;                _isWaitingForMatch.value = false&#13;&#10;                _lobbyMessages.value = emptyList()&#13;&#10;&#13;&#10;                Log.d(&quot;LobbyService&quot;, &quot;Lobby verlassen: $lobbyId&quot;)&#13;&#10;                Result.success(Unit)&#13;&#10;            } else {&#13;&#10;                Result.failure(Exception(&quot;Fehler beim Verlassen der Lobby&quot;))&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verlassen der Lobby&quot;, e)&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Lobby-Info abrufen&#13;&#10;    suspend fun getLobbyInfo(lobbyId: String): Result&lt;Lobby&gt; {&#13;&#10;        return try {&#13;&#10;            val response = lobbyApiService.getLobbyInfo(lobbyId)&#13;&#10;            if (response.isSuccessful) {&#13;&#10;                val lobbyInfo = response.body() ?: return Result.failure(Exception(&quot;Keine Lobby-Daten erhalten&quot;))&#13;&#10;&#13;&#10;                // Sichere Behandlung von gameTime - kann null oder &quot;null&quot; sein&#13;&#10;                val gameTime = when {&#13;&#10;                    lobbyInfo.gameTime == null -&gt; null&#13;&#10;                    lobbyInfo.gameTime == &quot;null&quot; -&gt; null&#13;&#10;                    lobbyInfo.gameTime.isBlank() -&gt; null&#13;&#10;                    else -&gt; try {&#13;&#10;                        GameTime.valueOf(lobbyInfo.gameTime)&#13;&#10;                    } catch (e: IllegalArgumentException) {&#13;&#10;                        Log.w(&quot;LobbyService&quot;, &quot;Unbekannte GameTime: ${lobbyInfo.gameTime}&quot;)&#13;&#10;                        null&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                val lobby = Lobby(&#13;&#10;                    lobbyId = lobbyInfo.lobbyId,&#13;&#10;                    lobbyType = LobbyType.valueOf(lobbyInfo.lobbyType),&#13;&#10;                    gameTime = gameTime,&#13;&#10;                    players = lobbyInfo.players,&#13;&#10;                    creator = lobbyInfo.creator,&#13;&#10;                    isGameStarted = lobbyInfo.isGameStarted,&#13;&#10;                    status = LobbyStatus.valueOf(lobbyInfo.status)&#13;&#10;                )&#13;&#10;                _currentLobby.value = lobby&#13;&#10;                Result.success(lobby)&#13;&#10;            } else {&#13;&#10;                Result.failure(Exception(&quot;Lobby nicht gefunden&quot;))&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Abrufen der Lobby-Info&quot;, e)&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // WebSocket-Nachrichten verarbeiten&#13;&#10;    fun handleWebSocketMessage(message: String) {&#13;&#10;        try {&#13;&#10;            Log.d(&quot;LobbyService&quot;, &quot;WebSocket-Nachricht erhalten: $message&quot;)&#13;&#10;&#13;&#10;            // Parse JSON-Nachricht&#13;&#10;            val jsonObject = gson.fromJson(message, Map::class.java)&#13;&#10;            val messageType = jsonObject[&quot;type&quot;] as? String&#13;&#10;&#13;&#10;            when (messageType) {&#13;&#10;                &quot;lobby-waiting&quot; -&gt; {&#13;&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#13;&#10;                    val waitingMessage = jsonObject[&quot;message&quot;] as? String&#13;&#10;                    _isWaitingForMatch.value = true&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Warte auf Gegner in Lobby: $lobbyId&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;lobby-error&quot; -&gt; {&#13;&#10;                    val error = jsonObject[&quot;error&quot;] as? String ?: &quot;Unbekannter Lobby-Fehler&quot;&#13;&#10;                    _lobbyError.value = error&#13;&#10;                    _isWaitingForMatch.value = false&#13;&#10;                    Log.e(&quot;LobbyService&quot;, &quot;Lobby-Fehler: $error&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;player-joined&quot; -&gt; {&#13;&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#13;&#10;                    val newPlayerId = jsonObject[&quot;newPlayerId&quot;] as? String&#13;&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#13;&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#13;&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#13;&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#13;&#10;&#13;&#10;                    // Aktualisiere die aktuelle Lobby&#13;&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#13;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#13;&#10;                            val updatedLobby = currentLobby.copy(&#13;&#10;                                players = players,&#13;&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#13;&#10;                            )&#13;&#10;                            _currentLobby.value = updatedLobby&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler beigetreten: $newPlayerId - $message&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;lobby-joined&quot; -&gt; {&#13;&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#13;&#10;                    val creatorId = jsonObject[&quot;creatorId&quot;] as? String&#13;&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#13;&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#13;&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#13;&#10;                    val isLobbyFull = jsonObject[&quot;isLobbyFull&quot;] as? Boolean ?: false&#13;&#10;&#13;&#10;                    // Aktualisiere die aktuelle Lobby&#13;&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#13;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#13;&#10;                            val updatedLobby = currentLobby.copy(&#13;&#10;                                players = players,&#13;&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status,&#13;&#10;                                creator = creatorId ?: currentLobby.creator&#13;&#10;                            )&#13;&#10;                            _currentLobby.value = updatedLobby&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby erfolgreich beigetreten: $message&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;lobby-update&quot; -&gt; {&#13;&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String&#13;&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#13;&#10;                    val status = jsonObject[&quot;status&quot;] as? String&#13;&#10;                    val updateMessage = jsonObject[&quot;message&quot;] as? String&#13;&#10;&#13;&#10;                    // Aktualisiere die aktuelle Lobby&#13;&#10;                    _currentLobby.value?.let { currentLobby -&gt;&#13;&#10;                        if (currentLobby.lobbyId == lobbyId) {&#13;&#10;                            val updatedLobby = currentLobby.copy(&#13;&#10;                                players = players,&#13;&#10;                                status = status?.let { LobbyStatus.valueOf(it) } ?: currentLobby.status&#13;&#10;                            )&#13;&#10;                            _currentLobby.value = updatedLobby&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Lobby-Update: $updateMessage&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;game-start&quot; -&gt; {&#13;&#10;                    val lobbyId = jsonObject[&quot;lobbyId&quot;] as? String ?: &quot;&quot;&#13;&#10;                    val gameTime = jsonObject[&quot;gameTime&quot;] as? String ?: &quot;&quot;&#13;&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#13;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#13;&#10;                    val lobbyChannel = jsonObject[&quot;lobbyChannel&quot;] as? String ?: &quot;&quot;&#13;&#10;&#13;&#10;                    val gameStart = GameStartMessage(&#13;&#10;                        lobbyId = lobbyId,&#13;&#10;                        gameTime = gameTime,&#13;&#10;                        whitePlayer = whitePlayer,&#13;&#10;                        blackPlayer = blackPlayer,&#13;&#10;                        lobbyChannel = lobbyChannel&#13;&#10;                    )&#13;&#10;&#13;&#10;                    _gameStarted.value = gameStart&#13;&#10;                    _isWaitingForMatch.value = false&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spiel startet! Lobby: $lobbyId&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;lobby-created&quot; -&gt; {&#13;&#10;                    val lobbyCode = jsonObject[&quot;lobbyCode&quot;] as? String&#13;&#10;                    val message = jsonObject[&quot;message&quot;] as? String&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Private Lobby erstellt: $lobbyCode - $message&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;PLAYER_READY&quot; -&gt; {&#13;&#10;                    val playerId = jsonObject[&quot;playerId&quot;] as? String&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Spieler bereit: $playerId&quot;)&#13;&#10;                    // Hier könntest du den Ready-Status in der UI anzeigen&#13;&#10;                }&#13;&#10;&#13;&#10;                &quot;GAME_START&quot; -&gt; {&#13;&#10;                    // Alternative Behandlung für direktes GAME_START&#13;&#10;                    val players = jsonObject[&quot;players&quot;] as? List&lt;String&gt; ?: emptyList()&#13;&#10;                    val whitePlayer = jsonObject[&quot;whitePlayer&quot;] as? String ?: &quot;&quot;&#13;&#10;                    val blackPlayer = jsonObject[&quot;blackPlayer&quot;] as? String ?: &quot;&quot;&#13;&#10;                    val gameTimeObj = jsonObject[&quot;gameTime&quot;]&#13;&#10;&#13;&#10;                    // Extrahiere gameTime richtig&#13;&#10;                    val gameTime = when (gameTimeObj) {&#13;&#10;                        is String -&gt; gameTimeObj&#13;&#10;                        is Map&lt;*, *&gt; -&gt; gameTimeObj[&quot;name&quot;] as? String ?: &quot;MIDDLE&quot;&#13;&#10;                        else -&gt; &quot;MIDDLE&quot;&#13;&#10;                    }&#13;&#10;&#13;&#10;                    val gameStart = GameStartMessage(&#13;&#10;                        lobbyId = _currentLobby.value?.lobbyId ?: &quot;&quot;,&#13;&#10;                        gameTime = gameTime,&#13;&#10;                        whitePlayer = whitePlayer,&#13;&#10;                        blackPlayer = blackPlayer,&#13;&#10;                        lobbyChannel = &quot;&quot;&#13;&#10;                    )&#13;&#10;&#13;&#10;                    _gameStarted.value = gameStart&#13;&#10;                    _isWaitingForMatch.value = false&#13;&#10;                    Log.d(&quot;LobbyService&quot;, &quot;Direkter Spielstart erkannt&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                else -&gt; {&#13;&#10;                    // Versuche Legacy-Format zu parsen&#13;&#10;                    when {&#13;&#10;                        message.contains(&quot;\&quot;error\&quot;&quot;) -&gt; {&#13;&#10;                            val errorMsg = gson.fromJson(message, LobbyErrorMessage::class.java)&#13;&#10;                            _lobbyError.value = errorMsg.error&#13;&#10;                            _isWaitingForMatch.value = false&#13;&#10;                        }&#13;&#10;                        message.contains(&quot;\&quot;lobbyId\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;message\&quot;&quot;) -&gt; {&#13;&#10;                            val waitingMsg = gson.fromJson(message, LobbyWaitingMessage::class.java)&#13;&#10;                            _isWaitingForMatch.value = true&#13;&#10;                        }&#13;&#10;                        message.contains(&quot;\&quot;gameTime\&quot;&quot;) &amp;&amp; message.contains(&quot;\&quot;whitePlayer\&quot;&quot;) -&gt; {&#13;&#10;                            val gameStart = gson.fromJson(message, GameStartMessage::class.java)&#13;&#10;                            _gameStarted.value = gameStart&#13;&#10;                            _isWaitingForMatch.value = false&#13;&#10;                        }&#13;&#10;                        else -&gt; {&#13;&#10;                            Log.w(&quot;LobbyService&quot;, &quot;Unbekannter Nachrichtentyp: $message&quot;)&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;LobbyService&quot;, &quot;Fehler beim Verarbeiten der WebSocket-Nachricht: $message&quot;, e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Neue Methode für Lobby-Chat-Nachrichten&#13;&#10;    fun sendLobbyMessage(lobbyId: String, content: String) {&#13;&#10;        webSocketService.sendLobbyChat(content)&#13;&#10;        Log.d(&quot;LobbyService&quot;, &quot;Sende Chat-Nachricht in Lobby $lobbyId: $content&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    // Neue Methode für Player-Ready-Status&#13;&#10;    fun setPlayerReady(lobbyId: String, ready: Boolean) {&#13;&#10;        webSocketService.sendPlayerReady(ready)&#13;&#10;        Log.d(&quot;LobbyService&quot;, &quot;Setze Spieler-Status: ${if (ready) &quot;bereit&quot; else &quot;nicht bereit&quot;}&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    // Fehler zurücksetzen&#13;&#10;    fun clearError() {&#13;&#10;        _lobbyError.value = null&#13;&#10;    }&#13;&#10;&#13;&#10;    // Spiel-Start zurücksetzen&#13;&#10;    fun clearGameStart() {&#13;&#10;        _gameStarted.value = null&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/PrivateLobbyViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/PrivateLobbyViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.lobby.ConfigureLobbyMessage&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.model.lobby.Lobby&#10;import app.chesspresso.service.LobbyService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class PrivateLobbyViewModel @Inject constructor(&#10;    private val lobbyService: LobbyService&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(PrivateLobbyUiState())&#10;    val uiState: StateFlow&lt;PrivateLobbyUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _navigationEvent = MutableStateFlow&lt;String?&gt;(null)&#10;    val navigationEvent: StateFlow&lt;String?&gt; = _navigationEvent.asStateFlow()&#10;&#10;    val currentLobby = lobbyService.currentLobby&#10;    val lobbyError = lobbyService.lobbyError&#10;    val gameStarted = lobbyService.gameStarted&#10;&#10;    fun createPrivateLobby() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            lobbyService.createPrivateLobby()&#10;                .onSuccess { lobbyCode -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        createdLobbyCode = lobbyCode,&#10;                        isLobbyCreated = true&#10;                    )&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun joinPrivateLobby(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            lobbyService.joinPrivateLobby(lobbyCode)&#10;                .onSuccess { code -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        joinedLobbyCode = code,&#10;                        isLobbyJoined = true&#10;                    )&#10;                    // Lobby-Info laden&#10;                    loadLobbyInfo(code)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun updateJoinCode(code: String) {&#10;        _uiState.value = _uiState.value.copy(joinCode = code.uppercase())&#10;    }&#10;&#10;    private fun loadLobbyInfo(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            lobbyService.getLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        viewModelScope.launch {&#10;            val lobbyCode = _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;Verlasse Lobby: $lobbyCode&quot;)&#10;            lobbyCode?.let { code -&gt;&#10;                lobbyService.leaveLobby(code)&#10;                resetState()&#10;                _navigationEvent.value = &quot;home&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        lobbyService.clearError()&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    fun clearGameStart() {&#10;        lobbyService.clearGameStart()&#10;    }&#10;&#10;    private fun resetState() {&#10;        _uiState.value = PrivateLobbyUiState()&#10;    }&#10;&#10;    fun configureAndStartGame(&#10;        lobbyCode: String,&#10;        gameTime: GameTime,&#10;        whitePlayer: String? = null,&#10;        blackPlayer: String? = null,&#10;        randomColors: Boolean = false&#10;    ) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;&#10;            val configMessage = ConfigureLobbyMessage(&#10;                lobbyCode = lobbyCode,&#10;                gameTime = gameTime,&#10;                whitePlayer = whitePlayer,&#10;                blackPlayer = blackPlayer,&#10;                randomColors = randomColors&#10;            )&#10;&#10;            // Für jetzt loggen wir die Konfiguration&#10;            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;Konfiguriere Spiel: $configMessage&quot;)&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = false)&#10;        }&#10;    }&#10;&#10;    fun refreshLobbyInfo(lobbyCode: String? = null) {&#10;        viewModelScope.launch {&#10;            val codeToUse = lobbyCode ?: _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            codeToUse?.let { code -&gt;&#10;                lobbyService.getLobbyInfo(code)&#10;                    .onSuccess { lobby -&gt;&#10;                        // Stelle sicher, dass der Lobby-Code im uiState gespeichert ist&#10;                        if (_uiState.value.createdLobbyCode == null &amp;&amp; _uiState.value.joinedLobbyCode == null) {&#10;                            _uiState.value = _uiState.value.copy(&#10;                                joinedLobbyCode = code&#10;                            )&#10;                            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;LobbyCode im uiState aktualisiert: $code&quot;)&#10;                        }&#10;                    }&#10;                    .onFailure { exception -&gt;&#10;                        Log.e(&quot;PrivateLobbyViewModel&quot;, &quot;Fehler beim Laden der Lobby-Info&quot;, exception)&#10;                    }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setReady(lobbyId: String, ready: Boolean) {&#10;        viewModelScope.launch {&#10;            lobbyService.setPlayerReady(lobbyId, ready)&#10;        }&#10;    }&#10;&#10;    fun onNavigated() {&#10;        _navigationEvent.value = null&#10;    }&#10;}&#10;&#10;data class PrivateLobbyUiState(&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val joinCode: String = &quot;&quot;,&#10;    val createdLobbyCode: String? = null,&#10;    val joinedLobbyCode: String? = null,&#10;    val isLobbyCreated: Boolean = false,&#10;    val isLobbyJoined: Boolean = false&#10;)&#10;" />
              <option name="updatedContent" value="package app.chesspresso.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.lobby.ConfigureLobbyMessage&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.model.lobby.Lobby&#10;import app.chesspresso.service.LobbyService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class PrivateLobbyViewModel @Inject constructor(&#10;    private val lobbyService: LobbyService&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(PrivateLobbyUiState())&#10;    val uiState: StateFlow&lt;PrivateLobbyUiState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _navigationEvent = MutableStateFlow&lt;String?&gt;(null)&#10;    val navigationEvent: StateFlow&lt;String?&gt; = _navigationEvent.asStateFlow()&#10;&#10;    val currentLobby = lobbyService.currentLobby&#10;    val lobbyError = lobbyService.lobbyError&#10;    val gameStarted = lobbyService.gameStarted&#10;&#10;    fun createPrivateLobby() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            lobbyService.createPrivateLobby()&#10;                .onSuccess { lobbyCode -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        createdLobbyCode = lobbyCode,&#10;                        isLobbyCreated = true&#10;                    )&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun joinPrivateLobby(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;            lobbyService.joinPrivateLobby(lobbyCode)&#10;                .onSuccess { code -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        joinedLobbyCode = code,&#10;                        isLobbyJoined = true&#10;                    )&#10;                    // Lobby-Info laden&#10;                    loadLobbyInfo(code)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isLoading = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun updateJoinCode(code: String) {&#10;        _uiState.value = _uiState.value.copy(joinCode = code.uppercase())&#10;    }&#10;&#10;    private fun loadLobbyInfo(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            lobbyService.getLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        viewModelScope.launch {&#10;            val lobbyCode = _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;Verlasse Lobby: $lobbyCode&quot;)&#10;            lobbyCode?.let { code -&gt;&#10;                lobbyService.leaveLobby(code)&#10;                resetState()&#10;                _navigationEvent.value = &quot;home&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        lobbyService.clearError()&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    fun clearGameStart() {&#10;        lobbyService.clearGameStart()&#10;    }&#10;&#10;    private fun resetState() {&#10;        _uiState.value = PrivateLobbyUiState()&#10;    }&#10;&#10;    fun configureAndStartGame(&#10;        lobbyCode: String,&#10;        gameTime: GameTime,&#10;        whitePlayer: String? = null,&#10;        blackPlayer: String? = null,&#10;        randomColors: Boolean = false&#10;    ) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isLoading = true, error = null)&#10;&#10;&#10;            val configMessage = ConfigureLobbyMessage(&#10;                lobbyCode = lobbyCode,&#10;                gameTime = gameTime,&#10;                whitePlayer = whitePlayer,&#10;                blackPlayer = blackPlayer,&#10;                randomColors = randomColors&#10;            )&#10;&#10;            // Für jetzt loggen wir die Konfiguration&#10;            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;Konfiguriere Spiel: $configMessage&quot;)&#10;&#10;            _uiState.value = _uiState.value.copy(isLoading = false)&#10;        }&#10;    }&#10;&#10;    fun refreshLobbyInfo(lobbyCode: String? = null) {&#10;        viewModelScope.launch {&#10;            val codeToUse = lobbyCode ?: _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            codeToUse?.let { code -&gt;&#10;                lobbyService.getLobbyInfo(code)&#10;                    .onSuccess { lobby -&gt;&#10;                        // Stelle sicher, dass der Lobby-Code im uiState gespeichert ist&#10;                        if (_uiState.value.createdLobbyCode == null &amp;&amp; _uiState.value.joinedLobbyCode == null) {&#10;                            _uiState.value = _uiState.value.copy(&#10;                                joinedLobbyCode = code&#10;                            )&#10;                            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;LobbyCode im uiState aktualisiert: $code&quot;)&#10;                        }&#10;                    }&#10;                    .onFailure { exception -&gt;&#10;                        Log.e(&quot;PrivateLobbyViewModel&quot;, &quot;Fehler beim Laden der Lobby-Info&quot;, exception)&#10;                    }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setReady(lobbyId: String, ready: Boolean) {&#10;        viewModelScope.launch {&#10;            lobbyService.setPlayerReady(lobbyId, ready)&#10;        }&#10;    }&#10;&#10;    fun onNavigated() {&#10;        _navigationEvent.value = null&#10;    }&#10;}&#10;&#10;data class PrivateLobbyUiState(&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null,&#10;    val joinCode: String = &quot;&quot;,&#10;    val createdLobbyCode: String? = null,&#10;    val joinedLobbyCode: String? = null,&#10;    val isLobbyCreated: Boolean = false,&#10;    val isLobbyJoined: Boolean = false&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>