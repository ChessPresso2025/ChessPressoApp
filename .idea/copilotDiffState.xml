<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/model/game/GameApiModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/model/game/GameApiModels.kt" />
              <option name="originalContent" value="package app.chesspresso.model.game&#10;&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.SpecialMove&#10;import app.chesspresso.model.TeamColor&#10;import com.google.gson.annotations.SerializedName&#10;import kotlinx.serialization.Serializable&#10;import kotlinx.serialization.SerialName&#10;&#10;//Messages&#10;@Serializable&#10;data class GameStartMessage(&#10;    val lobbyId: String,&#10;    val gameTime: String,&#10;    val whitePlayer: String?,&#10;    val blackPlayer: String?,&#10;    val randomPlayers: Boolean&#10;)&#10;&#10;@Serializable&#10;data class GameMoveMessage(&#10;    val from: String,&#10;    val to: String,&#10;    val teamColor: TeamColor,&#10;    val lobbyId: String,&#10;    val promotedPiece: PieceType? = null // Optionales Feld für Umwandlung&#10;)&#10;&#10;@Serializable&#10;data class PositionRequestMessage(&#10;    val lobbyId: String,&#10;    val position: String&#10;)&#10;&#10;data class PawnPromotionMessage(&#10;    val lobbyId: String,&#10;    val position: String,&#10;    val newPiece: PieceType&#10;)&#10;&#10;&#10;&#10;//Responses&#10;&#10;@Serializable&#10;data class GameMoveResponse(&#10;    val lobbyId: String,&#10;    @SerialName(&quot;activeTeam&quot;)&#10;    val nextPlayer: TeamColor,&#10;    val board: Map&lt;String, PieceInfo&gt;,&#10;    val isCheck: String,&#10;    val move: MoveInfo&#10;)&#10;@Serializable&#10;data class MoveInfo(&#10;    val start: String,&#10;    val end: String,&#10;    val piece: PieceType,&#10;    @SerialName(&quot;spezialMove&quot;)&#10;    val specialMove: SpecialMove? = null,&#10;    val captured: CapturedInfo? = null&#10;)&#10;@Serializable&#10;data class PromotionRequest(&#10;    val position: String,&#10;    val from: String, // Start-Position für die Umwandlung&#10;    val activeTeam: TeamColor&#10;)&#10;@Serializable&#10;data class CapturedInfo(&#10;    val type: PieceType?,&#10;    @SerialName(&quot;colour&quot;)&#10;    val color: TeamColor?,&#10;    val position: String?&#10;)&#10;@Serializable&#10;data class PieceInfo(&#10;    val type: PieceType,&#10;    @SerializedName(&quot;colour&quot;)&#10;    val color: TeamColor&#10;)&#10;&#10;data class PossibleMovesResponse(&#10;    @SerializedName(&quot;possible_moves&quot;)&#10;    val possibleMoves: List&lt;String&gt; // Liste der möglichen Zielfelder&#10;)&#10;" />
              <option name="updatedContent" value="package app.chesspresso.model.game&#10;&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.SpecialMove&#10;import app.chesspresso.model.TeamColor&#10;import com.google.gson.annotations.SerializedName&#10;import kotlinx.serialization.Serializable&#10;import kotlinx.serialization.SerialName&#10;&#10;//Messages&#10;@Serializable&#10;data class GameStartMessage(&#10;    val lobbyId: String,&#10;    val gameTime: String,&#10;    val whitePlayer: String?,&#10;    val blackPlayer: String?,&#10;    val randomPlayers: Boolean&#10;)&#10;&#10;@Serializable&#10;data class GameMoveMessage(&#10;    val from: String,&#10;    val to: String,&#10;    val teamColor: TeamColor,&#10;    val lobbyId: String,&#10;    val promotedPiece: PieceType? = null // Optionales Feld für Umwandlung&#10;)&#10;&#10;@Serializable&#10;data class PositionRequestMessage(&#10;    val lobbyId: String,&#10;    val position: String&#10;)&#10;&#10;data class PawnPromotionMessage(&#10;    val lobbyId: String,&#10;    val position: String,&#10;    val newPiece: PieceType&#10;)&#10;&#10;&#10;&#10;//Responses&#10;&#10;@Serializable&#10;data class GameMoveResponse(&#10;    val lobbyId: String,&#10;    @SerialName(&quot;activeTeam&quot;)&#10;    val nextPlayer: TeamColor,&#10;    val board: Map&lt;String, PieceInfo&gt;,&#10;    val isCheck: String,&#10;    val move: MoveInfo&#10;)&#10;@Serializable&#10;data class MoveInfo(&#10;    val start: String,&#10;    val end: String,&#10;    val piece: PieceType,&#10;    @SerialName(&quot;spezialMove&quot;)&#10;    val specialMove: SpecialMove? = null,&#10;    val captured: CapturedInfo? = null&#10;)&#10;@Serializable&#10;data class PromotionRequest(&#10;    val position: String,&#10;    val from: String, // Start-Position für die Umwandlung&#10;    val activeTeam: TeamColor&#10;)&#10;@Serializable&#10;data class CapturedInfo(&#10;    val type: PieceType?,&#10;    @SerialName(&quot;colour&quot;)&#10;    val color: TeamColor?,&#10;    val position: String?&#10;)&#10;@Serializable&#10;data class PieceInfo(&#10;    val type: PieceType,&#10;    @SerializedName(&quot;colour&quot;)&#10;    val color: TeamColor&#10;)&#10;&#10;data class PossibleMovesResponse(&#10;    @SerializedName(&quot;possible_moves&quot;)&#10;    val possibleMoves: List&lt;String&gt; // Liste der möglichen Zielfelder&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.game.PawnPromotionMessage&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChessGameViewModel @Inject constructor(&#10;    private val webSocketService: StompWebSocketService&#10;) : ViewModel() {&#10;&#10;    private val _currentGameState = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val currentGameState: StateFlow&lt;GameMoveResponse?&gt; = _currentGameState.asStateFlow()&#10;&#10;    private val _initialGameData = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val initialGameData: StateFlow&lt;GameStartResponse?&gt; = _initialGameData.asStateFlow()&#10;&#10;    private val _currentBoard = MutableStateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyMap())&#10;    val currentBoard: StateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt; = _currentBoard.asStateFlow()&#10;&#10;    private val _currentPlayer = MutableStateFlow&lt;app.chesspresso.model.TeamColor?&gt;(null)&#10;    val currentPlayer: StateFlow&lt;app.chesspresso.model.TeamColor?&gt; = _currentPlayer.asStateFlow()&#10;&#10;    private val _whiteTime = MutableStateFlow(0)&#10;    val whiteTime: StateFlow&lt;Int&gt; = _whiteTime.asStateFlow()&#10;    private val _blackTime = MutableStateFlow(0)&#10;    val blackTime: StateFlow&lt;Int&gt; = _blackTime.asStateFlow()&#10;&#10;    private val _myColor = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val myColor: StateFlow&lt;TeamColor?&gt; = _myColor.asStateFlow()&#10;&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    private val _capturedWhitePieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedWhitePieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedWhitePieces.asStateFlow()&#10;    private val _capturedBlackPieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedBlackPieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedBlackPieces.asStateFlow()&#10;    private val _promotionRequest = MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; = _promotionRequest.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var lastActivePlayer: TeamColor? = null&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            webSocketService.gameStartedEvent.collect { event -&gt;&#10;                event?.let { initializeGame(it) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.possibleMoves.collect { moves -&gt;&#10;                _possibleMoves.value = moves&#10;            }&#10;        }&#10;        // GameMoveResponse-Listener nur einmalig im init-Block registrieren!&#10;        viewModelScope.launch {&#10;            webSocketService.gameMoveUpdates.collect { gameMoveResponse -&gt;&#10;                gameMoveResponse?.let { response -&gt;&#10;                    val captured = response.move.captured&#10;                    if (captured != null &amp;&amp; captured.type != null &amp;&amp; captured.color != null) {&#10;                        val capturedPiece = app.chesspresso.model.game.PieceInfo(&#10;                            type = captured.type,&#10;                            color = captured.color&#10;                        )&#10;                        when (captured.color) {&#10;                            TeamColor.WHITE -&gt; _capturedWhitePieces.value = _capturedWhitePieces.value + capturedPiece&#10;                            TeamColor.BLACK -&gt; _capturedBlackPieces.value = _capturedBlackPieces.value + capturedPiece&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                    val newBoard = response.board&#10;                    _currentGameState.value = response&#10;                    _currentBoard.value = newBoard&#10;                    _possibleMoves.value = emptyList()&#10;                    if (response.nextPlayer != lastActivePlayer) {&#10;                        startTimer(response.nextPlayer)&#10;                        lastActivePlayer = response.nextPlayer&#10;                    }&#10;                    _currentPlayer.value = response.nextPlayer&#10;                    // Promotion-UI ausblenden, sobald ein Zug vom Server kommt&#10;                    _promotionRequest.value = null&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.promotionRequest.collect { request -&gt;&#10;                _promotionRequest.value = request&#10;            }&#10;        }&#10;    }&#10;&#10;    fun initializeGame(gameStartResponse: GameStartResponse) {&#10;        viewModelScope.launch {&#10;            // Warte, bis playerId gesetzt ist&#10;            var myId = webSocketService.playerId&#10;            var retry = 0&#10;            while (myId == null &amp;&amp; retry &lt; 50) { // max. 5 Sekunden warten&#10;                delay(100)&#10;                myId = webSocketService.playerId&#10;                retry++&#10;            }&#10;            if (myId == null) {&#10;                // Fehlerfall: ID konnte nicht ermittelt werden&#10;                android.util.Log.e(&quot;ChessGameViewModel&quot;, &quot;playerId ist nach 5 Sekunden immer noch null!&quot;)&#10;            }&#10;            _currentGameState.value = null&#10;            _initialGameData.value = gameStartResponse&#10;            _currentBoard.value = gameStartResponse.board&#10;            _currentPlayer.value = TeamColor.WHITE // Weiß beginnt immer&#10;&#10;            // Eigene Farbe bestimmen&#10;            android.util.Log.d(&quot;ChessGameViewModel&quot;, &quot;myId: $myId, whitePlayer: ${gameStartResponse.whitePlayer}, blackPlayer: ${gameStartResponse.blackPlayer}&quot;)&#10;            _myColor.value = when (myId) {&#10;                gameStartResponse.whitePlayer -&gt; TeamColor.WHITE&#10;                gameStartResponse.blackPlayer -&gt; TeamColor.BLACK&#10;                else -&gt; null&#10;            }&#10;&#10;            // Zeit direkt aus gameTime (jetzt Int in Sekunden)&#10;            _whiteTime.value = gameStartResponse.gameTime.seconds&#10;            _blackTime.value = gameStartResponse.gameTime.seconds&#10;            lastActivePlayer = TeamColor.WHITE&#10;            startTimer(TeamColor.WHITE)&#10;&#10;            // Subscribe zu Spiel-Updates für diese Lobby&#10;            webSocketService.subscribeToGame(gameStartResponse.lobbyId)&#10;        }&#10;    }&#10;&#10;    private fun startTimer(activePlayer: TeamColor) {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            while (true) {&#10;                delay(1000)&#10;                if (activePlayer == TeamColor.WHITE) {&#10;                    if (_whiteTime.value &gt; 0) _whiteTime.value = _whiteTime.value - 1&#10;                } else {&#10;                    if (_blackTime.value &gt; 0) _blackTime.value = _blackTime.value - 1&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPositionRequest(lobbyId: String, position: String) {&#10;        viewModelScope.launch {&#10;            val message = app.chesspresso.model.game.PositionRequestMessage(lobbyId, position)&#10;            webSocketService.sendPositionRequest(message)&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(lobbyId: String, from: String, to: String, teamColor: TeamColor, promotedPiece: PieceType? = null) {&#10;        val message = app.chesspresso.model.game.GameMoveMessage(&#10;            lobbyId = lobbyId,&#10;            from = from,&#10;            to = to,&#10;            teamColor = teamColor,&#10;            promotedPiece = promotedPiece&#10;        )&#10;        webSocketService.sendGameMoveMessage(message)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        webSocketService.unsubscribeFromGame()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.game.PawnPromotionMessage&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChessGameViewModel @Inject constructor(&#10;    private val webSocketService: StompWebSocketService&#10;) : ViewModel() {&#10;&#10;    private val _currentGameState = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val currentGameState: StateFlow&lt;GameMoveResponse?&gt; = _currentGameState.asStateFlow()&#10;&#10;    private val _initialGameData = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val initialGameData: StateFlow&lt;GameStartResponse?&gt; = _initialGameData.asStateFlow()&#10;&#10;    private val _currentBoard = MutableStateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyMap())&#10;    val currentBoard: StateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt; = _currentBoard.asStateFlow()&#10;&#10;    private val _currentPlayer = MutableStateFlow&lt;app.chesspresso.model.TeamColor?&gt;(null)&#10;    val currentPlayer: StateFlow&lt;app.chesspresso.model.TeamColor?&gt; = _currentPlayer.asStateFlow()&#10;&#10;    private val _whiteTime = MutableStateFlow(0)&#10;    val whiteTime: StateFlow&lt;Int&gt; = _whiteTime.asStateFlow()&#10;    private val _blackTime = MutableStateFlow(0)&#10;    val blackTime: StateFlow&lt;Int&gt; = _blackTime.asStateFlow()&#10;&#10;    private val _myColor = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val myColor: StateFlow&lt;TeamColor?&gt; = _myColor.asStateFlow()&#10;&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    private val _capturedWhitePieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedWhitePieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedWhitePieces.asStateFlow()&#10;    private val _capturedBlackPieces = MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedBlackPieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; = _capturedBlackPieces.asStateFlow()&#10;    private val _promotionRequest = MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; = _promotionRequest.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var lastActivePlayer: TeamColor? = null&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            webSocketService.gameStartedEvent.collect { event -&gt;&#10;                event?.let { initializeGame(it) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.possibleMoves.collect { moves -&gt;&#10;                _possibleMoves.value = moves&#10;            }&#10;        }&#10;        // GameMoveResponse-Listener nur einmalig im init-Block registrieren!&#10;        viewModelScope.launch {&#10;            webSocketService.gameMoveUpdates.collect { gameMoveResponse -&gt;&#10;                gameMoveResponse?.let { response -&gt;&#10;                    val captured = response.move.captured&#10;                    if (captured != null &amp;&amp; captured.type != null &amp;&amp; captured.color != null) {&#10;                        val capturedPiece = app.chesspresso.model.game.PieceInfo(&#10;                            type = captured.type,&#10;                            color = captured.color&#10;                        )&#10;                        when (captured.color) {&#10;                            TeamColor.WHITE -&gt; _capturedWhitePieces.value = _capturedWhitePieces.value + capturedPiece&#10;                            TeamColor.BLACK -&gt; _capturedBlackPieces.value = _capturedBlackPieces.value + capturedPiece&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                    val newBoard = response.board&#10;                    _currentGameState.value = response&#10;                    _currentBoard.value = newBoard&#10;                    _possibleMoves.value = emptyList()&#10;                    if (response.nextPlayer != lastActivePlayer) {&#10;                        startTimer(response.nextPlayer)&#10;                        lastActivePlayer = response.nextPlayer&#10;                    }&#10;                    _currentPlayer.value = response.nextPlayer&#10;                    // Promotion-UI ausblenden, sobald ein Zug vom Server kommt&#10;                    _promotionRequest.value = null&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.promotionRequest.collect { request -&gt;&#10;                _promotionRequest.value = request&#10;            }&#10;        }&#10;    }&#10;&#10;    fun initializeGame(gameStartResponse: GameStartResponse) {&#10;        viewModelScope.launch {&#10;            // Warte, bis playerId gesetzt ist&#10;            var myId = webSocketService.playerId&#10;            var retry = 0&#10;            while (myId == null &amp;&amp; retry &lt; 50) { // max. 5 Sekunden warten&#10;                delay(100)&#10;                myId = webSocketService.playerId&#10;                retry++&#10;            }&#10;            if (myId == null) {&#10;                // Fehlerfall: ID konnte nicht ermittelt werden&#10;                android.util.Log.e(&quot;ChessGameViewModel&quot;, &quot;playerId ist nach 5 Sekunden immer noch null!&quot;)&#10;            }&#10;            _currentGameState.value = null&#10;            _initialGameData.value = gameStartResponse&#10;            _currentBoard.value = gameStartResponse.board&#10;            _currentPlayer.value = TeamColor.WHITE // Weiß beginnt immer&#10;&#10;            // Eigene Farbe bestimmen&#10;            android.util.Log.d(&quot;ChessGameViewModel&quot;, &quot;myId: $myId, whitePlayer: ${gameStartResponse.whitePlayer}, blackPlayer: ${gameStartResponse.blackPlayer}&quot;)&#10;            _myColor.value = when (myId) {&#10;                gameStartResponse.whitePlayer -&gt; TeamColor.WHITE&#10;                gameStartResponse.blackPlayer -&gt; TeamColor.BLACK&#10;                else -&gt; null&#10;            }&#10;&#10;            // Zeit direkt aus gameTime (jetzt Int in Sekunden)&#10;            _whiteTime.value = gameStartResponse.gameTime.seconds&#10;            _blackTime.value = gameStartResponse.gameTime.seconds&#10;            lastActivePlayer = TeamColor.WHITE&#10;            startTimer(TeamColor.WHITE)&#10;&#10;            // Subscribe zu Spiel-Updates für diese Lobby&#10;            webSocketService.subscribeToGame(gameStartResponse.lobbyId)&#10;        }&#10;    }&#10;&#10;    private fun startTimer(activePlayer: TeamColor) {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            while (true) {&#10;                delay(1000)&#10;                if (activePlayer == TeamColor.WHITE) {&#10;                    if (_whiteTime.value &gt; 0) _whiteTime.value = _whiteTime.value - 1&#10;                } else {&#10;                    if (_blackTime.value &gt; 0) _blackTime.value = _blackTime.value - 1&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPositionRequest(lobbyId: String, position: String) {&#10;        viewModelScope.launch {&#10;            val message = app.chesspresso.model.game.PositionRequestMessage(lobbyId, position)&#10;            webSocketService.sendPositionRequest(message)&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(lobbyId: String, from: String, to: String, teamColor: TeamColor, promotedPiece: PieceType? = null) {&#10;        val message = app.chesspresso.model.game.GameMoveMessage(&#10;            lobbyId = lobbyId,&#10;            from = from,&#10;            to = to,&#10;            teamColor = teamColor,&#10;            promotedPiece = promotedPiece&#10;        )&#10;        webSocketService.sendGameMoveMessage(message)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;        webSocketService.unsubscribeFromGame()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>