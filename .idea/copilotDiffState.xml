<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.qr.QRScannerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.qr.QRScannerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/GameApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/GameApi.kt" />
              <option name="originalContent" value="package app.chesspresso.data.api&#10;&#10;import app.chesspresso.data.models.EventRequest&#10;import app.chesspresso.data.models.StatsReportRequest&#10;import app.chesspresso.data.models.StatsResponse&#10;import app.chesspresso.model.game.GameHistoryDto&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.POST&#10;import retrofit2.http.Path&#10;&#10;interface GameApi {&#10;    @POST(&quot;events&quot;)&#10;    suspend fun sendEvent(@Body request: EventRequest): Response&lt;Unit&gt;&#10;&#10;    @POST(&quot;stats/report&quot;)&#10;    suspend fun reportStats(@Body request: StatsReportRequest): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;stats/me&quot;)&#10;    suspend fun getMyStats(): Response&lt;StatsResponse&gt;&#10;&#10;    @GET(&quot;api/games/history/{userId}&quot;)&#10;    suspend fun getGameHistory(@Path(&quot;userId&quot;) userId: String): Response&lt;List&lt;GameHistoryDto&gt;&gt;&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.data.api&#13;&#10;&#13;&#10;import app.chesspresso.data.models.EventRequest&#13;&#10;import app.chesspresso.data.models.StatsReportRequest&#13;&#10;import app.chesspresso.data.models.StatsResponse&#13;&#10;import app.chesspresso.model.game.GameHistoryDto&#13;&#10;import retrofit2.Response&#13;&#10;import retrofit2.http.Body&#13;&#10;import retrofit2.http.GET&#13;&#10;import retrofit2.http.POST&#13;&#10;import retrofit2.http.Path&#13;&#10;&#13;&#10;interface GameApi {&#13;&#10;    @POST(&quot;events&quot;)&#13;&#10;    suspend fun sendEvent(@Body request: EventRequest): Response&lt;Unit&gt;&#13;&#10;&#13;&#10;    @POST(&quot;stats/report&quot;)&#13;&#10;    suspend fun reportStats(@Body request: StatsReportRequest): Response&lt;Unit&gt;&#13;&#10;&#13;&#10;    @GET(&quot;stats/me&quot;)&#13;&#10;    suspend fun getMyStats(): Response&lt;StatsResponse&gt;&#13;&#10;&#13;&#10;    @GET(&quot;api/games/history/{userId}&quot;)&#13;&#10;    suspend fun getGameHistory(@Path(&quot;userId&quot;) userId: String): Response&lt;List&lt;GameHistoryDto&gt;&gt;&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/UserApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/UserApi.kt" />
              <option name="originalContent" value="package app.chesspresso.data.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.PATCH&#10;&#10;// Datenklasse für die Anfrage&#10;data class ChangeUsernameRequest(val newUsername: String)&#10;&#10;// Datenklasse für die Passwortänderung&#10;data class ChangePasswordRequest(&#10;    val oldPassword: String,&#10;    val newPassword: String&#10;)&#10;&#10;data class UserProfileResponse(&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;interface UserApi {&#10;    @PATCH(&quot;/user/username&quot;)&#10;    suspend fun changeUsername(@Body request: ChangeUsernameRequest): Response&lt;Unit&gt;&#10;&#10;    @PATCH(&quot;/user/password&quot;)&#10;    suspend fun changePassword(@Body request: ChangePasswordRequest): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;/user/profile&quot;)&#10;    suspend fun getProfile(): UserProfileResponse&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.data.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.GET&#10;import retrofit2.http.PATCH&#10;&#10;// Datenklasse für die Anfrage&#10;data class ChangeUsernameRequest(val newUsername: String)&#10;&#10;// Datenklasse für die Passwortänderung&#10;data class ChangePasswordRequest(&#10;    val oldPassword: String,&#10;    val newPassword: String&#10;)&#10;&#10;data class UserProfileResponse(&#10;    val username: String,&#10;    val email: String&#10;)&#10;&#10;interface UserApi {&#10;    @PATCH(&quot;/user/username&quot;)&#10;    suspend fun changeUsername(@Body request: ChangeUsernameRequest): Response&lt;Unit&gt;&#10;&#10;    @PATCH(&quot;/user/password&quot;)&#10;    suspend fun changePassword(@Body request: ChangePasswordRequest): Response&lt;Unit&gt;&#10;&#10;    @GET(&quot;/user/profile&quot;)&#10;    suspend fun getProfile(): UserProfileResponse&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/ChessGameScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/ChessGameScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.board.Board&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChessGameScreen(&#10;    gameStartResponse: GameStartResponse,&#10;    viewModel: ChessGameViewModel = hiltViewModel(),&#10;    playerId: String,&#10;    onGameEnd: (gameEndResponse: app.chesspresso.model.lobby.GameEndResponse, playerId: String) -&gt; Unit = { _, _ -&gt; }&#10;) {&#10;    val board = remember { Board() }&#10;&#10;    // Collect ViewModel states&#10;    val currentBoard by viewModel.currentBoard.collectAsState()&#10;    val currentPlayer by viewModel.currentPlayer.collectAsState()&#10;    val currentGameState by viewModel.currentGameState.collectAsState()&#10;    val whiteTime by viewModel.whiteTime.collectAsState()&#10;    val blackTime by viewModel.blackTime.collectAsState()&#10;    val myColor by viewModel.myColor.collectAsState()&#10;    val possibleMoves by viewModel.possibleMoves.collectAsState()&#10;    val promotionRequest by viewModel.promotionRequest.collectAsState()&#10;    val gameEndEvent by viewModel.gameEndEvent.collectAsState()&#10;&#10;    // Determine which board state to use (current or initial)&#10;    val boardToDisplay = currentBoard.ifEmpty { gameStartResponse.board }&#10;    val activePlayer = currentPlayer ?: TeamColor.WHITE&#10;&#10;    // Initialize game when component first loads&#10;    LaunchedEffect(gameStartResponse) {&#10;        viewModel.initializeGame(gameStartResponse)&#10;    }&#10;&#10;    // Navigation zum GameOverScreen, wenn das Spiel beendet ist&#10;    LaunchedEffect(gameEndEvent) {&#10;        if (gameEndEvent != null) {&#10;            onGameEnd(gameEndEvent!!, playerId)&#10;        }&#10;    }&#10;&#10;    // ModalNavigationDrawer entfernt, Drawer wird jetzt zentral im MainScaffoldScreen verwaltet&#10;    Scaffold(&#10;        // TopAppBar entfernt, damit sie nur noch im MainScaffoldScreen angezeigt wird&#10;        content = { paddingValues -&gt;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .padding(horizontal = 8.dp, vertical = 4.dp), // Weniger vertikaler Abstand&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Spieler und Uhren&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(IntrinsicSize.Min),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    if (myColor == TeamColor.WHITE) {&#10;                        // Eigener Spieler (Weiß) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Schwarz) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                    } else if (myColor == TeamColor.BLACK) {&#10;                        // Eigener Spieler (Schwarz) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Weiß) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Schachbrett - verwende den aktuellen Spielbrett-Zustand&#10;                board.BoardContent(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 8.dp),&#10;                    boardState = boardToDisplay,&#10;                    lobbyId = gameStartResponse.lobbyId,&#10;                    onPositionRequest = { positionRequest -&gt;&#10;                        viewModel.sendPositionRequest(&#10;                            gameStartResponse.lobbyId,&#10;                            positionRequest.position&#10;                        )&#10;                    },&#10;                    isFlipped = (myColor == TeamColor.BLACK),&#10;                    possibleMoves = if (myColor == currentPlayer) possibleMoves else emptyList(),&#10;                    nextPlayer = currentPlayer ?: TeamColor.WHITE,&#10;                    myColor = myColor,&#10;                    isCheck = currentGameState?.isCheck ?: &quot;&quot;,&#10;                    onGameMove = { from, to -&gt;&#10;                        val color = myColor&#10;                        if (color != null) {&#10;                            viewModel.sendGameMoveMessage(&#10;                                gameStartResponse.lobbyId,&#10;                                from,&#10;                                to,&#10;                                color&#10;                            )&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // --- Promotion Auswahl unter dem Brett ---&#10;                if (promotionRequest != null &amp;&amp; promotionRequest!!.activeTeam == myColor) {&#10;                    val promotionPosition = promotionRequest!!.position&#10;                    val promotionFrom = promotionRequest!!.from&#10;                    val promotionOptions = listOf(&#10;                        app.chesspresso.model.PieceType.QUEEN,&#10;                        app.chesspresso.model.PieceType.ROOK,&#10;                        app.chesspresso.model.PieceType.BISHOP,&#10;                        app.chesspresso.model.PieceType.KNIGHT&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 8.dp),&#10;                        elevation = CardDefaults.cardElevation(4.dp)&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(12.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&quot;Wähle die Figur für die Umwandlung:&quot;, style = MaterialTheme.typography.titleMedium)&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Row(&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .heightIn(min = 48.dp)&#10;                            ) {&#10;                                promotionOptions.forEach { pieceType -&gt;&#10;                                    val drawableRes = when (pieceType) {&#10;                                        app.chesspresso.model.PieceType.QUEEN -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.queen_white else app.chesspresso.R.drawable.queen_black&#10;                                        app.chesspresso.model.PieceType.ROOK -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.rook_white else app.chesspresso.R.drawable.rook_black&#10;                                        app.chesspresso.model.PieceType.BISHOP -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.bishop_white else app.chesspresso.R.drawable.bishop_black&#10;                                        app.chesspresso.model.PieceType.KNIGHT -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.knight_white else app.chesspresso.R.drawable.knight_black&#10;                                        else -&gt; 0&#10;                                    }&#10;                                    if (drawableRes != 0) {&#10;                                        Image(&#10;                                            painter = painterResource(id = drawableRes),&#10;                                            contentDescription = pieceType.name,&#10;                                            modifier = Modifier&#10;                                                .size(48.dp)&#10;                                                .padding(horizontal = 6.dp)&#10;                                                .clickable {&#10;                                                    // Sende jetzt eine MoveMessage mit promotedPiece&#10;                                                    viewModel.sendGameMoveMessage(&#10;                                                        gameStartResponse.lobbyId,&#10;                                                        promotionFrom,&#10;                                                        promotionPosition,&#10;                                                        myColor!!,&#10;                                                        pieceType&#10;                                                    )&#10;                                                }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        })&#10;}&#10;&#10;@Composable&#10;fun PlayerClock(&#10;    playerName: String,&#10;    remainingTime: String,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            Text(&#10;                text = remainingTime,&#10;                style = MaterialTheme.typography.headlineLarge,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun pieceToUnicode(piece: app.chesspresso.model.game.PieceInfo): String {&#10;    return when (piece.type.name) {&#10;        &quot;KING&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;        &quot;QUEEN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;        &quot;ROOK&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;        &quot;BISHOP&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;        &quot;KNIGHT&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;        &quot;PAWN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;        else -&gt; &quot;?&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CapturedPieces(captured: List&lt;app.chesspresso.model.game.PieceInfo&gt;) {&#10;    if (captured.isEmpty()) return&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(50.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Kein Text mehr, nur Icons anzeigen&#10;            captured.forEach { piece -&gt;&#10;                Text(text = pieceToUnicode(piece), fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatSecondsToTimeString(seconds: Int): String {&#10;    val min = seconds / 60&#10;    val sec = seconds % 60&#10;    return &quot;%02d:%02d&quot;.format(min, sec)&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.board.Board&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChessGameScreen(&#10;    gameStartResponse: GameStartResponse,&#10;    viewModel: ChessGameViewModel = hiltViewModel(),&#10;    playerId: String,&#10;    onGameEnd: (gameEndResponse: app.chesspresso.model.lobby.GameEndResponse, playerId: String) -&gt; Unit = { _, _ -&gt; }&#10;) {&#10;    val board = remember { Board() }&#10;&#10;    // Collect ViewModel states&#10;    val currentBoard by viewModel.currentBoard.collectAsState()&#10;    val currentPlayer by viewModel.currentPlayer.collectAsState()&#10;    val currentGameState by viewModel.currentGameState.collectAsState()&#10;    val whiteTime by viewModel.whiteTime.collectAsState()&#10;    val blackTime by viewModel.blackTime.collectAsState()&#10;    val myColor by viewModel.myColor.collectAsState()&#10;    val possibleMoves by viewModel.possibleMoves.collectAsState()&#10;    val promotionRequest by viewModel.promotionRequest.collectAsState()&#10;    val gameEndEvent by viewModel.gameEndEvent.collectAsState()&#10;&#10;    // Determine which board state to use (current or initial)&#10;    val boardToDisplay = currentBoard.ifEmpty { gameStartResponse.board }&#10;    val activePlayer = currentPlayer ?: TeamColor.WHITE&#10;&#10;    // Initialize game when component first loads&#10;    LaunchedEffect(gameStartResponse) {&#10;        viewModel.initializeGame(gameStartResponse)&#10;    }&#10;&#10;    // Navigation zum GameOverScreen, wenn das Spiel beendet ist&#10;    LaunchedEffect(gameEndEvent) {&#10;        if (gameEndEvent != null) {&#10;            onGameEnd(gameEndEvent!!, playerId)&#10;        }&#10;    }&#10;&#10;    // ModalNavigationDrawer entfernt, Drawer wird jetzt zentral im MainScaffoldScreen verwaltet&#10;    Scaffold(&#10;        // TopAppBar entfernt, damit sie nur noch im MainScaffoldScreen angezeigt wird&#10;        content = { paddingValues -&gt;&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(paddingValues)&#10;                    .padding(horizontal = 8.dp, vertical = 4.dp), // Weniger vertikaler Abstand&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // Spieler und Uhren&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .height(IntrinsicSize.Min),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    if (myColor == TeamColor.WHITE) {&#10;                        // Eigener Spieler (Weiß) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Schwarz) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                    } else if (myColor == TeamColor.BLACK) {&#10;                        // Eigener Spieler (Schwarz) links&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.blackPlayer,&#10;                                remainingTime = formatSecondsToTimeString(blackTime),&#10;                                isActive = activePlayer == TeamColor.BLACK&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                        }&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        // Gegner (Weiß) rechts&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .weight(1f)&#10;                                .fillMaxWidth()&#10;                                .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            PlayerClock(&#10;                                playerName = gameStartResponse.whitePlayer,&#10;                                remainingTime = formatSecondsToTimeString(whiteTime),&#10;                                isActive = activePlayer == TeamColor.WHITE&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                            CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(24.dp))&#10;&#10;                // Schachbrett - verwende den aktuellen Spielbrett-Zustand&#10;                board.BoardContent(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 8.dp),&#10;                    boardState = boardToDisplay,&#10;                    lobbyId = gameStartResponse.lobbyId,&#10;                    onPositionRequest = { positionRequest -&gt;&#10;                        viewModel.sendPositionRequest(&#10;                            gameStartResponse.lobbyId,&#10;                            positionRequest.position&#10;                        )&#10;                    },&#10;                    isFlipped = (myColor == TeamColor.BLACK),&#10;                    possibleMoves = if (myColor == currentPlayer) possibleMoves else emptyList(),&#10;                    nextPlayer = currentPlayer ?: TeamColor.WHITE,&#10;                    myColor = myColor,&#10;                    isCheck = currentGameState?.isCheck ?: &quot;&quot;,&#10;                    onGameMove = { from, to -&gt;&#10;                        val color = myColor&#10;                        if (color != null) {&#10;                            viewModel.sendGameMoveMessage(&#10;                                gameStartResponse.lobbyId,&#10;                                from,&#10;                                to,&#10;                                color&#10;                            )&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // --- Promotion Auswahl unter dem Brett ---&#10;                if (promotionRequest != null &amp;&amp; promotionRequest!!.activeTeam == myColor) {&#10;                    val promotionPosition = promotionRequest!!.position&#10;                    val promotionFrom = promotionRequest!!.from&#10;                    val promotionOptions = listOf(&#10;                        app.chesspresso.model.PieceType.QUEEN,&#10;                        app.chesspresso.model.PieceType.ROOK,&#10;                        app.chesspresso.model.PieceType.BISHOP,&#10;                        app.chesspresso.model.PieceType.KNIGHT&#10;                    )&#10;                    Spacer(modifier = Modifier.height(12.dp))&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 8.dp),&#10;                        elevation = CardDefaults.cardElevation(4.dp)&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(12.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&quot;Wähle die Figur für die Umwandlung:&quot;, style = MaterialTheme.typography.titleMedium)&#10;                            Spacer(modifier = Modifier.height(4.dp))&#10;                            Row(&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .heightIn(min = 48.dp)&#10;                            ) {&#10;                                promotionOptions.forEach { pieceType -&gt;&#10;                                    val drawableRes = when (pieceType) {&#10;                                        app.chesspresso.model.PieceType.QUEEN -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.queen_white else app.chesspresso.R.drawable.queen_black&#10;                                        app.chesspresso.model.PieceType.ROOK -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.rook_white else app.chesspresso.R.drawable.rook_black&#10;                                        app.chesspresso.model.PieceType.BISHOP -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.bishop_white else app.chesspresso.R.drawable.bishop_black&#10;                                        app.chesspresso.model.PieceType.KNIGHT -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.knight_white else app.chesspresso.R.drawable.knight_black&#10;                                        else -&gt; 0&#10;                                    }&#10;                                    if (drawableRes != 0) {&#10;                                        Image(&#10;                                            painter = painterResource(id = drawableRes),&#10;                                            contentDescription = pieceType.name,&#10;                                            modifier = Modifier&#10;                                                .size(48.dp)&#10;                                                .padding(horizontal = 6.dp)&#10;                                                .clickable {&#10;                                                    // Sende jetzt eine MoveMessage mit promotedPiece&#10;                                                    viewModel.sendGameMoveMessage(&#10;                                                        gameStartResponse.lobbyId,&#10;                                                        promotionFrom,&#10;                                                        promotionPosition,&#10;                                                        myColor!!,&#10;                                                        pieceType&#10;                                                    )&#10;                                                }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        })&#10;}&#10;&#10;@Composable&#10;fun PlayerClock(&#10;    playerName: String,&#10;    remainingTime: String,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            Text(&#10;                text = remainingTime,&#10;                style = MaterialTheme.typography.headlineLarge,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun pieceToUnicode(piece: app.chesspresso.model.game.PieceInfo): String {&#10;    return when (piece.type.name) {&#10;        &quot;KING&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;        &quot;QUEEN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;        &quot;ROOK&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;        &quot;BISHOP&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;        &quot;KNIGHT&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;        &quot;PAWN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;        else -&gt; &quot;?&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CapturedPieces(captured: List&lt;app.chesspresso.model.game.PieceInfo&gt;) {&#10;    if (captured.isEmpty()) return&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(50.dp)&#10;    ) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Kein Text mehr, nur Icons anzeigen&#10;            captured.forEach { piece -&gt;&#10;                Text(text = pieceToUnicode(piece), fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatSecondsToTimeString(seconds: Int): String {&#10;    val min = seconds / 60&#10;    val sec = seconds % 60&#10;    return &quot;%02d:%02d&quot;.format(min, sec)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.RadioButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    isCreator: Boolean,&#10;    lobbyCode: String,&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val navigationEvent by viewModel.navigationEvent.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameTime by remember { mutableStateOf(GameTime.MIDDLE) }&#10;    var selectedWhitePlayer by remember { mutableStateOf(&quot;&quot;) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;&#10;    // Navigation nach Home wenn Lobby verlassen wurde&#10;    LaunchedEffect(navigationEvent) {&#10;        if (navigationEvent == &quot;home&quot;) {&#10;            onBackClick()&#10;            viewModel.onNavigated()&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    // Spieler-Namen aktualisieren wenn Lobby geladen wird&#10;    LaunchedEffect(currentLobby) {&#10;        currentLobby?.let { lobby -&gt;&#10;            if (lobby.players.isNotEmpty()) {&#10;                selectedWhitePlayer = lobby.players.first()&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        // nur wenn nur ein Spieler in der Lobby ist&#10;        if (currentLobby?.players?.size != 2) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Teile diesen Code mit deinem Freund&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code für Lobby-Ersteller anzeigen (nur wenn noch Platz frei ist)&#10;        if (isCreator &amp;&amp; currentLobby?.players?.size != 2) {&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Spieler-Status&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2):&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                currentLobby?.let { lobby -&gt;&#10;                    lobby.players.forEachIndexed { index, player -&gt;&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Person,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (currentLobby?.players?.size != 2) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(24.dp),&#10;                                strokeWidth = 2.dp&#10;                            )&#10;                            Text(&#10;                                text = &quot;Warte auf zweiten Spieler...&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Spieleinstellungen Card (nur für Ersteller)&#10;        currentLobby?.let { lobby -&gt;&#10;            if (isCreator) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Spiel-Einstellungen&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;&#10;                        // Spielzeit-Auswahl&#10;                        Text(&#10;                            text = &quot;Spielzeit:&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;&#10;                        GameTime.entries.forEach { gameTime -&gt;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = selectedGameTime == gameTime,&#10;                                        onClick = { selectedGameTime = gameTime }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = selectedGameTime == gameTime,&#10;                                    onClick = { selectedGameTime = gameTime }&#10;                                )&#10;                                Text(&#10;                                    text = gameTime.displayName,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Farbauswahl Card (nur wenn beide Spieler da sind)&#10;                if (lobby.players.size == 2) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Farbauswahl&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = randomColors,&#10;                                        onClick = { randomColors = true }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = randomColors,&#10;                                    onClick = { randomColors = true }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Zufällig&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = !randomColors,&#10;                                        onClick = { randomColors = false }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = !randomColors,&#10;                                    onClick = { randomColors = false }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Manuell auswählen&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            if (!randomColors) {&#10;                                Text(&#10;                                    text = &quot;Weiß spielt:&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                lobby.players.forEachIndexed { index, player -&gt;&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .selectable(&#10;                                                selected = selectedWhitePlayer == player,&#10;                                                onClick = { selectedWhitePlayer = player }&#10;                                            )&#10;                                            .padding(vertical = 2.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        RadioButton(&#10;                                            selected = selectedWhitePlayer == player,&#10;                                            onClick = { selectedWhitePlayer = player }&#10;                                        )&#10;                                        Text(&#10;                                            text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                            modifier = Modifier.padding(start = 8.dp),&#10;                                            style = MaterialTheme.typography.bodySmall&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Spiel starten Button&#10;                    Button(&#10;                        onClick = {&#10;                            val whitePlayerFinal = if (randomColors) null else selectedWhitePlayer&#10;                            val blackPlayerFinal =&#10;                                if (randomColors) null else lobby.players.find { it != selectedWhitePlayer }&#10;&#10;                            viewModel.configureAndStartGame(&#10;                                lobbyCode = lobbyCode,&#10;                                gameTime = selectedGameTime,&#10;                                whitePlayer = whitePlayerFinal,&#10;                                blackPlayer = blackPlayerFinal,&#10;                                randomColors = randomColors&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        enabled = !uiState.isLoading&#10;                    ) {&#10;                        if (uiState.isLoading) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(20.dp),&#10;                                color = MaterialTheme.colorScheme.onPrimary&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;                        Text(&quot;Spiel starten&quot;)&#10;                    }&#10;                }&#10;            } else if (lobby.players.size == 2) {&#10;                // Warte-Status für den zweiten Spieler&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(24.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = &quot;Warte auf Spiel-Start...&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Text(&#10;                            text = &quot;Der Lobby-Ersteller richtet das Spiel ein.&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Lobby verlassen Button&#10;        OutlinedButton(&#10;            onClick = {&#10;                viewModel.leaveLobby()&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = ButtonDefaults.outlinedButtonColors(&#10;                contentColor = MaterialTheme.colorScheme.error&#10;            )&#10;        ) {&#10;            Text(&quot;Lobby verlassen&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.RadioButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    isCreator: Boolean,&#10;    lobbyCode: String,&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val navigationEvent by viewModel.navigationEvent.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameTime by remember { mutableStateOf(GameTime.MIDDLE) }&#10;    var selectedWhitePlayer by remember { mutableStateOf(&quot;&quot;) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;&#10;    // Navigation nach Home wenn Lobby verlassen wurde&#10;    LaunchedEffect(navigationEvent) {&#10;        if (navigationEvent == &quot;home&quot;) {&#10;            onBackClick()&#10;            viewModel.onNavigated()&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    // Spieler-Namen aktualisieren wenn Lobby geladen wird&#10;    LaunchedEffect(currentLobby) {&#10;        currentLobby?.let { lobby -&gt;&#10;            if (lobby.players.isNotEmpty()) {&#10;                selectedWhitePlayer = lobby.players.first()&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        // nur wenn nur ein Spieler in der Lobby ist&#10;        if (currentLobby?.players?.size != 2) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Teile diesen Code mit deinem Freund&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code für Lobby-Ersteller anzeigen (nur wenn noch Platz frei ist)&#10;        if (isCreator &amp;&amp; currentLobby?.players?.size != 2) {&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Spieler-Status&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2):&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                currentLobby?.let { lobby -&gt;&#10;                    lobby.players.forEachIndexed { index, player -&gt;&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Person,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (currentLobby?.players?.size != 2) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(24.dp),&#10;                                strokeWidth = 2.dp&#10;                            )&#10;                            Text(&#10;                                text = &quot;Warte auf zweiten Spieler...&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Spieleinstellungen Card (nur für Ersteller)&#10;        currentLobby?.let { lobby -&gt;&#10;            if (isCreator) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Spiel-Einstellungen&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;&#10;                        // Spielzeit-Auswahl&#10;                        Text(&#10;                            text = &quot;Spielzeit:&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;&#10;                        GameTime.entries.forEach { gameTime -&gt;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = selectedGameTime == gameTime,&#10;                                        onClick = { selectedGameTime = gameTime }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = selectedGameTime == gameTime,&#10;                                    onClick = { selectedGameTime = gameTime }&#10;                                )&#10;                                Text(&#10;                                    text = gameTime.displayName,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Farbauswahl Card (nur wenn beide Spieler da sind)&#10;                if (lobby.players.size == 2) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Farbauswahl&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = randomColors,&#10;                                        onClick = { randomColors = true }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = randomColors,&#10;                                    onClick = { randomColors = true }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Zufällig&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = !randomColors,&#10;                                        onClick = { randomColors = false }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = !randomColors,&#10;                                    onClick = { randomColors = false }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Manuell auswählen&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            if (!randomColors) {&#10;                                Text(&#10;                                    text = &quot;Weiß spielt:&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                lobby.players.forEachIndexed { index, player -&gt;&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .selectable(&#10;                                                selected = selectedWhitePlayer == player,&#10;                                                onClick = { selectedWhitePlayer = player }&#10;                                            )&#10;                                            .padding(vertical = 2.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        RadioButton(&#10;                                            selected = selectedWhitePlayer == player,&#10;                                            onClick = { selectedWhitePlayer = player }&#10;                                        )&#10;                                        Text(&#10;                                            text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                            modifier = Modifier.padding(start = 8.dp),&#10;                                            style = MaterialTheme.typography.bodySmall&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Spiel starten Button&#10;                    Button(&#10;                        onClick = {&#10;                            val whitePlayerFinal = if (randomColors) null else selectedWhitePlayer&#10;                            val blackPlayerFinal =&#10;                                if (randomColors) null else lobby.players.find { it != selectedWhitePlayer }&#10;&#10;                            viewModel.configureAndStartGame(&#10;                                lobbyCode = lobbyCode,&#10;                                gameTime = selectedGameTime,&#10;                                whitePlayer = whitePlayerFinal,&#10;                                blackPlayer = blackPlayerFinal,&#10;                                randomColors = randomColors&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        enabled = !uiState.isLoading&#10;                    ) {&#10;                        if (uiState.isLoading) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(20.dp),&#10;                                color = MaterialTheme.colorScheme.onPrimary&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;                        Text(&quot;Spiel starten&quot;)&#10;                    }&#10;                }&#10;            } else if (lobby.players.size == 2) {&#10;                // Warte-Status für den zweiten Spieler&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(24.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = &quot;Warte auf Spiel-Start...&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Text(&#10;                            text = &quot;Der Lobby-Ersteller richtet das Spiel ein.&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Lobby verlassen Button&#10;        OutlinedButton(&#10;            onClick = {&#10;                viewModel.leaveLobby()&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = ButtonDefaults.outlinedButtonColors(&#10;                contentColor = MaterialTheme.colorScheme.error&#10;            )&#10;        ) {&#10;            Text(&quot;Lobby verlassen&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>