<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/model/board/Board.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/model/board/Board.kt" />
              <option name="originalContent" value="package app.chesspresso.model.board&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.colorResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.PieceInfo&#10;import app.chesspresso.model.game.PositionRequestMessage&#10;&#10;class Board {&#10;    val board: List&lt;Field&gt; = boardInit().toMutableList()&#10;&#10;    fun boardInit(): List&lt;Field&gt; {&#10;        val list = mutableListOf&lt;Field&gt;()&#10;        val cols = 'A'..'H'&#10;        val rows = 1..8&#10;&#10;        for (row in rows.reversed()) {&#10;            for (col in cols) {&#10;                val field = Field(&quot;$col$row&quot;)&#10;                // Setze die Farbe der Felder&#10;                field.isLightSquare = (row + col.code) % 2 == 0&#10;                list.add(field)&#10;            }&#10;        }&#10;        return list&#10;    }&#10;&#10;    fun getField(name: String): Field? {&#10;        return board.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;    }&#10;&#10;    @Composable&#10;    fun BoardContent(&#10;        modifier: Modifier = Modifier,&#10;        nextPlayer: TeamColor = TeamColor.WHITE,&#10;        myColor: TeamColor? = null,&#10;        isCheck: String = &quot;&quot;,&#10;        isCheckmate: String = &quot;&quot;,&#10;        boardState: Map&lt;String, PieceInfo?&gt; = emptyMap(),&#10;        lobbyId: String = &quot;&quot;,&#10;        onPositionRequest: (PositionRequestMessage) -&gt; Unit = {},&#10;        isFlipped: Boolean = false,&#10;        possibleMoves: List&lt;String&gt; = emptyList(),&#10;        onGameMove: (from: String, to: String) -&gt; Unit = { _, _ -&gt; },&#10;        fieldHighlights: Map&lt;String, app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight&gt; = emptyMap() // NEU&#10;    ) {&#10;        var selectedField by remember { mutableStateOf&lt;String?&gt;(null) }&#10;        var validMoves by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(possibleMoves.toSet()) }&#10;&#10;        var currentIndex : String? = boardState.keys.firstOrNull()&#10;        if(currentIndex.isNullOrEmpty()){&#10;            Log.d(&quot;BoardContent&quot;, &quot;boardState is empty&quot;)&#10;        } else {&#10;            Log.d(&quot;BoardContent&quot;, &quot;boardState has entries, first key: $currentIndex&quot;)&#10;        }&#10;&#10;        // Funktion zum Zurücksetzen der Auswahl&#10;        fun resetSelection() {&#10;            // Reset validMove states only (isSelected is now handled by Compose state)&#10;            board.forEach { field -&gt;&#10;                field.isValidMove = false&#10;            }&#10;        }&#10;&#10;        // Funktion für Feldklicks&#10;        fun handleFieldClick(fieldName: String) {&#10;            //Nur erlauben, wenn der Spieler am Zug ist&#10;            if (myColor == null || myColor != nextPlayer) {&#10;                Log.d(&quot;BoardContent&quot;, &quot;Nicht am Zug: myColor=$myColor, nextPlayer=$nextPlayer&quot;)&#10;                return&#10;            }&#10;&#10;            val field = getField(fieldName) ?: return&#10;&#10;            when {&#10;                // Wenn bereits ein Feld ausgewählt ist und wir auf ein anderes klicken&#10;                selectedField != null &amp;&amp; selectedField != fieldName -&gt; {&#10;                    if (validMoves.contains(fieldName)) {&#10;                        // Zug ausführen&#10;                        Log.d(&quot;Board&quot;, &quot;Zug von $selectedField nach $fieldName&quot;)&#10;                        onGameMove(selectedField!!, fieldName) // NEU: Callback aufrufen&#10;                        resetSelection()&#10;                        selectedField = null // Auswahl nach Zug zurücksetzen&#10;                    } else {&#10;                        // Neue Auswahl oder Abwählen&#10;                        resetSelection()&#10;                        if (boardState[fieldName] != null) {&#10;                            // Neues Feld auswählen&#10;                            selectedField = fieldName&#10;&#10;                            // PositionRequestMessage erstellen und senden&#10;                            val positionRequest = PositionRequestMessage(&#10;                                lobbyId = lobbyId,&#10;                                position = fieldName&#10;                            )&#10;                            onPositionRequest(positionRequest)&#10;                            Log.d(&quot;Board&quot;, &quot;PositionRequest gesendet: $positionRequest&quot;)&#10;                        }&#10;                    }&#10;                }&#10;                // Wenn das gleiche Feld nochmal geklickt wird&#10;                selectedField == fieldName -&gt; {&#10;                    resetSelection()&#10;                    selectedField = null&#10;                    validMoves = emptySet() // possibleMoves zurücksetzen&#10;                }&#10;                // Wenn noch nichts ausgewählt ist&#10;                selectedField == null -&gt; {&#10;                    if (boardState[fieldName] != null) {&#10;                        selectedField = fieldName&#10;&#10;                        // PositionRequestMessage erstellen und senden&#10;                        val positionRequest = PositionRequestMessage(&#10;                            lobbyId = lobbyId,&#10;                            position = fieldName&#10;                        )&#10;                        onPositionRequest(positionRequest)&#10;                        Log.d(&quot;Board&quot;, &quot;PositionRequest gesendet: $positionRequest&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Synchronisiere validMoves mit possibleMoves&#10;        LaunchedEffect(possibleMoves) {&#10;            validMoves = possibleMoves.toSet()&#10;        }&#10;&#10;        // Labels und Reihenfolge je nach Drehung&#10;        val columnLabels = if (isFlipped) listOf(&quot;H&quot;, &quot;G&quot;, &quot;F&quot;, &quot;E&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;) else listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;)&#10;        val rowLabels = if (isFlipped) (1..8).toList() else (8 downTo 1).toList()&#10;        val numberFontSize = 14.sp&#10;        val labelFontSize = 20.sp&#10;        val labelFontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;        val labelColor = Color.Black // Alternativ: Color.White, je nach Theme&#10;        val rowRange = if (isFlipped) 7 downTo 0 else 0..7&#10;        val colRange = if (isFlipped) 7 downTo 0 else 0..7&#10;&#10;        Column(&#10;            modifier = modifier.aspectRatio(1f)&#10;        ) {&#10;            // Obere Buchstaben-Beschriftung&#10;            Row(modifier = Modifier.fillMaxWidth()) {&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;                for (label in columnLabels) {&#10;                    Box(&#10;                        modifier = Modifier.weight(1f),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = label,&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                }&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;            }&#10;            // Das Brett mit Zahlen-Beschriftung links und rechts&#10;            for ((rowIdx, row) in rowRange.withIndex()) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(1f),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // Linke Zahlen-Beschriftung mit mehr Abstand zum Brett&#10;                    Box(&#10;                        modifier = Modifier.weight(0.3f).padding(end = 12.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = rowLabels[rowIdx].toString(),&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor&#10;                        )&#10;                    }&#10;                    // Schachbrettfelder&#10;                    for (col in colRange) {&#10;                        val index = row * 8 + col&#10;                        val field = board[index]&#10;                        val isLightSquare = (row + col) % 2 == 0&#10;                        field.isLightSquare = isLightSquare&#10;                        val highlight = fieldHighlights[field.name] ?: app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.NONE&#10;                        val backgroundColor = when (highlight) {&#10;                            app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.CHECKMATE_KING -&gt; Color(colorResource(id = app.chesspresso.R.color.checkmate_king).value)&#10;                            app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.CHECKMATE_ATTACKER, &#10;                            app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.CHECK_KING -&gt; Color(colorResource(id = app.chesspresso.R.color.checkmate_attacker).value)&#10;                            else -&gt; if (isLightSquare) app.chesspresso.ui.theme.CoffeeCremeMid else app.chesspresso.ui.theme.CoffeeBrownSoft&#10;                        }&#10;                        Box(&#10;                            modifier = Modifier.weight(1f)&#10;                        ) {&#10;                            field.FieldContent(&#10;                                modifier = Modifier.fillMaxSize().clickable { handleFieldClick(field.name) }.background(backgroundColor),&#10;                                isCheck = isCheck == field.name,&#10;                                isCheckmate = isCheckmate == field.name,&#10;                                pieceInfo = boardState.getValue(field.name),&#10;                                isFieldSelected = selectedField == field.name,&#10;                                isValidMove = validMoves.contains(field.name),&#10;                                onFieldClick = { handleFieldClick(field.name) }&#10;                            )&#10;                        }&#10;                    }&#10;                    // Rechte Zahlen-Beschriftung mit mehr Abstand zum Brett&#10;                    Box(&#10;                        modifier = Modifier.weight(0.3f).padding(start = 12.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = rowLabels[rowIdx].toString(),&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            // Untere Buchstaben-Beschriftung&#10;            Row(modifier = Modifier.fillMaxWidth()) {&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;                for (label in columnLabels) {&#10;                    Box(&#10;                        modifier = Modifier.weight(1f),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = label,&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor,&#10;                            modifier = Modifier.padding(top = 8.dp)&#10;                        )&#10;                    }&#10;                }&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funktion zum Setzen der gültigen Züge (wird später vom Server Response aufgerufen)&#10;    fun setValidMoves(moves: Set&lt;String&gt;) {&#10;        board.forEach { field -&gt;&#10;            field.isValidMove = moves.contains(field.name)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.model.board&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.aspectRatio&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.colorResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.PieceInfo&#10;import app.chesspresso.model.game.PositionRequestMessage&#10;&#10;class Board {&#10;    val board: List&lt;Field&gt; = boardInit().toMutableList()&#10;&#10;    fun boardInit(): List&lt;Field&gt; {&#10;        val list = mutableListOf&lt;Field&gt;()&#10;        val cols = 'A'..'H'&#10;        val rows = 1..8&#10;&#10;        for (row in rows.reversed()) {&#10;            for (col in cols) {&#10;                val field = Field(&quot;$col$row&quot;)&#10;                // Setze die Farbe der Felder&#10;                field.isLightSquare = (row + col.code) % 2 == 0&#10;                list.add(field)&#10;            }&#10;        }&#10;        return list&#10;    }&#10;&#10;    fun getField(name: String): Field? {&#10;        return board.firstOrNull { it.name.equals(name, ignoreCase = true) }&#10;    }&#10;&#10;    @Composable&#10;    fun BoardContent(&#10;        modifier: Modifier = Modifier,&#10;        nextPlayer: TeamColor = TeamColor.WHITE,&#10;        myColor: TeamColor? = null,&#10;        isCheck: String = &quot;&quot;,&#10;        isCheckmate: String = &quot;&quot;,&#10;        boardState: Map&lt;String, PieceInfo?&gt; = emptyMap(),&#10;        lobbyId: String = &quot;&quot;,&#10;        onPositionRequest: (PositionRequestMessage) -&gt; Unit = {},&#10;        isFlipped: Boolean = false,&#10;        possibleMoves: List&lt;String&gt; = emptyList(),&#10;        onGameMove: (from: String, to: String) -&gt; Unit = { _, _ -&gt; },&#10;        fieldHighlights: Map&lt;String, app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight&gt; = emptyMap() // NEU&#10;    ) {&#10;        var selectedField by remember { mutableStateOf&lt;String?&gt;(null) }&#10;        var validMoves by remember { mutableStateOf&lt;Set&lt;String&gt;&gt;(possibleMoves.toSet()) }&#10;&#10;        var currentIndex : String? = boardState.keys.firstOrNull()&#10;        if(currentIndex.isNullOrEmpty()){&#10;            Log.d(&quot;BoardContent&quot;, &quot;boardState is empty&quot;)&#10;        } else {&#10;            Log.d(&quot;BoardContent&quot;, &quot;boardState has entries, first key: $currentIndex&quot;)&#10;        }&#10;&#10;        // Funktion zum Zurücksetzen der Auswahl&#10;        fun resetSelection() {&#10;            // Reset validMove states only (isSelected is now handled by Compose state)&#10;            board.forEach { field -&gt;&#10;                field.isValidMove = false&#10;            }&#10;        }&#10;&#10;        // Funktion für Feldklicks&#10;        fun handleFieldClick(fieldName: String) {&#10;            //Nur erlauben, wenn der Spieler am Zug ist&#10;            if (myColor == null || myColor != nextPlayer) {&#10;                Log.d(&quot;BoardContent&quot;, &quot;Nicht am Zug: myColor=$myColor, nextPlayer=$nextPlayer&quot;)&#10;                return&#10;            }&#10;&#10;            val field = getField(fieldName) ?: return&#10;&#10;            when {&#10;                // Wenn bereits ein Feld ausgewählt ist und wir auf ein anderes klicken&#10;                selectedField != null &amp;&amp; selectedField != fieldName -&gt; {&#10;                    if (validMoves.contains(fieldName)) {&#10;                        // Zug ausführen&#10;                        Log.d(&quot;Board&quot;, &quot;Zug von $selectedField nach $fieldName&quot;)&#10;                        onGameMove(selectedField!!, fieldName) // NEU: Callback aufrufen&#10;                        resetSelection()&#10;                        selectedField = null // Auswahl nach Zug zurücksetzen&#10;                    } else {&#10;                        // Neue Auswahl oder Abwählen&#10;                        resetSelection()&#10;                        if (boardState[fieldName] != null) {&#10;                            // Neues Feld auswählen&#10;                            selectedField = fieldName&#10;&#10;                            // PositionRequestMessage erstellen und senden&#10;                            val positionRequest = PositionRequestMessage(&#10;                                lobbyId = lobbyId,&#10;                                position = fieldName&#10;                            )&#10;                            onPositionRequest(positionRequest)&#10;                            Log.d(&quot;Board&quot;, &quot;PositionRequest gesendet: $positionRequest&quot;)&#10;                        }&#10;                    }&#10;                }&#10;                // Wenn das gleiche Feld nochmal geklickt wird&#10;                selectedField == fieldName -&gt; {&#10;                    resetSelection()&#10;                    selectedField = null&#10;                    validMoves = emptySet() // possibleMoves zurücksetzen&#10;                }&#10;                // Wenn noch nichts ausgewählt ist&#10;                selectedField == null -&gt; {&#10;                    if (boardState[fieldName] != null) {&#10;                        selectedField = fieldName&#10;&#10;                        // PositionRequestMessage erstellen und senden&#10;                        val positionRequest = PositionRequestMessage(&#10;                            lobbyId = lobbyId,&#10;                            position = fieldName&#10;                        )&#10;                        onPositionRequest(positionRequest)&#10;                        Log.d(&quot;Board&quot;, &quot;PositionRequest gesendet: $positionRequest&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Synchronisiere validMoves mit possibleMoves&#10;        LaunchedEffect(possibleMoves) {&#10;            validMoves = possibleMoves.toSet()&#10;        }&#10;&#10;        // Labels und Reihenfolge je nach Drehung&#10;        val columnLabels = if (isFlipped) listOf(&quot;H&quot;, &quot;G&quot;, &quot;F&quot;, &quot;E&quot;, &quot;D&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;) else listOf(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;)&#10;        val rowLabels = if (isFlipped) (1..8).toList() else (8 downTo 1).toList()&#10;        val numberFontSize = 14.sp&#10;        val labelFontSize = 20.sp&#10;        val labelFontWeight = androidx.compose.ui.text.font.FontWeight.Bold&#10;        val labelColor = Color.Black // Alternativ: Color.White, je nach Theme&#10;        val rowRange = if (isFlipped) 7 downTo 0 else 0..7&#10;        val colRange = if (isFlipped) 7 downTo 0 else 0..7&#10;&#10;        Column(&#10;            modifier = modifier.aspectRatio(1f)&#10;        ) {&#10;            // Obere Buchstaben-Beschriftung&#10;            Row(modifier = Modifier.fillMaxWidth()) {&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;                for (label in columnLabels) {&#10;                    Box(&#10;                        modifier = Modifier.weight(1f),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = label,&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                }&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;            }&#10;            // Das Brett mit Zahlen-Beschriftung links und rechts&#10;            for ((rowIdx, row) in rowRange.withIndex()) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .weight(1f),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    // Linke Zahlen-Beschriftung mit mehr Abstand zum Brett&#10;                    Box(&#10;                        modifier = Modifier.weight(0.3f).padding(end = 12.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = rowLabels[rowIdx].toString(),&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor&#10;                        )&#10;                    }&#10;                    // Schachbrettfelder&#10;                    for (col in colRange) {&#10;                        val index = row * 8 + col&#10;                        val field = board[index]&#10;                        val isLightSquare = (row + col) % 2 == 0&#10;                        field.isLightSquare = isLightSquare&#10;                        val highlight = fieldHighlights[field.name] ?: app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.NONE&#10;                        val backgroundColor = when (highlight) {&#10;                            app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.CHECKMATE_KING -&gt; Color(colorResource(id = app.chesspresso.R.color.checkmate_king).value)&#10;                            app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.CHECKMATE_ATTACKER, &#10;                            app.chesspresso.viewmodel.ChessGameViewModel.FieldHighlight.CHECK_KING -&gt; Color(colorResource(id = app.chesspresso.R.color.checkmate_attacker).value)&#10;                            else -&gt; if (isLightSquare) app.chesspresso.ui.theme.CoffeeCremeMid else app.chesspresso.ui.theme.CoffeeBrownSoft&#10;                        }&#10;                        Box(&#10;                            modifier = Modifier.weight(1f)&#10;                        ) {&#10;                            field.FieldContent(&#10;                                modifier = Modifier.fillMaxSize().clickable { handleFieldClick(field.name) }.background(backgroundColor),&#10;                                isCheck = isCheck == field.name,&#10;                                isCheckmate = isCheckmate == field.name,&#10;                                pieceInfo = boardState.getValue(field.name),&#10;                                isFieldSelected = selectedField == field.name,&#10;                                isValidMove = validMoves.contains(field.name),&#10;                                onFieldClick = { handleFieldClick(field.name) }&#10;                            )&#10;                        }&#10;                    }&#10;                    // Rechte Zahlen-Beschriftung mit mehr Abstand zum Brett&#10;                    Box(&#10;                        modifier = Modifier.weight(0.3f).padding(start = 12.dp),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = rowLabels[rowIdx].toString(),&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            // Untere Buchstaben-Beschriftung&#10;            Row(modifier = Modifier.fillMaxWidth()) {&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;                for (label in columnLabels) {&#10;                    Box(&#10;                        modifier = Modifier.weight(1f),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&#10;                            text = label,&#10;                            fontSize = labelFontSize,&#10;                            fontWeight = labelFontWeight,&#10;                            color = labelColor,&#10;                            modifier = Modifier.padding(top = 8.dp)&#10;                        )&#10;                    }&#10;                }&#10;                Spacer(modifier = Modifier.weight(0.2f))&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funktion zum Setzen der gültigen Züge (wird später vom Server Response aufgerufen)&#10;    fun setValidMoves(moves: Set&lt;String&gt;) {&#10;        board.forEach { field -&gt;&#10;            field.isValidMove = moves.contains(field.name)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>