<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    package=&quot;app.chesspresso&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    package=&quot;app.chesspresso&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/MainActivity.kt" />
              <option name="originalContent" value="package app.chesspresso&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import app.chesspresso.ui.theme.ChessPressoAppTheme&#10;import app.chesspresso.ui.theme.Creme1&#10;import app.chesspresso.ui.theme.Creme2&#10;import app.chesspresso.ui.theme.DarkBrown1&#10;import app.chesspresso.ui.theme.MidBrown2&#10;import app.chesspresso.auth.presemtation.LoginScreen&#10;import app.chesspresso.auth.presemtation.AuthViewModel&#10;import app.chesspresso.websocket.WebSocketManager&#10;import app.chesspresso.utils.PlayerIdManager&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            ChessPressoAppTheme {&#10;                MainScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onRegisterClick(){&#10;        //register&#10;    }&#10;&#10;    @Composable&#10;    fun MainScreen(){&#10;        val navController = rememberNavController()&#10;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = &quot;main_screen&quot;&#10;        ){&#10;            composable(&quot;main_screen&quot;) {&#10;                HomeScreen(&#10;                    onLoginClick = { navController.navigate(&quot;login_screen&quot;) }, &#10;                    onRegisterClick = { onRegisterClick() }&#10;                )&#10;        var isConnected by remember { mutableStateOf(false) }&#10;        var connectionStatus by remember { mutableStateOf(&quot;Nicht verbunden&quot;) }&#10;&#10;            }&#10;&#10;            composable(&quot;login_screen&quot;) {&#10;                val authViewModel: AuthViewModel = viewModel()&#10;                LoginScreen(authViewModel)&#10;            }&#10;&#10;            //andere Seiten werden hier geaddet&#10;        }&#10;        var isConnected by remember { mutableStateOf(false) }&#10;        var connectionStatus by remember { mutableStateOf(&quot;Nicht verbunden&quot;) }&#10;&#10;    }&#10;&#10;    @Composable&#10;    fun HomeScreen(&#10;        onLoginClick: () -&gt; Unit,&#10;        onRegisterClick: () -&gt; Unit&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    brush = Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            DarkBrown1, MidBrown2&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Image(&#10;                // Server Verbindungs Status&#10;                Text(&#10;                    text = &quot;Server Status: $connectionStatus&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = if (isConnected) Color.Green else Color.Red,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                // Server Verbindungs Button&#10;                Button(&#10;                    onClick = {&#10;                        if (!isConnected) {&#10;                            try {&#10;                                val playerId = PlayerIdManager.getOrCreatePlayerId(this@MainActivity)&#10;                                WebSocketManager.init(playerId)&#10;                                isConnected = true&#10;                                connectionStatus = &quot;Verbunden&quot;&#10;                            } catch (e: Exception) {&#10;                                connectionStatus = &quot;Verbindung fehlgeschlagen&quot;&#10;                            }&#10;                        } else {&#10;                            WebSocketManager.disconnect()&#10;                            isConnected = false&#10;                            connectionStatus = &quot;Nicht verbunden&quot;&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = if (isConnected) MaterialTheme.colorScheme.error&#10;                                       else MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = if (isConnected) &quot;Verbindung trennen&quot; else &quot;Mit Server verbinden&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                    painter = painterResource(id = R.drawable.watermark_chess),&#10;                    contentDescription = &quot;ChessPresso Logo&quot;,&#10;                    modifier = Modifier.size(400.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;ChessPresso&quot;,&#10;                    fontSize = 36.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Creme1&#10;                )&#10;&#10;                // Server Verbindungs Status&#10;                Text(&#10;                    text = &quot;Server Status: $connectionStatus&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = if (isConnected) Color.Green else Color.Red,&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                // Server Verbindungs Button&#10;                Button(&#10;                    onClick = {&#10;                        if (!isConnected) {&#10;                            try {&#10;                                val playerId = PlayerIdManager.getOrCreatePlayerId(this@MainActivity)&#10;                                WebSocketManager.init(playerId)&#10;                                isConnected = true&#10;                                connectionStatus = &quot;Verbunden&quot;&#10;                            } catch (e: Exception) {&#10;                                connectionStatus = &quot;Verbindung fehlgeschlagen&quot;&#10;                            }&#10;                        } else {&#10;                            WebSocketManager.disconnect()&#10;                            isConnected = false&#10;                            connectionStatus = &quot;Nicht verbunden&quot;&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = if (isConnected) MaterialTheme.colorScheme.error &#10;                                       else MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = if (isConnected) &quot;Verbindung trennen&quot; else &quot;Mit Server verbinden&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                Text(&#10;                    text = &quot;Schach für Koffeinabhängige&quot;,&#10;                    fontSize = 20.sp,&#10;                    color = Creme2,&#10;                    modifier = Modifier.padding(32.dp)&#10;                )&#10;&#10;                Button(&#10;                    onClick = onLoginClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Einloggen&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                Button(&#10;                    onClick = onRegisterClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    colors = ButtonDefaults.buttonColors()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Registrieren&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import app.chesspresso.ui.theme.ChessPressoAppTheme&#10;import app.chesspresso.ui.theme.Creme1&#10;import app.chesspresso.ui.theme.Creme2&#10;import app.chesspresso.ui.theme.DarkBrown1&#10;import app.chesspresso.ui.theme.MidBrown2&#10;import app.chesspresso.auth.presemtation.LoginScreen&#10;import app.chesspresso.auth.presemtation.AuthViewModel&#10;import app.chesspresso.websocket.WebSocketManager&#10;import app.chesspresso.utils.PlayerIdManager&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            ChessPressoAppTheme {&#10;                MainScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onRegisterClick(){&#10;        //register&#10;    }&#10;&#10;    @Composable&#10;    fun MainScreen(){&#10;        val navController = rememberNavController()&#10;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = &quot;main_screen&quot;&#10;        ){&#10;            composable(&quot;main_screen&quot;) {&#10;                HomeScreen(&#10;                    onLoginClick = { navController.navigate(&quot;login_screen&quot;) }, &#10;                    onRegisterClick = { onRegisterClick() }&#10;                )&#10;            }&#10;&#10;            composable(&quot;login_screen&quot;) {&#10;                val authViewModel: AuthViewModel = viewModel()&#10;                LoginScreen(authViewModel)&#10;            }&#10;&#10;            //andere Seiten werden hier geaddet&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun HomeScreen(&#10;        onLoginClick: () -&gt; Unit,&#10;        onRegisterClick: () -&gt; Unit&#10;    ) {&#10;        var isConnected by remember { mutableStateOf(false) }&#10;        var connectionStatus by remember { mutableStateOf(&quot;Nicht verbunden&quot;) }&#10;        var isConnecting by remember { mutableStateOf(false) }&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    brush = Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            DarkBrown1, MidBrown2&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.watermark_chess),&#10;                    contentDescription = &quot;ChessPresso Logo&quot;,&#10;                    modifier = Modifier.size(400.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;ChessPresso&quot;,&#10;                    fontSize = 36.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Creme1&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Schach für Koffeinabhängige&quot;,&#10;                    fontSize = 20.sp,&#10;                    color = Creme2,&#10;                    modifier = Modifier.padding(32.dp)&#10;                )&#10;&#10;                // Server Verbindungs Status&#10;                Text(&#10;                    text = &quot;Server Status: $connectionStatus&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = when {&#10;                        isConnecting -&gt; Color.Yellow&#10;                        isConnected -&gt; Color.Green&#10;                        else -&gt; Color.Red&#10;                    },&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                // Server Verbindungs Button&#10;                Button(&#10;                    onClick = {&#10;                        if (!isConnected &amp;&amp; !isConnecting) {&#10;                            isConnecting = true&#10;                            connectionStatus = &quot;Verbinde...&quot;&#10;                            &#10;                            val playerId = PlayerIdManager.getOrCreatePlayerId(this@MainActivity)&#10;                            WebSocketManager.init(&#10;                                playerId = playerId,&#10;                                onSuccess = {&#10;                                    isConnected = true&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Verbunden&quot;&#10;                                },&#10;                                onFailure = { error -&gt;&#10;                                    isConnected = false&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Fehler: $error&quot;&#10;                                },&#10;                                onDisconnect = {&#10;                                    isConnected = false&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Verbindung getrennt&quot;&#10;                                }&#10;                            )&#10;                        } else if (isConnected) {&#10;                            WebSocketManager.disconnect()&#10;                            // Status wird durch onDisconnect Callback aktualisiert&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    enabled = !isConnecting,&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = when {&#10;                            isConnecting -&gt; MaterialTheme.colorScheme.secondary&#10;                            isConnected -&gt; MaterialTheme.colorScheme.error &#10;                            else -&gt; MaterialTheme.colorScheme.primary&#10;                        }&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = when {&#10;                            isConnecting -&gt; &quot;Verbinde...&quot;&#10;                            isConnected -&gt; &quot;Verbindung trennen&quot;&#10;                            else -&gt; &quot;Mit Server verbinden&quot;&#10;                        },&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                Button(&#10;                    onClick = onLoginClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Einloggen&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                Button(&#10;                    onClick = onRegisterClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    colors = ButtonDefaults.buttonColors()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Registrieren&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/WebSocketManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/WebSocketManager.kt" />
              <option name="originalContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;&#10;object WebSocketManager : WebSocketListener(){&#10;    private const val SOCKET_URL = &quot;ws://10.0.2.2:8080&quot; // Emulator IP statt localhost&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;&#10;    private var playerId: String =&quot;&quot;&#10;    private var currentLobbyId: String? = null&#10;&#10;    // Callback-Funktionen für Verbindungsstatus&#10;    private var onConnectionSuccess: (() -&gt; Unit)? = null&#10;    private var onConnectionFailure: ((String) -&gt; Unit)? = null&#10;    private var onDisconnected: (() -&gt; Unit)? = null&#10;&#10;    fun init (playerId: String,&#10;              onSuccess: (() -&gt; Unit)? = null,&#10;              onFailure: ((String) -&gt; Unit)? = null,&#10;              onDisconnect: (() -&gt; Unit)? = null) {&#10;        this.playerId = playerId&#10;        this.onConnectionSuccess = onSuccess&#10;        this.onConnectionFailure = onFailure&#10;        this.onDisconnected = onDisconnect&#10;        connect()&#10;    }&#10;&#10;    private fun connect() {&#10;        val request = Request.Builder().url(SOCKET_URL).build()&#10;        val client = OkHttpClient()&#10;        webSocket = client.newWebSocket(request, this)&#10;    }&#10;&#10;    fun setLobby(lobbyId: String?) {&#10;        currentLobbyId = lobbyId&#10;    }&#10;&#10;    override fun onOpen(webSocket: WebSocket, response: Response) {&#10;        Log.d(&quot;WebSocket&quot;, &quot;Verbindung erfolgreich hergestellt&quot;)&#10;        onConnectionSuccess?.invoke()&#10;        startHeartbeat()&#10;    }&#10;&#10;    override fun onMessage(webSocket: WebSocket, text: String) {&#10;        Log.d(&quot;WebSocket&quot;, &quot;Nachricht vom Server: $text&quot;)&#10;        // für debugging&#10;    }&#10;&#10;    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;        Log.e(&quot;WebSocket&quot;, &quot;Verbindung fehlgeschlagen: ${t.message}&quot;)&#10;        onConnectionFailure?.invoke(t.message ?: &quot;Unbekannter Fehler&quot;)&#10;        stopHeartbeat()&#10;    }&#10;&#10;    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;        Log.i(&quot;WebSocket&quot;, &quot;Verbindung geschlossen: $reason&quot;)&#10;        onDisconnected?.invoke()&#10;        stopHeartbeat()&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive) {&#10;                val lobby = currentLobbyId ?: &quot;NoLobby&quot;&#10;                val message = buildHeartbeatMessage(playerId, lobby)&#10;                webSocket?.send(message)&#10;                delay(30_000)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;    }&#10;&#10;    fun disconnect() {&#10;        stopHeartbeat()&#10;        webSocket?.close(1000, &quot;App geschlossen&quot;)&#10;        onDisconnected?.invoke()&#10;    }&#10;&#10;    private fun buildHeartbeatMessage(playerId: String, lobbyId: String): String {&#10;        return &quot;&quot;&quot;&#10;            {&#10;              &quot;type&quot;: &quot;heartbeat&quot;,&#10;              &quot;playerId&quot;: &quot;$playerId&quot;,&#10;              &quot;lobbyId&quot;: &quot;$lobbyId&quot;&#10;            }&#10;        &quot;&quot;&quot;.trimIndent()&#10;    }&#10;&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;&#10;object WebSocketManager : WebSocketListener(){&#10;    private const val SOCKET_URL = &quot;ws://10.0.2.2:8080&quot; // Emulator IP statt localhost&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;&#10;    private var playerId: String =&quot;&quot;&#10;    private var currentLobbyId: String? = null&#10;&#10;    // Callback-Funktionen für Verbindungsstatus&#10;    private var onConnectionSuccess: (() -&gt; Unit)? = null&#10;    private var onConnectionFailure: ((String) -&gt; Unit)? = null&#10;    private var onDisconnected: (() -&gt; Unit)? = null&#10;&#10;    fun init (playerId: String,&#10;              onSuccess: (() -&gt; Unit)? = null,&#10;              onFailure: ((String) -&gt; Unit)? = null,&#10;              onDisconnect: (() -&gt; Unit)? = null) {&#10;        this.playerId = playerId&#10;        this.onConnectionSuccess = onSuccess&#10;        this.onConnectionFailure = onFailure&#10;        this.onDisconnected = onDisconnect&#10;        connect()&#10;    }&#10;&#10;    private fun connect() {&#10;        val request = Request.Builder().url(SOCKET_URL).build()&#10;        val client = OkHttpClient()&#10;        webSocket = client.newWebSocket(request, this)&#10;    }&#10;&#10;    fun setLobby(lobbyId: String?) {&#10;        currentLobbyId = lobbyId&#10;    }&#10;&#10;    override fun onOpen(webSocket: WebSocket, response: Response) {&#10;        Log.d(&quot;WebSocket&quot;, &quot;Verbindung erfolgreich hergestellt&quot;)&#10;        onConnectionSuccess?.invoke()&#10;        startHeartbeat()&#10;    }&#10;&#10;    override fun onMessage(webSocket: WebSocket, text: String) {&#10;        Log.d(&quot;WebSocket&quot;, &quot;Nachricht vom Server: $text&quot;)&#10;        // für debugging&#10;    }&#10;&#10;    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;        Log.e(&quot;WebSocket&quot;, &quot;Verbindung fehlgeschlagen: ${t.message}&quot;)&#10;        onConnectionFailure?.invoke(t.message ?: &quot;Unbekannter Fehler&quot;)&#10;        stopHeartbeat()&#10;    }&#10;&#10;    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;        Log.i(&quot;WebSocket&quot;, &quot;Verbindung geschlossen: $reason&quot;)&#10;        onDisconnected?.invoke()&#10;        stopHeartbeat()&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive) {&#10;                val lobby = currentLobbyId ?: &quot;NoLobby&quot;&#10;                val message = buildHeartbeatMessage(playerId, lobby)&#10;                webSocket?.send(message)&#10;                delay(30_000)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;    }&#10;&#10;    fun disconnect() {&#10;        stopHeartbeat()&#10;        webSocket?.close(1000, &quot;App geschlossen&quot;)&#10;        onDisconnected?.invoke()&#10;    }&#10;&#10;    private fun buildHeartbeatMessage(playerId: String, lobbyId: String): String {&#10;        return &quot;&quot;&quot;&#10;            {&#10;              &quot;type&quot;: &quot;heartbeat&quot;,&#10;              &quot;playerId&quot;: &quot;$playerId&quot;,&#10;              &quot;lobbyId&quot;: &quot;$lobbyId&quot;&#10;            }&#10;        &quot;&quot;&quot;.trimIndent()&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>