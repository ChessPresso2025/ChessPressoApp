<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameDuration&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    lobbyCode: String,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameDuration by remember { mutableStateOf(GameDuration.MEDIUM) }&#10;    var selectedWhitePlayer by remember { mutableStateOf(&quot;&quot;) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    // Spieler-Namen aktualisieren wenn Lobby geladen wird&#10;    LaunchedEffect(currentLobby) {&#10;        currentLobby?.let { lobby -&gt;&#10;            if (lobby.players.isNotEmpty()) {&#10;                selectedWhitePlayer = lobby.players.first()&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Große Überschrift mit Lobby-Code&#10;        Text(&#10;            text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        // Info-Card für den Lobby-Code&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                horizontalAlignment = Alignment.Start,&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Gib deinem Freund diesen Code&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Sobald dein Freund der Lobby beitritt, kann das Spiel beginnen.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;&#10;        // Spieler-Status Card&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2)&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                currentLobby?.let { lobby -&gt;&#10;                    lobby.players.forEachIndexed { index, player -&gt;&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Person,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (currentLobby?.players?.size != 2) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            strokeWidth = 2.dp&#10;                        )&#10;                        Text(&#10;                            text = &quot;Warte auf weiteren Spieler...&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameDuration&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    lobbyCode: String,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameDuration by remember { mutableStateOf(GameDuration.MEDIUM) }&#10;    var selectedWhitePlayer by remember { mutableStateOf(&quot;&quot;) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    // Spieler-Namen aktualisieren wenn Lobby geladen wird&#10;    LaunchedEffect(currentLobby) {&#10;        currentLobby?.let { lobby -&gt;&#10;            if (lobby.players.isNotEmpty()) {&#10;                selectedWhitePlayer = lobby.players.first()&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Große Überschrift mit Lobby-Code&#10;        Text(&#10;            text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;            style = MaterialTheme.typography.headlineMedium,&#10;            fontWeight = FontWeight.Bold,&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;&#10;        // Info-Card für den Lobby-Code&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                horizontalAlignment = Alignment.Start,&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Gib deinem Freund diesen Code&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Sobald dein Freund der Lobby beitritt, kann das Spiel beginnen.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;            }&#10;        }&#10;&#10;        // Spieler-Status Card&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2)&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                currentLobby?.let { lobby -&gt;&#10;                    lobby.players.forEachIndexed { index, player -&gt;&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Person,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (currentLobby?.players?.size != 2) {&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        verticalAlignment = Alignment.CenterVertically,&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            strokeWidth = 2.dp&#10;                        )&#10;                        Text(&#10;                            text = &quot;Warte auf weiteren Spieler...&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/PrivateLobbyScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/PrivateLobbyScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardCapitalization&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PrivateLobbyScreen(&#10;    onBackClick: () -&gt; Unit,&#10;    onLobbyCreated: (String) -&gt; Unit,&#10;    onLobbyJoined: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;&#10;    // Navigation bei erfolgreichem Lobby-Erstellen/Beitreten&#10;    LaunchedEffect(uiState.isLobbyCreated, uiState.createdLobbyCode) {&#10;        if (uiState.isLobbyCreated &amp;&amp; uiState.createdLobbyCode != null) {&#10;            onLobbyCreated(uiState.createdLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.isLobbyJoined, uiState.joinedLobbyCode) {&#10;        if (uiState.isLobbyJoined &amp;&amp; uiState.joinedLobbyCode != null) {&#10;            onLobbyJoined(uiState.joinedLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            // Navigation zum Spiel&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Lobby erstellen&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Neue Lobby erstellen&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Erstelle eine private Lobby und teile den Code mit deinem Freund.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                Button(&#10;                    onClick = { viewModel.createPrivateLobby() },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isCreating&#10;                ) {&#10;                    if (uiState.isCreating) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby erstellen&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Trennlinie mit ODER&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            HorizontalDivider(&#10;                modifier = Modifier.weight(1f),&#10;                thickness = 1.dp&#10;            )&#10;            Text(&#10;                text = &quot;ODER&quot;,&#10;                style = MaterialTheme.typography.labelMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            HorizontalDivider(&#10;                modifier = Modifier.weight(1f),&#10;                thickness = 1.dp&#10;            )&#10;        }&#10;&#10;        // Lobby beitreten&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby beitreten&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Gib den 6-stelligen Lobby-Code ein, den du von deinem Freund erhalten hast.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = uiState.joinCode,&#10;                    onValueChange = viewModel::updateJoinCode,&#10;                    label = { Text(&quot;Lobby-Code&quot;) },&#10;                    placeholder = { Text(&quot;ABC123&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isJoining,&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(&#10;                        capitalization = KeyboardCapitalization.Characters,&#10;                        imeAction = ImeAction.Done&#10;                    ),&#10;                    keyboardActions = KeyboardActions(&#10;                        onDone = {&#10;                            if (uiState.joinCode.length == 6) {&#10;                                keyboardController?.hide()&#10;                                viewModel.joinPrivateLobby(uiState.joinCode)&#10;                            }&#10;                        }&#10;                    ),&#10;                    supportingText = {&#10;                        Text(&quot;${uiState.joinCode.length}/6 Zeichen&quot;)&#10;                    }&#10;                )&#10;&#10;                Button(&#10;                    onClick = {&#10;                        keyboardController?.hide()&#10;                        viewModel.joinPrivateLobby(uiState.joinCode)&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isJoining &amp;&amp; uiState.joinCode.length == 6&#10;                ) {&#10;                    if (uiState.isJoining) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby beitreten&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        uiState.error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardCapitalization&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PrivateLobbyScreen(&#10;    onBackClick: () -&gt; Unit,&#10;    onLobbyCreated: (String) -&gt; Unit,&#10;    onLobbyJoined: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;&#10;    // Navigation bei erfolgreichem Lobby-Erstellen/Beitreten&#10;    LaunchedEffect(uiState.isLobbyCreated, uiState.createdLobbyCode) {&#10;        if (uiState.isLobbyCreated &amp;&amp; uiState.createdLobbyCode != null) {&#10;            onLobbyCreated(uiState.createdLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.isLobbyJoined, uiState.joinedLobbyCode) {&#10;        if (uiState.isLobbyJoined &amp;&amp; uiState.joinedLobbyCode != null) {&#10;            onLobbyJoined(uiState.joinedLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            // Navigation zum Spiel&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Lobby erstellen&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Neue Lobby erstellen&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Erstelle eine private Lobby und teile den Code mit deinem Freund.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                Button(&#10;                    onClick = { viewModel.createPrivateLobby() },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isCreating&#10;                ) {&#10;                    if (uiState.isCreating) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby erstellen&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Trennlinie mit ODER&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically,&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            HorizontalDivider(&#10;                modifier = Modifier.weight(1f),&#10;                thickness = 1.dp&#10;            )&#10;            Text(&#10;                text = &quot;ODER&quot;,&#10;                style = MaterialTheme.typography.labelMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;            )&#10;            HorizontalDivider(&#10;                modifier = Modifier.weight(1f),&#10;                thickness = 1.dp&#10;            )&#10;        }&#10;&#10;        // Lobby beitreten&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby beitreten&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Gib den 6-stelligen Lobby-Code ein, den du von deinem Freund erhalten hast.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = uiState.joinCode,&#10;                    onValueChange = viewModel::updateJoinCode,&#10;                    label = { Text(&quot;Lobby-Code&quot;) },&#10;                    placeholder = { Text(&quot;ABC123&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isJoining,&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(&#10;                        capitalization = KeyboardCapitalization.Characters,&#10;                        imeAction = ImeAction.Done&#10;                    ),&#10;                    keyboardActions = KeyboardActions(&#10;                        onDone = {&#10;                            if (uiState.joinCode.length == 6) {&#10;                                keyboardController?.hide()&#10;                                viewModel.joinPrivateLobby(uiState.joinCode)&#10;                            }&#10;                        }&#10;                    ),&#10;                    supportingText = {&#10;                        Text(&quot;${uiState.joinCode.length}/6 Zeichen&quot;)&#10;                    }&#10;                )&#10;&#10;                Button(&#10;                    onClick = {&#10;                        keyboardController?.hide()&#10;                        viewModel.joinPrivateLobby(uiState.joinCode)&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isJoining &amp;&amp; uiState.joinCode.length == 6&#10;                ) {&#10;                    if (uiState.isJoining) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby beitreten&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        uiState.error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/QuickMatchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/QuickMatchScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameDuration&#10;import app.chesspresso.viewmodel.QuickMatchViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun QuickMatchScreen(&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: QuickMatchViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val isWaiting by viewModel.isWaitingForMatch.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameDuration by remember { mutableStateOf(GameDuration.MEDIUM) }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Fehler anzeigen&#10;    error?.let { errorMessage -&gt;&#10;        LaunchedEffect(errorMessage) {&#10;            // Hier könnte ein Snackbar oder Dialog angezeigt werden&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        if (isWaiting) {&#10;            // Wartezustand&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(24.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                    Text(&#10;                        text = &quot;Suche nach Gegner...&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                    Text(&#10;                        text = &quot;Spielzeit: ${selectedGameDuration.displayName}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;&#10;                    Button(&#10;                        onClick = { viewModel.cancelSearch() },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Suche abbrechen&quot;)&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            // Spielzeit-Auswahl&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Spielzeit wählen:&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    GameDuration.entries.filter { it != GameDuration.UNLIMITED }.forEach { gameTime -&gt;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .selectable(&#10;                                    selected = selectedGameDuration == gameTime,&#10;                                    onClick = { selectedGameDuration = gameTime }&#10;                                )&#10;                                .padding(vertical = 8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            RadioButton(&#10;                                selected = selectedGameDuration == gameTime,&#10;                                onClick = { selectedGameDuration = gameTime }&#10;                            )&#10;                            Text(&#10;                                text = gameTime.displayName,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Fehleranzeige&#10;            error?.let { errorMessage -&gt;&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = errorMessage,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        color = MaterialTheme.colorScheme.onErrorContainer,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;&#10;            // Spiel starten Button&#10;            Button(&#10;                onClick = { viewModel.joinQuickMatch(selectedGameDuration) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = !uiState.isLoading&#10;            ) {&#10;                if (uiState.isLoading) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(20.dp),&#10;                        color = MaterialTheme.colorScheme.onPrimary&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                }&#10;                Text(&quot;Spiel suchen&quot;)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameDuration&#10;import app.chesspresso.viewmodel.QuickMatchViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun QuickMatchScreen(&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: QuickMatchViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val isWaiting by viewModel.isWaitingForMatch.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameDuration by remember { mutableStateOf(GameDuration.MEDIUM) }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Fehler anzeigen&#10;    error?.let { errorMessage -&gt;&#10;        LaunchedEffect(errorMessage) {&#10;            // Hier könnte ein Snackbar oder Dialog angezeigt werden&#10;            viewModel.clearError()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        if (isWaiting) {&#10;            // Wartezustand&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(24.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    CircularProgressIndicator()&#10;                    Text(&#10;                        text = &quot;Suche nach Gegner...&quot;,&#10;                        style = MaterialTheme.typography.bodyLarge&#10;                    )&#10;                    Text(&#10;                        text = &quot;Spielzeit: ${selectedGameDuration.displayName}&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    )&#10;&#10;                    Button(&#10;                        onClick = { viewModel.cancelSearch() },&#10;                        colors = ButtonDefaults.buttonColors(&#10;                            containerColor = MaterialTheme.colorScheme.error&#10;                        )&#10;                    ) {&#10;                        Text(&quot;Suche abbrechen&quot;)&#10;                    }&#10;                }&#10;            }&#10;        } else {&#10;            // Spielzeit-Auswahl&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Spielzeit wählen:&quot;,&#10;                        style = MaterialTheme.typography.titleMedium,&#10;                        fontWeight = FontWeight.Bold&#10;                    )&#10;&#10;                    GameDuration.entries.filter { it != GameDuration.UNLIMITED }.forEach { gameTime -&gt;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .selectable(&#10;                                    selected = selectedGameDuration == gameTime,&#10;                                    onClick = { selectedGameDuration = gameTime }&#10;                                )&#10;                                .padding(vertical = 8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            RadioButton(&#10;                                selected = selectedGameDuration == gameTime,&#10;                                onClick = { selectedGameDuration = gameTime }&#10;                            )&#10;                            Text(&#10;                                text = gameTime.displayName,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Fehleranzeige&#10;            error?.let { errorMessage -&gt;&#10;                Card(&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = MaterialTheme.colorScheme.errorContainer&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = errorMessage,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        color = MaterialTheme.colorScheme.onErrorContainer,&#10;                        style = MaterialTheme.typography.bodyMedium&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.weight(1f))&#10;&#10;            // Spiel starten Button&#10;            Button(&#10;                onClick = { viewModel.joinQuickMatch(selectedGameDuration) },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = !uiState.isLoading&#10;            ) {&#10;                if (uiState.isLoading) {&#10;                    CircularProgressIndicator(&#10;                        modifier = Modifier.size(20.dp),&#10;                        color = MaterialTheme.colorScheme.onPrimary&#10;                    )&#10;                    Spacer(modifier = Modifier.width(8.dp))&#10;                }&#10;                Text(&quot;Spiel suchen&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/PrivateLobbyViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/PrivateLobbyViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.lobby.ConfigureLobbyMessage&#10;import app.chesspresso.model.lobby.GameDuration&#10;import app.chesspresso.service.LobbyService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class PrivateLobbyViewModel @Inject constructor(&#10;    private val lobbyService: LobbyService&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(PrivateLobbyUiState())&#10;    val uiState: StateFlow&lt;PrivateLobbyUiState&gt; = _uiState.asStateFlow()&#10;&#10;    val currentLobby = lobbyService.currentLobby&#10;    val lobbyError = lobbyService.lobbyError&#10;    val gameStarted = lobbyService.gameStarted&#10;&#10;    fun createPrivateLobby() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isCreating = true, error = null)&#10;&#10;            lobbyService.createPrivateLobby()&#10;                .onSuccess { lobbyCode -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isCreating = false,&#10;                        createdLobbyCode = lobbyCode,&#10;                        isLobbyCreated = true&#10;                    )&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isCreating = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun joinPrivateLobby(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isJoining = true, error = null)&#10;&#10;            lobbyService.joinPrivateLobby(lobbyCode)&#10;                .onSuccess { code -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isJoining = false,&#10;                        joinedLobbyCode = code,&#10;                        isLobbyJoined = true&#10;                    )&#10;                    // Lobby-Info laden&#10;                    loadLobbyInfo(code)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isJoining = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun updateJoinCode(code: String) {&#10;        _uiState.value = _uiState.value.copy(joinCode = code.uppercase())&#10;    }&#10;&#10;    private fun loadLobbyInfo(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            lobbyService.getLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        viewModelScope.launch {&#10;            val lobbyCode = _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            lobbyCode?.let { code -&gt;&#10;                lobbyService.leaveLobby(code)&#10;                resetState()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        lobbyService.clearError()&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    fun clearGameStart() {&#10;        lobbyService.clearGameStart()&#10;    }&#10;&#10;    private fun resetState() {&#10;        _uiState.value = PrivateLobbyUiState()&#10;    }&#10;&#10;    fun configureAndStartGame(&#10;        lobbyCode: String,&#10;        gameDuration: GameDuration,&#10;        whitePlayer: String? = null,&#10;        blackPlayer: String? = null,&#10;        randomColors: Boolean = false&#10;    ) {&#10;        viewModelScope.launch {&#10;            val configMessage = ConfigureLobbyMessage(&#10;                lobbyCode = lobbyCode,&#10;                gameDuration = gameDuration,&#10;                whitePlayer = whitePlayer,&#10;                blackPlayer = blackPlayer,&#10;                randomColors = randomColors&#10;            )&#10;&#10;            // Für jetzt loggen wir die Konfiguration&#10;            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;Konfiguriere Spiel: $configMessage&quot;)&#10;        }&#10;    }&#10;&#10;    fun refreshLobbyInfo(lobbyCode: String? = null) {&#10;        viewModelScope.launch {&#10;            val codeToUse = lobbyCode ?: _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            codeToUse?.let { code -&gt;&#10;                lobbyService.getLobbyInfo(code)&#10;                    .onFailure { exception -&gt;&#10;                        Log.e(&quot;PrivateLobbyViewModel&quot;, &quot;Fehler beim Laden der Lobby-Info&quot;, exception)&#10;                    }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setReady(lobbyId: String, ready: Boolean) {&#10;        viewModelScope.launch {&#10;            lobbyService.setPlayerReady(lobbyId, ready)&#10;        }&#10;    }&#10;}&#10;&#10;data class PrivateLobbyUiState(&#10;    val joinCode: String = &quot;&quot;,&#10;    val error: String? = null,&#10;    val isCreating: Boolean = false,&#10;    val isJoining: Boolean = false,&#10;    val createdLobbyCode: String? = null,&#10;    val joinedLobbyCode: String? = null,&#10;    val isLobbyCreated: Boolean = false,&#10;    val isLobbyJoined: Boolean = false&#10;)&#10;" />
              <option name="updatedContent" value="package app.chesspresso.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.lobby.ConfigureLobbyMessage&#10;import app.chesspresso.model.lobby.GameDuration&#10;import app.chesspresso.service.LobbyService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class PrivateLobbyViewModel @Inject constructor(&#10;    private val lobbyService: LobbyService&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(PrivateLobbyUiState())&#10;    val uiState: StateFlow&lt;PrivateLobbyUiState&gt; = _uiState.asStateFlow()&#10;&#10;    val currentLobby = lobbyService.currentLobby&#10;    val lobbyError = lobbyService.lobbyError&#10;    val gameStarted = lobbyService.gameStarted&#10;&#10;    fun createPrivateLobby() {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isCreating = true, error = null)&#10;&#10;            lobbyService.createPrivateLobby()&#10;                .onSuccess { lobbyCode -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isCreating = false,&#10;                        createdLobbyCode = lobbyCode,&#10;                        isLobbyCreated = true&#10;                    )&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isCreating = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun joinPrivateLobby(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            _uiState.value = _uiState.value.copy(isJoining = true, error = null)&#10;&#10;            lobbyService.joinPrivateLobby(lobbyCode)&#10;                .onSuccess { code -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isJoining = false,&#10;                        joinedLobbyCode = code,&#10;                        isLobbyJoined = true&#10;                    )&#10;                    // Lobby-Info laden&#10;                    loadLobbyInfo(code)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = _uiState.value.copy(&#10;                        isJoining = false,&#10;                        error = exception.message&#10;                    )&#10;                }&#10;        }&#10;    }&#10;&#10;    fun updateJoinCode(code: String) {&#10;        _uiState.value = _uiState.value.copy(joinCode = code.uppercase())&#10;    }&#10;&#10;    private fun loadLobbyInfo(lobbyCode: String) {&#10;        viewModelScope.launch {&#10;            lobbyService.getLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        viewModelScope.launch {&#10;            val lobbyCode = _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            lobbyCode?.let { code -&gt;&#10;                lobbyService.leaveLobby(code)&#10;                resetState()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() {&#10;        lobbyService.clearError()&#10;        _uiState.value = _uiState.value.copy(error = null)&#10;    }&#10;&#10;    fun clearGameStart() {&#10;        lobbyService.clearGameStart()&#10;    }&#10;&#10;    private fun resetState() {&#10;        _uiState.value = PrivateLobbyUiState()&#10;    }&#10;&#10;    fun configureAndStartGame(&#10;        lobbyCode: String,&#10;        gameDuration: GameDuration,&#10;        whitePlayer: String? = null,&#10;        blackPlayer: String? = null,&#10;        randomColors: Boolean = false&#10;    ) {&#10;        viewModelScope.launch {&#10;            val configMessage = ConfigureLobbyMessage(&#10;                lobbyCode = lobbyCode,&#10;                gameDuration = gameDuration,&#10;                whitePlayer = whitePlayer,&#10;                blackPlayer = blackPlayer,&#10;                randomColors = randomColors&#10;            )&#10;&#10;            // Für jetzt loggen wir die Konfiguration&#10;            Log.d(&quot;PrivateLobbyViewModel&quot;, &quot;Konfiguriere Spiel: $configMessage&quot;)&#10;        }&#10;    }&#10;&#10;    fun refreshLobbyInfo(lobbyCode: String? = null) {&#10;        viewModelScope.launch {&#10;            val codeToUse = lobbyCode ?: _uiState.value.createdLobbyCode ?: _uiState.value.joinedLobbyCode&#10;            codeToUse?.let { code -&gt;&#10;                lobbyService.getLobbyInfo(code)&#10;                    .onFailure { exception -&gt;&#10;                        Log.e(&quot;PrivateLobbyViewModel&quot;, &quot;Fehler beim Laden der Lobby-Info&quot;, exception)&#10;                    }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setReady(lobbyId: String, ready: Boolean) {&#10;        viewModelScope.launch {&#10;            lobbyService.setPlayerReady(lobbyId, ready)&#10;        }&#10;    }&#10;}&#10;&#10;data class PrivateLobbyUiState(&#10;    val joinCode: String = &quot;&quot;,&#10;    val error: String? = null,&#10;    val isCreating: Boolean = false,&#10;    val isJoining: Boolean = false,&#10;    val createdLobbyCode: String? = null,&#10;    val joinedLobbyCode: String? = null,&#10;    val isLobbyCreated: Boolean = false,&#10;    val isLobbyJoined: Boolean = false&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>