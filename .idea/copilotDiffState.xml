<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Base URL für API konfigurierbar&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;    // DataStore für Token-Speicherung&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Base URL für API konfigurierbar&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;    // DataStore für Token-Speicherung&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/data/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/data/AuthRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import app.chesspresso.data.api.AuthApi as JwtAuthApi&#10;import app.chesspresso.data.models.LoginRequest as JwtLoginRequest&#10;import app.chesspresso.data.models.RegisterRequest as JwtRegisterRequest&#10;import app.chesspresso.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthRepository @Inject constructor(&#10;    private val api: AuthApi,&#10;    private val jwtApi: JwtAuthApi,&#10;    private val tokenStorage: TokenStorage,&#10;    private val context: Context&#10;) {&#10;&#10;    suspend fun login(username: String, password: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Attempting JWT login for user: $username&quot;)&#10;&#10;        // Zuerst JWT-Login versuchen&#10;        try {&#10;            val jwtRequest = JwtLoginRequest(username, password)&#10;            val jwtResponse = jwtApi.login(jwtRequest)&#10;&#10;            if (jwtResponse.isSuccessful &amp;&amp; jwtResponse.body() != null) {&#10;                val tokenResponse = jwtResponse.body()!!&#10;                tokenStorage.saveToken(tokenResponse.accessToken)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT login successful, token saved&quot;)&#10;&#10;                // Erstelle AuthResponse basierend auf JWT-Response (ohne altes System zu verwenden)&#10;                val authResponse = AuthResponse(&#10;                    playerId = &quot;jwt_user_&quot; + System.currentTimeMillis(), // Temporäre ID bis echte Stats verfügbar sind&#10;                    name = tokenResponse.username ?: username,&#10;                    email = &quot;&quot;, // Wird später über API geholt&#10;                    playedGames = 0,&#10;                    win = 0,&#10;                    draw = 0,&#10;                    lose = 0&#10;                )&#10;                &#10;                storePlayerData(authResponse)&#10;                storeCredentials(authResponse.name)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT Player data stored locally&quot;)&#10;                return authResponse&#10;            } else {&#10;                throw Exception(&quot;JWT Login failed: ${jwtResponse.message()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;JWT login failed, falling back to old system: ${e.message}&quot;)&#10;            // Fallback zum alten System nur wenn JWT komplett fehlschlägt&#10;            return processAuthRequest(&#10;                authAction = { api.login(LoginRequest(username, password)) },&#10;                actionType = &quot;login&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, password: String, email: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Attempting JWT registration for user: $username&quot;)&#10;&#10;        // Zuerst JWT-Registrierung versuchen&#10;        try {&#10;            val jwtRequest = JwtRegisterRequest(username, email, password)&#10;            val jwtResponse = jwtApi.register(jwtRequest)&#10;&#10;            if (jwtResponse.isSuccessful &amp;&amp; jwtResponse.body() != null) {&#10;                val tokenResponse = jwtResponse.body()!!&#10;                tokenStorage.saveToken(tokenResponse.accessToken)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT registration successful, token saved&quot;)&#10;&#10;                // Erstelle AuthResponse basierend auf JWT-Response (ohne altes System zu verwenden)&#10;                val authResponse = AuthResponse(&#10;                    playerId = &quot;jwt_user_&quot; + System.currentTimeMillis(), // Temporäre ID bis echte Stats verfügbar sind&#10;                    name = tokenResponse.username ?: username,&#10;                    email = email,&#10;                    playedGames = 0,&#10;                    win = 0,&#10;                    draw = 0,&#10;                    lose = 0&#10;                )&#10;                &#10;                storePlayerData(authResponse)&#10;                storeCredentials(authResponse.name)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT Player data stored locally&quot;)&#10;                return authResponse&#10;            } else {&#10;                throw Exception(&quot;JWT Registration failed: ${jwtResponse.message()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;JWT registration failed, falling back to old system: ${e.message}&quot;)&#10;            // Fallback zum alten System nur wenn JWT komplett fehlschlägt&#10;            return processAuthRequest(&#10;                authAction = { api.register(RegisterRequest(username, password, email)) },&#10;                actionType = &quot;registration&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private suspend fun processAuthRequest(&#10;        authAction: suspend () -&gt; AuthResponse,&#10;        actionType: String&#10;    ): AuthResponse {&#10;        try {&#10;            val response = authAction()&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Server response received successfully for $actionType&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player ID: ${response.playerId}&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player Name: ${response.name}&quot;)&#10;&#10;            storePlayerData(response)&#10;            storeCredentials(response.name) // Store username for auto-login&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player data stored locally&quot;)&#10;            return response&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Error during $actionType: ${e.message}&quot;, e)&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;            throw Exception(&quot;Server-Kommunikation fehlgeschlagen: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun storePlayerData(response: AuthResponse) {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit()&#10;            .putString(&quot;playerId&quot;, response.playerId)&#10;            .putString(&quot;playerName&quot;, response.name)&#10;            .putString(&quot;playerEmail&quot;, response.email)&#10;            .putInt(&quot;playedGames&quot;, response.playedGames)&#10;            .putInt(&quot;win&quot;, response.win)&#10;            .putInt(&quot;draw&quot;, response.draw)&#10;            .putInt(&quot;lose&quot;, response.lose)&#10;            .apply()&#10;    }&#10;&#10;    private fun storeCredentials(username: String) {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit()&#10;            .putString(&quot;storedUsername&quot;, username)&#10;            .putBoolean(&quot;isLoggedIn&quot;, true)&#10;            .apply()&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        val playerId = prefs.getString(&quot;playerId&quot;, null)&#10;        val playerName = prefs.getString(&quot;playerName&quot;, null)&#10;        val isLoggedIn = prefs.getBoolean(&quot;isLoggedIn&quot;, false)&#10;&#10;        return if (playerId != null &amp;&amp; playerName != null &amp;&amp; isLoggedIn) {&#10;            PlayerInfo(&#10;                playerId = playerId,&#10;                name = playerName,&#10;                email = prefs.getString(&quot;playerEmail&quot;, &quot;&quot;),&#10;                playedGames = prefs.getInt(&quot;playedGames&quot;, 0),&#10;                win = prefs.getInt(&quot;win&quot;, 0),&#10;                draw = prefs.getInt(&quot;draw&quot;, 0),&#10;                lose = prefs.getInt(&quot;lose&quot;, 0)&#10;            )&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun getStoredUsername(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;storedUsername&quot;, null)&#10;    }&#10;&#10;    fun clearStoredPlayerInfo() {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().clear().apply()&#10;&#10;        // Auch JWT Token löschen&#10;        kotlinx.coroutines.runBlocking {&#10;            tokenStorage.clearToken()&#10;        }&#10;    }&#10;&#10;    suspend fun getJwtToken(): String? {&#10;        return tokenStorage.getToken().first()&#10;    }&#10;&#10;    suspend fun isLoggedInWithJwt(): Boolean {&#10;        return getJwtToken() != null&#10;    }&#10;}&#10;&#10;data class PlayerInfo(&#10;    val playerId: String,&#10;    val name: String,&#10;    val email: String?,&#10;    val playedGames: Int,&#10;    val win: Int,&#10;    val draw: Int,&#10;    val lose: Int&#10;)&#10;" />
              <option name="updatedContent" value="package app.chesspresso.auth.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import app.chesspresso.data.api.AuthApi as JwtAuthApi&#10;import app.chesspresso.data.models.LoginRequest as JwtLoginRequest&#10;import app.chesspresso.data.models.RegisterRequest as JwtRegisterRequest&#10;import app.chesspresso.data.storage.TokenStorage&#10;import kotlinx.coroutines.flow.first&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class AuthRepository @Inject constructor(&#10;    private val api: AuthApi,&#10;    private val jwtApi: JwtAuthApi,&#10;    private val tokenStorage: TokenStorage,&#10;    private val context: Context&#10;) {&#10;&#10;    suspend fun login(username: String, password: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Attempting JWT login for user: $username&quot;)&#10;&#10;        // Zuerst JWT-Login versuchen&#10;        try {&#10;            val jwtRequest = JwtLoginRequest(username, password)&#10;            val jwtResponse = jwtApi.login(jwtRequest)&#10;&#10;            if (jwtResponse.isSuccessful &amp;&amp; jwtResponse.body() != null) {&#10;                val tokenResponse = jwtResponse.body()!!&#10;                tokenStorage.saveToken(tokenResponse.accessToken)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT login successful, token saved&quot;)&#10;&#10;                // Erstelle AuthResponse basierend auf JWT-Response (ohne altes System zu verwenden)&#10;                val authResponse = AuthResponse(&#10;                    playerId = &quot;jwt_user_&quot; + System.currentTimeMillis(), // Temporäre ID bis echte Stats verfügbar sind&#10;                    name = tokenResponse.username ?: username,&#10;                    email = &quot;&quot;, // Wird später über API geholt&#10;                    playedGames = 0,&#10;                    win = 0,&#10;                    draw = 0,&#10;                    lose = 0&#10;                )&#10;                &#10;                storePlayerData(authResponse)&#10;                storeCredentials(authResponse.name)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT Player data stored locally&quot;)&#10;                return authResponse&#10;            } else {&#10;                throw Exception(&quot;JWT Login failed: ${jwtResponse.message()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;JWT login failed, falling back to old system: ${e.message}&quot;)&#10;            // Fallback zum alten System nur wenn JWT komplett fehlschlägt&#10;            return processAuthRequest(&#10;                authAction = { api.login(LoginRequest(username, password)) },&#10;                actionType = &quot;login&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    suspend fun register(username: String, password: String, email: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Attempting JWT registration for user: $username&quot;)&#10;&#10;        // Zuerst JWT-Registrierung versuchen&#10;        try {&#10;            val jwtRequest = JwtRegisterRequest(username, email, password)&#10;            val jwtResponse = jwtApi.register(jwtRequest)&#10;&#10;            if (jwtResponse.isSuccessful &amp;&amp; jwtResponse.body() != null) {&#10;                val tokenResponse = jwtResponse.body()!!&#10;                tokenStorage.saveToken(tokenResponse.accessToken)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT registration successful, token saved&quot;)&#10;&#10;                // Erstelle AuthResponse basierend auf JWT-Response (ohne altes System zu verwenden)&#10;                val authResponse = AuthResponse(&#10;                    playerId = &quot;jwt_user_&quot; + System.currentTimeMillis(), // Temporäre ID bis echte Stats verfügbar sind&#10;                    name = tokenResponse.username ?: username,&#10;                    email = email,&#10;                    playedGames = 0,&#10;                    win = 0,&#10;                    draw = 0,&#10;                    lose = 0&#10;                )&#10;                &#10;                storePlayerData(authResponse)&#10;                storeCredentials(authResponse.name)&#10;                Log.d(&quot;AuthRepository&quot;, &quot;JWT Player data stored locally&quot;)&#10;                return authResponse&#10;            } else {&#10;                throw Exception(&quot;JWT Registration failed: ${jwtResponse.message()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;JWT registration failed, falling back to old system: ${e.message}&quot;)&#10;            // Fallback zum alten System nur wenn JWT komplett fehlschlägt&#10;            return processAuthRequest(&#10;                authAction = { api.register(RegisterRequest(username, password, email)) },&#10;                actionType = &quot;registration&quot;&#10;            )&#10;        }&#10;    }&#10;&#10;    private suspend fun processAuthRequest(&#10;        authAction: suspend () -&gt; AuthResponse,&#10;        actionType: String&#10;    ): AuthResponse {&#10;        try {&#10;            val response = authAction()&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Server response received successfully for $actionType&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player ID: ${response.playerId}&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player Name: ${response.name}&quot;)&#10;&#10;            storePlayerData(response)&#10;            storeCredentials(response.name) // Store username for auto-login&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player data stored locally&quot;)&#10;            return response&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Error during $actionType: ${e.message}&quot;, e)&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;            throw Exception(&quot;Server-Kommunikation fehlgeschlagen: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun storePlayerData(response: AuthResponse) {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit()&#10;            .putString(&quot;playerId&quot;, response.playerId)&#10;            .putString(&quot;playerName&quot;, response.name)&#10;            .putString(&quot;playerEmail&quot;, response.email)&#10;            .putInt(&quot;playedGames&quot;, response.playedGames)&#10;            .putInt(&quot;win&quot;, response.win)&#10;            .putInt(&quot;draw&quot;, response.draw)&#10;            .putInt(&quot;lose&quot;, response.lose)&#10;            .apply()&#10;    }&#10;&#10;    private fun storeCredentials(username: String) {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit()&#10;            .putString(&quot;storedUsername&quot;, username)&#10;            .putBoolean(&quot;isLoggedIn&quot;, true)&#10;            .apply()&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        val playerId = prefs.getString(&quot;playerId&quot;, null)&#10;        val playerName = prefs.getString(&quot;playerName&quot;, null)&#10;        val isLoggedIn = prefs.getBoolean(&quot;isLoggedIn&quot;, false)&#10;&#10;        return if (playerId != null &amp;&amp; playerName != null &amp;&amp; isLoggedIn) {&#10;            PlayerInfo(&#10;                playerId = playerId,&#10;                name = playerName,&#10;                email = prefs.getString(&quot;playerEmail&quot;, &quot;&quot;),&#10;                playedGames = prefs.getInt(&quot;playedGames&quot;, 0),&#10;                win = prefs.getInt(&quot;win&quot;, 0),&#10;                draw = prefs.getInt(&quot;draw&quot;, 0),&#10;                lose = prefs.getInt(&quot;lose&quot;, 0)&#10;            )&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun getStoredUsername(): String? {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        return prefs.getString(&quot;storedUsername&quot;, null)&#10;    }&#10;&#10;    fun clearStoredPlayerInfo() {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().clear().apply()&#10;&#10;        // Auch JWT Token löschen&#10;        kotlinx.coroutines.runBlocking {&#10;            tokenStorage.clearToken()&#10;        }&#10;    }&#10;&#10;    suspend fun getJwtToken(): String? {&#10;        return tokenStorage.getToken().first()&#10;    }&#10;&#10;    suspend fun isLoggedInWithJwt(): Boolean {&#10;        return getJwtToken() != null&#10;    }&#10;}&#10;&#10;data class PlayerInfo(&#10;    val playerId: String,&#10;    val name: String,&#10;    val email: String?,&#10;    val playedGames: Int,&#10;    val win: Int,&#10;    val draw: Int,&#10;    val lose: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/models/AuthModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/models/AuthModels.kt" />
              <option name="originalContent" value="package app.chesspresso.data.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;data class RegisterRequest(&#10;    val username: String,&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class LoginRequest(&#10;    val login: String,&#10;    val password: String&#10;)&#10;&#10;data class TokenResponse(&#10;    @SerializedName(&quot;accessToken&quot;)&#10;    val accessToken: String,&#10;    @SerializedName(&quot;tokenType&quot;)&#10;    val tokenType: String? = null,&#10;    @SerializedName(&quot;expiresIn&quot;)&#10;    val expiresIn: Long? = null,&#10;    @SerializedName(&quot;username&quot;)&#10;    val username: String? = null&#10;)&#10;&#10;data class EventRequest(&#10;    val type: String,&#10;    val payload: Map&lt;String, Any&gt;&#10;)&#10;&#10;data class StatsReportRequest(&#10;    val result: String // &quot;WIN&quot; | &quot;LOSS&quot; | &quot;DRAW&quot;&#10;)&#10;&#10;data class StatsResponse(&#10;    val wins: Int,&#10;    val losses: Int,&#10;    val draws: Int&#10;)&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.models&#10;&#10;import com.google.gson.annotations.SerializedName&#10;&#10;data class RegisterRequest(&#10;    val username: String,&#10;    val email: String,&#10;    val password: String&#10;)&#10;&#10;data class LoginRequest(&#10;    val login: String,&#10;    val password: String&#10;)&#10;&#10;data class TokenResponse(&#10;    @SerializedName(&quot;accessToken&quot;)&#10;    val accessToken: String,&#10;    @SerializedName(&quot;tokenType&quot;)&#10;    val tokenType: String? = null,&#10;    @SerializedName(&quot;expiresIn&quot;)&#10;    val expiresIn: Long? = null,&#10;    @SerializedName(&quot;username&quot;)&#10;    val username: String? = null&#10;)&#10;&#10;data class EventRequest(&#10;    val type: String,&#10;    val payload: Map&lt;String, Any&gt;&#10;)&#10;&#10;data class StatsReportRequest(&#10;    val result: String // &quot;WIN&quot; | &quot;LOSS&quot; | &quot;DRAW&quot;&#10;)&#10;&#10;data class StatsResponse(&#10;    val wins: Int,&#10;    val losses: Int,&#10;    val draws: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>