<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/ChessGameScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/ChessGameScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.board.Board&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;import androidx.navigation.NavHostController&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChessGameScreen(&#10;    gameStartResponse: GameStartResponse,&#10;    viewModel: ChessGameViewModel,&#10;    playerId: String,&#10;    navController: NavHostController,&#10;    paddingValues: androidx.compose.foundation.layout.PaddingValues = androidx.compose.foundation.layout.PaddingValues(0.dp),&#10;    onGameEnd: (() -&gt; Unit)? = null&#10;) {&#10;    val board = remember { Board() }&#10;&#10;    // Collect ViewModel states&#10;    val currentBoard by viewModel.currentBoard.collectAsState()&#10;    val currentPlayer by viewModel.currentPlayer.collectAsState()&#10;    val currentGameState by viewModel.currentGameState.collectAsState()&#10;    val whiteTime by viewModel.whiteTime.collectAsState()&#10;    val blackTime by viewModel.blackTime.collectAsState()&#10;    val myColor by viewModel.myColor.collectAsState()&#10;    val possibleMoves by viewModel.possibleMoves.collectAsState()&#10;    val promotionRequest by viewModel.promotionRequest.collectAsState()&#10;    val gameEndEvent by viewModel.gameEndEvent.collectAsState()&#10;    val fieldHighlights by viewModel.fieldHighlights.collectAsState()&#10;    val pendingRemisRequest by viewModel.pendingRemisRequest.collectAsState()&#10;&#10;    // Determine which board state to use (current or initial)&#10;    val boardToDisplay = currentBoard.ifEmpty { gameStartResponse.board }&#10;    val activePlayer = currentPlayer ?: TeamColor.WHITE&#10;&#10;    // Neue Zustände für das Game Over Dialog&#10;    var showGameOverDialog by remember { mutableStateOf(false) }&#10;    var gameEndResult by remember { mutableStateOf&lt;app.chesspresso.model.lobby.GameEndResponse?&gt;(null) }&#10;&#10;    // Spielende erkennen&#10;    LaunchedEffect(gameEndEvent) {&#10;        if (gameEndEvent != null) {&#10;            onGameEnd?.invoke()&#10;            gameEndResult = gameEndEvent&#10;            showGameOverDialog = true&#10;        } else {&#10;            // Overlay ausblenden, wenn ein neues Spiel startet&#10;            showGameOverDialog = false&#10;            gameEndResult = null&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 8.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Game Over UI direkt im Layout anzeigen&#10;            if (showGameOverDialog &amp;&amp; gameEndResult != null) {&#10;                GameOverResultInfo(gameEndResult!!, playerId)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;            // Spieler und Uhren&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(IntrinsicSize.Min)&#10;                    .padding(horizontal = 8.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (myColor == TeamColor.WHITE) {&#10;                    // Eigener Spieler (Weiß) links&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .fillMaxWidth()&#10;                            .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.whitePlayer,&#10;                            remainingTime = formatSecondsToTimeString(whiteTime),&#10;                            isActive = activePlayer == TeamColor.WHITE&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                    }&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;                    // Gegner (Schwarz) rechts&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.blackPlayer,&#10;                            remainingTime = formatSecondsToTimeString(blackTime),&#10;                            isActive = activePlayer == TeamColor.BLACK&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                    }&#10;                } else if (myColor == TeamColor.BLACK) {&#10;                    // Eigener Spieler (Schwarz) links&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.blackPlayer,&#10;                            remainingTime = formatSecondsToTimeString(blackTime),&#10;                            isActive = activePlayer == TeamColor.BLACK&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                    }&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;                    // Gegner (Weiß) rechts&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .fillMaxWidth()&#10;                            .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.whitePlayer,&#10;                            remainingTime = formatSecondsToTimeString(whiteTime),&#10;                            isActive = activePlayer == TeamColor.WHITE&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Schachbrett - verwende den aktuellen Spielbrett-Zustand&#10;            board.BoardContent(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                boardState = boardToDisplay,&#10;                lobbyId = gameStartResponse.lobbyId,&#10;                onPositionRequest = { positionRequest -&gt;&#10;                    viewModel.sendPositionRequest(&#10;                        gameStartResponse.lobbyId,&#10;                        positionRequest.position&#10;                    )&#10;                },&#10;                isFlipped = (myColor == TeamColor.BLACK),&#10;                possibleMoves = if (myColor == currentPlayer) possibleMoves else emptyList(),&#10;                nextPlayer = currentPlayer ?: TeamColor.WHITE,&#10;                fieldHighlights = fieldHighlights, // NEU: Markierungen für Schachmatt&#10;                myColor = myColor,&#10;                isCheck = currentGameState?.isCheck ?: &quot;&quot;,&#10;                onGameMove = { from, to -&gt;&#10;                    val color = myColor&#10;                    if (color != null) {&#10;                        viewModel.sendGameMoveMessage(&#10;                            gameStartResponse.lobbyId,&#10;                            from,&#10;                            to,&#10;                            color&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // --- Promotion Auswahl unter dem Brett ---&#10;            if (promotionRequest != null &amp;&amp; promotionRequest!!.activeTeam == myColor) {&#10;                val promotionPosition = promotionRequest!!.position&#10;                val promotionFrom = promotionRequest!!.from&#10;                val promotionOptions = listOf(&#10;                    app.chesspresso.model.PieceType.QUEEN,&#10;                    app.chesspresso.model.PieceType.ROOK,&#10;                    app.chesspresso.model.PieceType.BISHOP,&#10;                    app.chesspresso.model.PieceType.KNIGHT&#10;                )&#10;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 8.dp),&#10;                    elevation = CardDefaults.cardElevation(4.dp)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Text(&quot;Wähle die Figur für die Umwandlung:&quot;, style = MaterialTheme.typography.titleMedium)&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .heightIn(min = 48.dp)&#10;                        ) {&#10;                            promotionOptions.forEach { pieceType -&gt;&#10;                                val drawableRes = when (pieceType) {&#10;                                    app.chesspresso.model.PieceType.QUEEN -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.queen_white else app.chesspresso.R.drawable.queen_black&#10;                                    app.chesspresso.model.PieceType.ROOK -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.rook_white else app.chesspresso.R.drawable.rook_black&#10;                                    app.chesspresso.model.PieceType.BISHOP -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.bishop_white else app.chesspresso.R.drawable.bishop_black&#10;                                    app.chesspresso.model.PieceType.KNIGHT -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.knight_white else app.chesspresso.R.drawable.knight_black&#10;                                    else -&gt; 0&#10;                                }&#10;                                if (drawableRes != 0) {&#10;                                    Image(&#10;                                        painter = painterResource(id = drawableRes),&#10;                                        contentDescription = pieceType.name,&#10;                                        modifier = Modifier&#10;                                            .size(48.dp)&#10;                                            .padding(horizontal = 6.dp)&#10;                                            .clickable {&#10;                                                // Sende jetzt eine MoveMessage mit promotedPiece&#10;                                                viewModel.sendGameMoveMessage(&#10;                                                    gameStartResponse.lobbyId,&#10;                                                    promotionFrom,&#10;                                                    promotionPosition,&#10;                                                    myColor!!,&#10;                                                    pieceType&#10;                                                )&#10;                                            }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // Remis-Anfrage-Dialog&#10;            if (pendingRemisRequest != null) {&#10;                androidx.compose.material3.AlertDialog(&#10;                    onDismissRequest = { viewModel.respondToRemisRequest(false) },&#10;                    title = { Text(&quot;Unentschieden?&quot;) },&#10;                    text = { Text(&quot;Dein Gegner bietet ein Remis an. Möchtest du das Remis annehmen?&quot;) },&#10;                    confirmButton = {&#10;                        Button(onClick = { viewModel.respondToRemisRequest(true) }) {&#10;                            Text(&quot;Annehmen&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        Button(onClick = { viewModel.respondToRemisRequest(false) }) {&#10;                            Text(&quot;Ablehnen&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Am unteren Rand die Buttons anzeigen, falls Game Over&#10;            if (showGameOverDialog &amp;&amp; gameEndResult != null) {&#10;                Spacer(modifier = Modifier.weight(1f))&#10;                GameOverActions(gameEndResult!!, viewModel, navController = navController)&#10;                // Rematch-Dialoge zentral anzeigen&#10;                RematchDialogsHandler(viewModel, gameEndResult!!, navController)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PlayerClock(&#10;    playerName: String,&#10;    remainingTime: String,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            Text(&#10;                text = remainingTime,&#10;                style = MaterialTheme.typography.headlineLarge,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun pieceToUnicode(piece: app.chesspresso.model.game.PieceInfo): String {&#10;    return when (piece.type.name) {&#10;        &quot;KING&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;        &quot;QUEEN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;        &quot;ROOK&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;        &quot;BISHOP&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;        &quot;KNIGHT&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;        &quot;PAWN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;        else -&gt; &quot;?&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CapturedPieces(captured: List&lt;app.chesspresso.model.game.PieceInfo&gt;) {&#10;    if (captured.isEmpty()) return&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(50.dp)&#10;    ) {&#10;        LazyRow(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            items(captured) { piece -&gt;&#10;                Text(text = pieceToUnicode(piece), fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatSecondsToTimeString(seconds: Int): String {&#10;    val min = seconds / 60&#10;    val sec = seconds % 60&#10;    return &quot;%02d:%02d&quot;.format(min, sec)&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.IntrinsicSize&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.heightIn&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.alpha&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.board.Board&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;import androidx.navigation.NavHostController&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ChessGameScreen(&#10;    gameStartResponse: GameStartResponse,&#10;    viewModel: ChessGameViewModel,&#10;    playerId: String,&#10;    navController: NavHostController,&#10;    paddingValues: androidx.compose.foundation.layout.PaddingValues = androidx.compose.foundation.layout.PaddingValues(0.dp),&#10;    onGameEnd: (() -&gt; Unit)? = null&#10;) {&#10;    val board = remember { Board() }&#10;&#10;    // Collect ViewModel states&#10;    val currentBoard by viewModel.currentBoard.collectAsState()&#10;    val currentPlayer by viewModel.currentPlayer.collectAsState()&#10;    val currentGameState by viewModel.currentGameState.collectAsState()&#10;    val whiteTime by viewModel.whiteTime.collectAsState()&#10;    val blackTime by viewModel.blackTime.collectAsState()&#10;    val myColor by viewModel.myColor.collectAsState()&#10;    val possibleMoves by viewModel.possibleMoves.collectAsState()&#10;    val promotionRequest by viewModel.promotionRequest.collectAsState()&#10;    val gameEndEvent by viewModel.gameEndEvent.collectAsState()&#10;    val fieldHighlights by viewModel.fieldHighlights.collectAsState()&#10;    val pendingRemisRequest by viewModel.pendingRemisRequest.collectAsState()&#10;&#10;    // Determine which board state to use (current or initial)&#10;    val boardToDisplay = currentBoard.ifEmpty { gameStartResponse.board }&#10;    val activePlayer = currentPlayer ?: TeamColor.WHITE&#10;&#10;    // Neue Zustände für das Game Over Dialog&#10;    var showGameOverDialog by remember { mutableStateOf(false) }&#10;    var gameEndResult by remember { mutableStateOf&lt;app.chesspresso.model.lobby.GameEndResponse?&gt;(null) }&#10;&#10;    // Spielende erkennen&#10;    LaunchedEffect(gameEndEvent) {&#10;        if (gameEndEvent != null) {&#10;            onGameEnd?.invoke()&#10;            gameEndResult = gameEndEvent&#10;            showGameOverDialog = true&#10;        } else {&#10;            // Overlay ausblenden, wenn ein neues Spiel startet&#10;            showGameOverDialog = false&#10;            gameEndResult = null&#10;        }&#10;    }&#10;&#10;    Box(modifier = Modifier.fillMaxSize()) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(paddingValues)&#10;                .padding(horizontal = 8.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            // Game Over UI direkt im Layout anzeigen&#10;            if (showGameOverDialog &amp;&amp; gameEndResult != null) {&#10;                GameOverResultInfo(gameEndResult!!, playerId)&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;            }&#10;            // Spieler und Uhren&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(IntrinsicSize.Min)&#10;                    .padding(horizontal = 8.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                if (myColor == TeamColor.WHITE) {&#10;                    // Eigener Spieler (Weiß) links&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .fillMaxWidth()&#10;                            .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.whitePlayer,&#10;                            remainingTime = formatSecondsToTimeString(whiteTime),&#10;                            isActive = activePlayer == TeamColor.WHITE&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                    }&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;                    // Gegner (Schwarz) rechts&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.blackPlayer,&#10;                            remainingTime = formatSecondsToTimeString(blackTime),&#10;                            isActive = activePlayer == TeamColor.BLACK&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                    }&#10;                } else if (myColor == TeamColor.BLACK) {&#10;                    // Eigener Spieler (Schwarz) links&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .alpha(if (activePlayer == TeamColor.BLACK) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.blackPlayer,&#10;                            remainingTime = formatSecondsToTimeString(blackTime),&#10;                            isActive = activePlayer == TeamColor.BLACK&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedWhitePieces.collectAsState().value)&#10;                    }&#10;                    Spacer(modifier = Modifier.width(16.dp))&#10;                    // Gegner (Weiß) rechts&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .weight(1f)&#10;                            .fillMaxWidth()&#10;                            .alpha(if (activePlayer == TeamColor.WHITE) 1f else 0.4f),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        PlayerClock(&#10;                            playerName = gameStartResponse.whitePlayer,&#10;                            remainingTime = formatSecondsToTimeString(whiteTime),&#10;                            isActive = activePlayer == TeamColor.WHITE&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CapturedPieces(captured = viewModel.capturedBlackPieces.collectAsState().value)&#10;                    }&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;            // Schachbrett - verwende den aktuellen Spielbrett-Zustand&#10;            board.BoardContent(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(horizontal = 8.dp),&#10;                boardState = boardToDisplay,&#10;                lobbyId = gameStartResponse.lobbyId,&#10;                onPositionRequest = { positionRequest -&gt;&#10;                    viewModel.sendPositionRequest(&#10;                        gameStartResponse.lobbyId,&#10;                        positionRequest.position&#10;                    )&#10;                },&#10;                isFlipped = (myColor == TeamColor.BLACK),&#10;                possibleMoves = if (myColor == currentPlayer) possibleMoves else emptyList(),&#10;                nextPlayer = currentPlayer ?: TeamColor.WHITE,&#10;                fieldHighlights = fieldHighlights, // NEU: Markierungen für Schachmatt&#10;                myColor = myColor,&#10;                isCheck = currentGameState?.isCheck ?: &quot;&quot;,&#10;                onGameMove = { from, to -&gt;&#10;                    val color = myColor&#10;                    if (color != null) {&#10;                        viewModel.sendGameMoveMessage(&#10;                            gameStartResponse.lobbyId,&#10;                            from,&#10;                            to,&#10;                            color&#10;                        )&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(12.dp))&#10;&#10;            // --- Promotion Auswahl unter dem Brett ---&#10;            if (promotionRequest != null &amp;&amp; promotionRequest!!.activeTeam == myColor) {&#10;                val promotionPosition = promotionRequest!!.position&#10;                val promotionFrom = promotionRequest!!.from&#10;                val promotionOptions = listOf(&#10;                    app.chesspresso.model.PieceType.QUEEN,&#10;                    app.chesspresso.model.PieceType.ROOK,&#10;                    app.chesspresso.model.PieceType.BISHOP,&#10;                    app.chesspresso.model.PieceType.KNIGHT&#10;                )&#10;&#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 8.dp),&#10;                    elevation = CardDefaults.cardElevation(4.dp)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Text(&quot;Wähle die Figur für die Umwandlung:&quot;, style = MaterialTheme.typography.titleMedium)&#10;                        Spacer(modifier = Modifier.height(4.dp))&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .heightIn(min = 48.dp)&#10;                        ) {&#10;                            promotionOptions.forEach { pieceType -&gt;&#10;                                val drawableRes = when (pieceType) {&#10;                                    app.chesspresso.model.PieceType.QUEEN -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.queen_white else app.chesspresso.R.drawable.queen_black&#10;                                    app.chesspresso.model.PieceType.ROOK -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.rook_white else app.chesspresso.R.drawable.rook_black&#10;                                    app.chesspresso.model.PieceType.BISHOP -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.bishop_white else app.chesspresso.R.drawable.bishop_black&#10;                                    app.chesspresso.model.PieceType.KNIGHT -&gt; if (myColor == TeamColor.WHITE) app.chesspresso.R.drawable.knight_white else app.chesspresso.R.drawable.knight_black&#10;                                    else -&gt; 0&#10;                                }&#10;                                if (drawableRes != 0) {&#10;                                    Image(&#10;                                        painter = painterResource(id = drawableRes),&#10;                                        contentDescription = pieceType.name,&#10;                                        modifier = Modifier&#10;                                            .size(48.dp)&#10;                                            .padding(horizontal = 6.dp)&#10;                                            .clickable {&#10;                                                // Sende jetzt eine MoveMessage mit promotedPiece&#10;                                                viewModel.sendGameMoveMessage(&#10;                                                    gameStartResponse.lobbyId,&#10;                                                    promotionFrom,&#10;                                                    promotionPosition,&#10;                                                    myColor!!,&#10;                                                    pieceType&#10;                                                )&#10;                                            }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            // Remis-Anfrage-Dialog&#10;            if (pendingRemisRequest != null) {&#10;                androidx.compose.material3.AlertDialog(&#10;                    onDismissRequest = { viewModel.respondToRemisRequest(false) },&#10;                    title = { Text(&quot;Unentschieden?&quot;) },&#10;                    text = { Text(&quot;Dein Gegner bietet ein Remis an. Möchtest du das Remis annehmen?&quot;) },&#10;                    confirmButton = {&#10;                        Button(onClick = { viewModel.respondToRemisRequest(true) }) {&#10;                            Text(&quot;Annehmen&quot;)&#10;                        }&#10;                    },&#10;                    dismissButton = {&#10;                        Button(onClick = { viewModel.respondToRemisRequest(false) }) {&#10;                            Text(&quot;Ablehnen&quot;)&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Am unteren Rand die Buttons anzeigen, falls Game Over&#10;            if (showGameOverDialog &amp;&amp; gameEndResult != null) {&#10;                Spacer(modifier = Modifier.weight(1f))&#10;                GameOverActions(gameEndResult!!, viewModel, navController = navController)&#10;                // Rematch-Dialoge zentral anzeigen&#10;                RematchDialogsHandler(viewModel, gameEndResult!!, navController)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun PlayerClock(&#10;    playerName: String,&#10;    remainingTime: String,&#10;    isActive: Boolean&#10;) {&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .padding(16.dp)&#10;                .fillMaxWidth(),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            Text(&#10;                text = playerName,&#10;                style = MaterialTheme.typography.titleMedium,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;            Text(&#10;                text = remainingTime,&#10;                style = MaterialTheme.typography.headlineLarge,&#10;                color = if (isActive)&#10;                    MaterialTheme.colorScheme.primary&#10;                else&#10;                    MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;fun pieceToUnicode(piece: app.chesspresso.model.game.PieceInfo): String {&#10;    return when (piece.type.name) {&#10;        &quot;KING&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;        &quot;QUEEN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;        &quot;ROOK&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;        &quot;BISHOP&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;        &quot;KNIGHT&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;        &quot;PAWN&quot; -&gt; if (piece.color.name == &quot;WHITE&quot;) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;        else -&gt; &quot;?&quot;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CapturedPieces(captured: List&lt;app.chesspresso.model.game.PieceInfo&gt;) {&#10;    if (captured.isEmpty()) return&#10;    Card(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(50.dp)&#10;    ) {&#10;        LazyRow(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            items(captured) { piece -&gt;&#10;                Text(text = pieceToUnicode(piece), fontSize = 28.sp)&#10;                Spacer(modifier = Modifier.width(4.dp))&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;fun formatSecondsToTimeString(seconds: Int): String {&#10;    val min = seconds / 60&#10;    val sec = seconds % 60&#10;    return &quot;%02d:%02d&quot;.format(min, sec)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/GameOverScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/game/GameOverScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.screens.main.NavRoutes&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;import app.chesspresso.viewmodel.RematchDialogState&#10;&#10;@Composable&#10;fun RematchDialog(&#10;    show: Boolean,&#10;    onDismissRequest: () -&gt; Unit,&#10;    title: String,&#10;    text: String,&#10;    confirmButtonText: String,&#10;    onConfirm: () -&gt; Unit,&#10;    dismissButtonText: String? = null,&#10;    onDismiss: (() -&gt; Unit)? = null&#10;) {&#10;    if (show) {&#10;        AlertDialog(&#10;            onDismissRequest = onDismissRequest,&#10;            title = { Text(title) },&#10;            text = { Text(text) },&#10;            confirmButton = {&#10;                TextButton(onClick = onConfirm) {&#10;                    Text(confirmButtonText)&#10;                }&#10;            },&#10;            dismissButton = if (dismissButtonText != null &amp;&amp; onDismiss != null) {&#10;                {&#10;                    TextButton(onClick = onDismiss) {&#10;                        Text(dismissButtonText)&#10;                    }&#10;                }&#10;            } else null&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RematchDialogsHandler(viewModel: ChessGameViewModel, gameEndResponse: GameEndResponse, navController: NavHostController?) {&#10;    val rematchDialogState = viewModel.rematchDialogState.collectAsStateWithLifecycle().value&#10;    when (rematchDialogState) {&#10;        is RematchDialogState.WaitingForResponse -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch angefragt&quot;,&#10;                text = &quot;Warte auf Antwort des Gegners...&quot;,&#10;                confirmButtonText = &quot;Abbrechen&quot;,&#10;                onConfirm = {&#10;                    viewModel.clearRematchDialog() }&#10;            )&#10;        }&#10;        is RematchDialogState.OfferReceived -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch erhalten&quot;,&#10;                text = &quot;Dein Gegner möchte ein Rematch. Annehmen?&quot;,&#10;                confirmButtonText = &quot;Annehmen&quot;,&#10;                onConfirm = { viewModel.respondRematch(true) },&#10;                dismissButtonText = &quot;Ablehnen&quot;,&#10;                onDismiss = { viewModel.respondRematch(false) }&#10;            )&#10;        }&#10;        is RematchDialogState.WaitingForResult -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Antwort gesendet&quot;,&#10;                text = &quot;Warte auf Bestätigung...&quot;,&#10;                confirmButtonText = &quot;Schließen&quot;,&#10;                onConfirm = {&#10;                    viewModel.clearRematchDialog() }&#10;            )&#10;        }&#10;        is RematchDialogState.Accepted -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch angenommen&quot;,&#10;                text = &quot;Das Rematch startet jetzt!&quot;,&#10;                confirmButtonText = &quot;OK&quot;,&#10;                onConfirm = {&#10;                    viewModel.clearRematchDialog()&#10;                    val isPrivate = gameEndResponse.lobbyId.length &lt;= 6&#10;                    if (isPrivate) {&#10;                        if(viewModel.rematchResult.value == null) {&#10;                            android.util.Log.e(&#10;                                &quot;GameOverScreen&quot;,&#10;                                &quot;rematchResult ist null, kann nicht navigieren&quot;&#10;                            )&#10;                            return@RematchDialog&#10;                        }&#10;                        val isCreator = viewModel.myColor.value == TeamColor.WHITE&#10;                        navController!!.navigate(&quot;lobby_waiting/${viewModel.rematchResult.value!!.newlobbyid}/$isCreator&quot;) {&#10;                            popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                        }&#10;                    } else {&#10;                        navController!!.navigate(&quot;game/${gameEndResponse.lobbyId}&quot;) {&#10;                            popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        is RematchDialogState.Declined -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch abgelehnt&quot;,&#10;                text = &quot;Der Gegner hat das Rematch abgelehnt.&quot;,&#10;                confirmButtonText = &quot;OK&quot;,&#10;                onConfirm = {&#10;                    viewModel.resetGameState()&#10;                    viewModel.clearRematchDialog()&#10;                    navController!!.navigate(NavRoutes.HOME) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        else -&gt; null&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameOverResultInfo(&#10;    gameEndResponse: GameEndResponse,&#10;    playerId: String&#10;) {&#10;    val ergebnisText = when {&#10;        gameEndResponse.draw -&gt; &quot;Unentschieden&quot;&#10;        playerId == gameEndResponse.winner -&gt; &quot;Sieg&quot;&#10;        playerId == gameEndResponse.loser -&gt; &quot;Niederlage&quot;&#10;        else -&gt; &quot;Unbekannt&quot;&#10;    }&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = ergebnisText,&#10;            style = MaterialTheme.typography.displayMedium,&#10;            color = when (ergebnisText) {&#10;                &quot;Sieg&quot; -&gt; Color(0xFF4CAF50)&#10;                &quot;Niederlage&quot; -&gt; Color(0xFFF44336)&#10;                &quot;Unentschieden&quot; -&gt; Color(0xFF9E9E9E)&#10;                else -&gt; MaterialTheme.colorScheme.onSurface&#10;            },&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;        Text(&#10;            text = if (playerId == gameEndResponse.winner) &quot;Du hast gewonnen!&quot; else if (playerId == gameEndResponse.loser) &quot;Du hast verloren.&quot; else &quot;&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameOverActions(&#10;    gameEndResponse: GameEndResponse,&#10;    viewModel: ChessGameViewModel,&#10;    navController: NavHostController? = null&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalArrangement = Arrangement.Center,&#10;    ) {&#10;        Button(onClick = { viewModel.requestRematch() }) {&#10;            Text(&quot;Rematch&quot;)&#10;        }&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;        Button(onClick = {&#10;            viewModel.closeLobby(gameEndResponse.lobbyId)&#10;            navController?.navigate(NavRoutes.HOME) {&#10;                popUpTo(0) { inclusive = true }&#10;            }&#10;        }) {&#10;            Text(&quot;Zurück&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.game&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.screens.main.NavRoutes&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;import app.chesspresso.viewmodel.RematchDialogState&#10;&#10;@Composable&#10;fun RematchDialog(&#10;    show: Boolean,&#10;    onDismissRequest: () -&gt; Unit,&#10;    title: String,&#10;    text: String,&#10;    confirmButtonText: String,&#10;    onConfirm: () -&gt; Unit,&#10;    dismissButtonText: String? = null,&#10;    onDismiss: (() -&gt; Unit)? = null&#10;) {&#10;    if (show) {&#10;        AlertDialog(&#10;            onDismissRequest = onDismissRequest,&#10;            title = { Text(title) },&#10;            text = { Text(text) },&#10;            confirmButton = {&#10;                TextButton(onClick = onConfirm) {&#10;                    Text(confirmButtonText)&#10;                }&#10;            },&#10;            dismissButton = if (dismissButtonText != null &amp;&amp; onDismiss != null) {&#10;                {&#10;                    TextButton(onClick = onDismiss) {&#10;                        Text(dismissButtonText)&#10;                    }&#10;                }&#10;            } else null&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun RematchDialogsHandler(viewModel: ChessGameViewModel, gameEndResponse: GameEndResponse, navController: NavHostController?) {&#10;    val rematchDialogState = viewModel.rematchDialogState.collectAsStateWithLifecycle().value&#10;    when (rematchDialogState) {&#10;        is RematchDialogState.WaitingForResponse -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch angefragt&quot;,&#10;                text = &quot;Warte auf Antwort des Gegners...&quot;,&#10;                confirmButtonText = &quot;Abbrechen&quot;,&#10;                onConfirm = {&#10;                    viewModel.clearRematchDialog() }&#10;            )&#10;        }&#10;        is RematchDialogState.OfferReceived -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch erhalten&quot;,&#10;                text = &quot;Dein Gegner möchte ein Rematch. Annehmen?&quot;,&#10;                confirmButtonText = &quot;Annehmen&quot;,&#10;                onConfirm = { viewModel.respondRematch(true) },&#10;                dismissButtonText = &quot;Ablehnen&quot;,&#10;                onDismiss = { viewModel.respondRematch(false) }&#10;            )&#10;        }&#10;        is RematchDialogState.WaitingForResult -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Antwort gesendet&quot;,&#10;                text = &quot;Warte auf Bestätigung...&quot;,&#10;                confirmButtonText = &quot;Schließen&quot;,&#10;                onConfirm = {&#10;                    viewModel.clearRematchDialog() }&#10;            )&#10;        }&#10;        is RematchDialogState.Accepted -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch angenommen&quot;,&#10;                text = &quot;Das Rematch startet jetzt!&quot;,&#10;                confirmButtonText = &quot;OK&quot;,&#10;                onConfirm = {&#10;                    viewModel.clearRematchDialog()&#10;                    val isPrivate = gameEndResponse.lobbyId.length &lt;= 6&#10;                    if (isPrivate) {&#10;                        if(viewModel.rematchResult.value == null) {&#10;                            android.util.Log.e(&#10;                                &quot;GameOverScreen&quot;,&#10;                                &quot;rematchResult ist null, kann nicht navigieren&quot;&#10;                            )&#10;                            return@RematchDialog&#10;                        }&#10;                        val isCreator = viewModel.myColor.value == TeamColor.WHITE&#10;                        navController!!.navigate(&quot;lobby_waiting/${viewModel.rematchResult.value!!.newlobbyid}/$isCreator&quot;) {&#10;                            popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                        }&#10;                    } else {&#10;                        navController!!.navigate(&quot;game/${gameEndResponse.lobbyId}&quot;) {&#10;                            popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                        }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        is RematchDialogState.Declined -&gt; {&#10;            RematchDialog(&#10;                show = true,&#10;                onDismissRequest = { viewModel.clearRematchDialog() },&#10;                title = &quot;Rematch abgelehnt&quot;,&#10;                text = &quot;Der Gegner hat das Rematch abgelehnt.&quot;,&#10;                confirmButtonText = &quot;OK&quot;,&#10;                onConfirm = {&#10;                    viewModel.resetGameState()&#10;                    viewModel.clearRematchDialog()&#10;                    navController!!.navigate(NavRoutes.HOME) {&#10;                        popUpTo(0) { inclusive = true }&#10;                    }&#10;                }&#10;            )&#10;        }&#10;        else -&gt; null&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameOverResultInfo(&#10;    gameEndResponse: GameEndResponse,&#10;    playerId: String&#10;) {&#10;    val ergebnisText = when {&#10;        gameEndResponse.draw -&gt; &quot;Unentschieden&quot;&#10;        playerId == gameEndResponse.winner -&gt; &quot;Sieg&quot;&#10;        playerId == gameEndResponse.loser -&gt; &quot;Niederlage&quot;&#10;        else -&gt; &quot;Unbekannt&quot;&#10;    }&#10;    Column(&#10;        horizontalAlignment = Alignment.CenterHorizontally,&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = ergebnisText,&#10;            style = MaterialTheme.typography.displayMedium,&#10;            color = when (ergebnisText) {&#10;                &quot;Sieg&quot; -&gt; Color(0xFF4CAF50)&#10;                &quot;Niederlage&quot; -&gt; Color(0xFFF44336)&#10;                &quot;Unentschieden&quot; -&gt; Color(0xFF9E9E9E)&#10;                else -&gt; MaterialTheme.colorScheme.onSurface&#10;            },&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;        Text(&#10;            text = if (playerId == gameEndResponse.winner) &quot;Du hast gewonnen!&quot; else if (playerId == gameEndResponse.loser) &quot;Du hast verloren.&quot; else &quot;&quot;,&#10;            style = MaterialTheme.typography.titleLarge,&#10;            color = MaterialTheme.colorScheme.onSurface,&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameOverActions(&#10;    gameEndResponse: GameEndResponse,&#10;    viewModel: ChessGameViewModel,&#10;    navController: NavHostController? = null&#10;) {&#10;    Row(&#10;        modifier = Modifier.fillMaxSize(),&#10;        horizontalArrangement = Arrangement.Center,&#10;    ) {&#10;        Button(onClick = { viewModel.requestRematch() }) {&#10;            Text(&quot;Rematch&quot;)&#10;        }&#10;        Spacer(modifier = Modifier.width(16.dp))&#10;        Button(onClick = {&#10;            viewModel.closeLobby(gameEndResponse.lobbyId)&#10;            navController?.navigate(NavRoutes.HOME) {&#10;                popUpTo(0) { inclusive = true }&#10;            }&#10;        }) {&#10;            Text(&quot;Zurück&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/viewmodel/ChessGameViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.EndType&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.lobby.GameEndMessage&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.RematchResult&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChessGameViewModel @Inject constructor(&#10;    val webSocketService: StompWebSocketService&#10;) : ViewModel() {&#10;&#10;    private val _currentGameState = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val currentGameState: StateFlow&lt;GameMoveResponse?&gt; = _currentGameState.asStateFlow()&#10;&#10;    private val _initialGameData = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val initialGameData: StateFlow&lt;GameStartResponse?&gt; = _initialGameData.asStateFlow()&#10;&#10;    private val _currentBoard =&#10;        MutableStateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyMap())&#10;    val currentBoard: StateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt; =&#10;        _currentBoard.asStateFlow()&#10;&#10;    private val _currentPlayer = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val currentPlayer: StateFlow&lt;TeamColor?&gt; = _currentPlayer.asStateFlow()&#10;&#10;    private val _whiteTime = MutableStateFlow(0)&#10;    val whiteTime: StateFlow&lt;Int&gt; = _whiteTime.asStateFlow()&#10;    private val _blackTime = MutableStateFlow(0)&#10;    val blackTime: StateFlow&lt;Int&gt; = _blackTime.asStateFlow()&#10;&#10;    private val _myColor = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val myColor: StateFlow&lt;TeamColor?&gt; = _myColor.asStateFlow()&#10;&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    private val _capturedWhitePieces =&#10;        MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedWhitePieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; =&#10;        _capturedWhitePieces.asStateFlow()&#10;    private val _capturedBlackPieces =&#10;        MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedBlackPieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; =&#10;        _capturedBlackPieces.asStateFlow()&#10;    private val _promotionRequest =&#10;        MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; =&#10;        _promotionRequest.asStateFlow()&#10;&#10;    private val _gameEndEvent = MutableStateFlow&lt;GameEndResponse?&gt;(null)&#10;    val gameEndEvent: StateFlow&lt;GameEndResponse?&gt; = _gameEndEvent&#10;&#10;    private val _moveHistory = MutableStateFlow&lt;List&lt;GameMoveResponse&gt;&gt;(emptyList())&#10;    val moveHistory: StateFlow&lt;List&lt;GameMoveResponse&gt;&gt; = _moveHistory.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var lastActivePlayer: TeamColor? = null&#10;    private var timeoutSent = false&#10;&#10;    private val _rematchDialogState = MutableStateFlow&lt;RematchDialogState&gt;(RematchDialogState.None)&#10;    val rematchDialogState: StateFlow&lt;RematchDialogState&gt; = _rematchDialogState.asStateFlow()&#10;&#10;    private val _rematchResult = MutableStateFlow&lt;RematchResult?&gt;(null)&#10;    val rematchResult: StateFlow&lt;RematchResult?&gt; = _rematchResult.asStateFlow()&#10;&#10;    enum class FieldHighlight {&#10;        NONE,&#10;        CHECKMATE_KING,&#10;        CHECKMATE_ATTACKER,&#10;        CHECK_KING&#10;    }&#10;&#10;    private val _fieldHighlights = MutableStateFlow&lt;Map&lt;String, FieldHighlight&gt;&gt;(emptyMap())&#10;    val fieldHighlights: StateFlow&lt;Map&lt;String, FieldHighlight&gt;&gt; = _fieldHighlights.asStateFlow()&#10;&#10;    private val _pendingRemisRequest =&#10;        MutableStateFlow&lt;app.chesspresso.model.lobby.RemisMessage?&gt;(null)&#10;    val pendingRemisRequest: StateFlow&lt;app.chesspresso.model.lobby.RemisMessage?&gt; =&#10;        _pendingRemisRequest.asStateFlow()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            webSocketService.gameStartedEvent.collect { event -&gt;&#10;                event?.let { initializeGame(it) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.possibleMoves.collect { moves -&gt;&#10;                _possibleMoves.value = moves&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            webSocketService.gameMoveUpdates.collect { gameMoveResponse -&gt;&#10;                gameMoveResponse?.let { response -&gt;&#10;                    val captured = response.move.captured&#10;                    if (captured != null &amp;&amp; captured.type != null &amp;&amp; captured.color != null) {&#10;                        val capturedPiece = app.chesspresso.model.game.PieceInfo(&#10;                            type = captured.type,&#10;                            color = captured.color&#10;                        )&#10;                        when (captured.color) {&#10;                            TeamColor.WHITE -&gt; _capturedWhitePieces.value =&#10;                                _capturedWhitePieces.value + capturedPiece&#10;&#10;                            TeamColor.BLACK -&gt; _capturedBlackPieces.value =&#10;                                _capturedBlackPieces.value + capturedPiece&#10;&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                    val newBoard = response.board&#10;                    _currentGameState.value = response&#10;                    _currentBoard.value = newBoard&#10;                    _possibleMoves.value = emptyList()&#10;                    if (response.nextPlayer != lastActivePlayer) {&#10;                        startTimer(response.nextPlayer)&#10;                        lastActivePlayer = response.nextPlayer&#10;                    }&#10;                    _currentPlayer.value = response.nextPlayer&#10;                    // Promotion-UI ausblenden, sobald ein Zug vom Server kommt&#10;                    _promotionRequest.value = null&#10;                    // Zug zur History hinzufügen&#10;                    _moveHistory.value = _moveHistory.value + response&#10;&#10;                    val highlights = mutableMapOf&lt;String, FieldHighlight&gt;()&#10;                    val checkmateFields = response.checkMatePositions&#10;                    val kingField = response.isCheck&#10;                    if (checkmateFields != null &amp;&amp; checkmateFields.isNotEmpty() &amp;&amp; kingField.isNotEmpty()) {&#10;                        // Schachmatt: König dunkelrot, Angreifer hellrot&#10;                        highlights[kingField] = FieldHighlight.CHECKMATE_KING&#10;                        checkmateFields.forEach { field: String -&gt;&#10;                            highlights[field] = FieldHighlight.CHECKMATE_ATTACKER&#10;                        }&#10;                    } else if(kingField.isNotEmpty()){&#10;                        // Schach: König hellrot&#10;                        highlights[kingField] = FieldHighlight.CHECK_KING&#10;                    }&#10;                    _fieldHighlights.value = highlights&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.promotionRequest.collect { request -&gt;&#10;                _promotionRequest.value = request&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.gameEndEvent.collect { event -&gt;&#10;                _gameEndEvent.value = event&#10;                stopTimer()&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.rematchOfferEvent.collectLatest { offer -&gt;&#10;                val lobbyId = _initialGameData.value?.lobbyId ?: return@collectLatest&#10;                val myId = webSocketService.playerId?.trim()?.lowercase()&#10;                val toId = offer?.toPlayerId?.trim()?.lowercase()&#10;                android.util.Log.d(&quot;RematchDebug&quot;, &quot;Vergleich: myId=$myId, toId=$toId, offer=$offer&quot;)&#10;                if (offer != null &amp;&amp; offer.lobbyId == lobbyId &amp;&amp; myId == toId) {&#10;                    android.util.Log.d(&quot;RematchDebug&quot;, &quot;Rematch-Dialog wird angezeigt für playerId=$myId&quot;)&#10;                    _rematchDialogState.value = RematchDialogState.OfferReceived(offer)&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.rematchResultEvent.collectLatest { result -&gt;&#10;                val lobbyId = _initialGameData.value?.lobbyId ?: return@collectLatest&#10;                if (result != null &amp;&amp; result.lobbyId == lobbyId) {&#10;                    if (result.result == &quot;accepted&quot; &amp;&amp; result.newlobbyid != null) {&#10;                        _rematchDialogState.value = RematchDialogState.Accepted&#10;                        webSocketService.resetGameFlows()&#10;                        webSocketService.subscribeToLobby(result.newlobbyid)&#10;                        _rematchResult.value = result&#10;                    }&#10;                    else _rematchDialogState.value = RematchDialogState.Declined&#10;                }&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            webSocketService.remisRequest.collect { remisMessage -&gt;&#10;                // Nur anzeigen, wenn es eine Anfrage vom Gegner ist (responder == null, requester != ich)&#10;                if (remisMessage != null &amp;&amp; !remisMessage.accept &amp;&amp; remisMessage.responder == null) {&#10;                    _pendingRemisRequest.value = remisMessage&#10;                } else {&#10;                    _pendingRemisRequest.value = null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetGameState() {&#10;        _currentGameState.value = null&#10;        _initialGameData.value = null&#10;        _currentBoard.value = emptyMap()&#10;        _currentPlayer.value = null&#10;        _whiteTime.value = 0&#10;        _blackTime.value = 0&#10;        _myColor.value = null&#10;        _possibleMoves.value = emptyList()&#10;        _capturedWhitePieces.value = emptyList()&#10;        _capturedBlackPieces.value = emptyList()&#10;        _promotionRequest.value = null&#10;        _gameEndEvent.value = null&#10;        _moveHistory.value = emptyList()&#10;        timerJob?.cancel()&#10;        timerJob = null&#10;        lastActivePlayer = null&#10;        timeoutSent = false&#10;        _rematchDialogState.value = RematchDialogState.None&#10;        _rematchResult.value = null&#10;        _fieldHighlights.value = emptyMap()&#10;        _pendingRemisRequest.value = null&#10;    }&#10;&#10;    fun initializeGame(gameStartResponse: GameStartResponse) {&#10;        resetGameState()&#10;        viewModelScope.launch {&#10;            // Warte, bis playerId gesetzt ist&#10;            var myId = webSocketService.playerId&#10;            var retry = 0&#10;            while (myId == null &amp;&amp; retry &lt; 50) { // max. 5 Sekunden warten&#10;                delay(100)&#10;                myId = webSocketService.playerId&#10;                retry++&#10;            }&#10;            if (myId == null) {&#10;                // Fehlerfall: ID konnte nicht ermittelt werden&#10;                Log.e(&#10;                    &quot;ChessGameViewModel&quot;,&#10;                    &quot;playerId ist nach 5 Sekunden immer noch null!&quot;&#10;                )&#10;            }&#10;            _currentGameState.value = null&#10;            _initialGameData.value = gameStartResponse&#10;            _currentBoard.value = gameStartResponse.board&#10;            _currentPlayer.value = TeamColor.WHITE // Weiß beginnt immer&#10;&#10;            _myColor.value = when (myId) {&#10;                gameStartResponse.whitePlayer -&gt; TeamColor.WHITE&#10;                gameStartResponse.blackPlayer -&gt; TeamColor.BLACK&#10;                else -&gt; null&#10;            }&#10;&#10;            // Zeit direkt aus gameTime (jetzt Int in Sekunden)&#10;            _whiteTime.value = gameStartResponse.gameTime.seconds&#10;            _blackTime.value = gameStartResponse.gameTime.seconds&#10;            lastActivePlayer = TeamColor.WHITE&#10;            startTimer(TeamColor.WHITE)&#10;&#10;            // Subscribe zu Spiel-Updates für diese Lobby&#10;            webSocketService.subscribeToGame(gameStartResponse.lobbyId)&#10;        }&#10;    }&#10;&#10;    private fun startTimer(activePlayer: TeamColor) {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            timeoutSent = false // Timer-Start: Reset Flag&#10;            while (true) {&#10;                delay(1000)&#10;                if (activePlayer == TeamColor.WHITE) {&#10;                    if (_whiteTime.value &gt; 0) {&#10;                        _whiteTime.value = _whiteTime.value - 1&#10;                        if (_whiteTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.WHITE) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.WHITE)&#10;                        }&#10;                    }&#10;                } else {&#10;                    if (_blackTime.value &gt; 0) {&#10;                        _blackTime.value = _blackTime.value - 1&#10;                        if (_blackTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.BLACK) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.BLACK)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = null&#10;    }&#10;&#10;    private fun sendTimeoutEndMessage(teamColor: TeamColor) {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.TIMEOUT&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun sendPositionRequest(lobbyId: String, position: String) {&#10;        viewModelScope.launch {&#10;            val message = app.chesspresso.model.game.PositionRequestMessage(lobbyId, position)&#10;            webSocketService.sendPositionRequest(message)&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(&#10;        lobbyId: String,&#10;        from: String,&#10;        to: String,&#10;        teamColor: TeamColor,&#10;        promotedPiece: PieceType? = null&#10;    ) {&#10;        val message = app.chesspresso.model.game.GameMoveMessage(&#10;            lobbyId = lobbyId,&#10;            from = from,&#10;            to = to,&#10;            teamColor = teamColor,&#10;            promotedPiece = promotedPiece&#10;        )&#10;        webSocketService.sendGameMoveMessage(message)&#10;    }&#10;&#10;    fun resignGame(teamColor: TeamColor, lobbyId: String) {&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.RESIGNATION&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun closeLobby(lobbyId: String) {&#10;        webSocketService.sendLobbyCloseMessage(lobbyId)&#10;        webSocketService.resetGameFlows()&#10;        webSocketService.unsubscribeFromLobby()&#10;        webSocketService.unsubscribeFromGame()&#10;        resetViewModel()&#10;    }&#10;&#10;    fun clearGameEndEvent() {&#10;        _gameEndEvent.value = null&#10;    }&#10;&#10;    fun requestRematch() {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        _rematchDialogState.value = RematchDialogState.WaitingForResponse&#10;        webSocketService.sendRematchRequest(lobbyId)&#10;    }&#10;&#10;    fun respondRematch(accept: Boolean) {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        webSocketService.sendRematchResponse(lobbyId, if (accept) &quot;accepted&quot; else &quot;declined&quot;)&#10;        _rematchDialogState.value = RematchDialogState.WaitingForResult&#10;    }&#10;&#10;    fun clearRematchDialog() {&#10;        _rematchDialogState.value = RematchDialogState.None&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;    }&#10;&#10;    fun offerDraw(lobbyId: String, player: TeamColor) {&#10;        val remisMessage = app.chesspresso.model.lobby.RemisMessage(&#10;            lobbyId = lobbyId,&#10;            requester = player,&#10;            responder = TeamColor.NULL,&#10;            accept = false // Remis wird angeboten&#10;        )&#10;        webSocketService.sendRemisMessage(remisMessage)&#10;    }&#10;&#10;    fun respondToRemisRequest(accept: Boolean) {&#10;        val request = _pendingRemisRequest.value ?: return&#10;        val response = app.chesspresso.model.lobby.RemisMessage(&#10;            lobbyId = request.lobbyId,&#10;            requester = request.requester,&#10;            responder = myColor.value ?: TeamColor.NULL,&#10;            accept = accept&#10;        )&#10;        webSocketService.sendRemisMessage(response)&#10;        _pendingRemisRequest.value = null&#10;    }&#10;&#10;    fun resetViewModel(){&#10;        _currentGameState.value = null&#10;        _initialGameData.value = null&#10;        _currentBoard.value = emptyMap()&#10;        _currentPlayer.value = null&#10;        _whiteTime.value = 0&#10;        _blackTime.value = 0&#10;        _myColor.value = null&#10;        _possibleMoves.value = emptyList()&#10;        _capturedWhitePieces.value = emptyList()&#10;        _capturedBlackPieces.value = emptyList()&#10;        _promotionRequest.value = null&#10;        _gameEndEvent.value = null&#10;        _moveHistory.value = emptyList()&#10;        timerJob?.cancel()&#10;        timerJob = null&#10;        lastActivePlayer = null&#10;        timeoutSent = false&#10;        _rematchDialogState.value = RematchDialogState.None&#10;        _rematchResult.value = null&#10;        _fieldHighlights.value = emptyMap()&#10;        _pendingRemisRequest.value = null&#10;        webSocketService.unsubscribeFromGame()&#10;        webSocketService.resetGameFlows()&#10;        Log.d(&quot;ChessGameViewModel&quot;, &quot;ViewModel wurde zurückgesetzt.&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.viewmodel&#10;&#10;import android.util.Log&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.model.EndType&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.model.lobby.GameEndMessage&#10;import app.chesspresso.model.lobby.GameEndResponse&#10;import app.chesspresso.model.lobby.GameStartResponse&#10;import app.chesspresso.model.lobby.RematchResult&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.collectLatest&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class ChessGameViewModel @Inject constructor(&#10;    val webSocketService: StompWebSocketService&#10;) : ViewModel() {&#10;&#10;    private val _currentGameState = MutableStateFlow&lt;GameMoveResponse?&gt;(null)&#10;    val currentGameState: StateFlow&lt;GameMoveResponse?&gt; = _currentGameState.asStateFlow()&#10;&#10;    private val _initialGameData = MutableStateFlow&lt;GameStartResponse?&gt;(null)&#10;    val initialGameData: StateFlow&lt;GameStartResponse?&gt; = _initialGameData.asStateFlow()&#10;&#10;    private val _currentBoard =&#10;        MutableStateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyMap())&#10;    val currentBoard: StateFlow&lt;Map&lt;String, app.chesspresso.model.game.PieceInfo&gt;&gt; =&#10;        _currentBoard.asStateFlow()&#10;&#10;    private val _currentPlayer = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val currentPlayer: StateFlow&lt;TeamColor?&gt; = _currentPlayer.asStateFlow()&#10;&#10;    private val _whiteTime = MutableStateFlow(0)&#10;    val whiteTime: StateFlow&lt;Int&gt; = _whiteTime.asStateFlow()&#10;    private val _blackTime = MutableStateFlow(0)&#10;    val blackTime: StateFlow&lt;Int&gt; = _blackTime.asStateFlow()&#10;&#10;    private val _myColor = MutableStateFlow&lt;TeamColor?&gt;(null)&#10;    val myColor: StateFlow&lt;TeamColor?&gt; = _myColor.asStateFlow()&#10;&#10;    private val _possibleMoves = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val possibleMoves: StateFlow&lt;List&lt;String&gt;&gt; = _possibleMoves.asStateFlow()&#10;&#10;    private val _capturedWhitePieces =&#10;        MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedWhitePieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; =&#10;        _capturedWhitePieces.asStateFlow()&#10;    private val _capturedBlackPieces =&#10;        MutableStateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt;(emptyList())&#10;    val capturedBlackPieces: StateFlow&lt;List&lt;app.chesspresso.model.game.PieceInfo&gt;&gt; =&#10;        _capturedBlackPieces.asStateFlow()&#10;    private val _promotionRequest =&#10;        MutableStateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt;(null)&#10;    val promotionRequest: StateFlow&lt;app.chesspresso.model.game.PromotionRequest?&gt; =&#10;        _promotionRequest.asStateFlow()&#10;&#10;    private val _gameEndEvent = MutableStateFlow&lt;GameEndResponse?&gt;(null)&#10;    val gameEndEvent: StateFlow&lt;GameEndResponse?&gt; = _gameEndEvent&#10;&#10;    private val _moveHistory = MutableStateFlow&lt;List&lt;GameMoveResponse&gt;&gt;(emptyList())&#10;    val moveHistory: StateFlow&lt;List&lt;GameMoveResponse&gt;&gt; = _moveHistory.asStateFlow()&#10;&#10;    private var timerJob: Job? = null&#10;    private var lastActivePlayer: TeamColor? = null&#10;    private var timeoutSent = false&#10;&#10;    private val _rematchDialogState = MutableStateFlow&lt;RematchDialogState&gt;(RematchDialogState.None)&#10;    val rematchDialogState: StateFlow&lt;RematchDialogState&gt; = _rematchDialogState.asStateFlow()&#10;&#10;    private val _rematchResult = MutableStateFlow&lt;RematchResult?&gt;(null)&#10;    val rematchResult: StateFlow&lt;RematchResult?&gt; = _rematchResult.asStateFlow()&#10;&#10;    enum class FieldHighlight {&#10;        NONE,&#10;        CHECKMATE_KING,&#10;        CHECKMATE_ATTACKER,&#10;        CHECK_KING&#10;    }&#10;&#10;    private val _fieldHighlights = MutableStateFlow&lt;Map&lt;String, FieldHighlight&gt;&gt;(emptyMap())&#10;    val fieldHighlights: StateFlow&lt;Map&lt;String, FieldHighlight&gt;&gt; = _fieldHighlights.asStateFlow()&#10;&#10;    private val _pendingRemisRequest =&#10;        MutableStateFlow&lt;app.chesspresso.model.lobby.RemisMessage?&gt;(null)&#10;    val pendingRemisRequest: StateFlow&lt;app.chesspresso.model.lobby.RemisMessage?&gt; =&#10;        _pendingRemisRequest.asStateFlow()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            webSocketService.gameStartedEvent.collect { event -&gt;&#10;                event?.let { initializeGame(it) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.possibleMoves.collect { moves -&gt;&#10;                _possibleMoves.value = moves&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            webSocketService.gameMoveUpdates.collect { gameMoveResponse -&gt;&#10;                gameMoveResponse?.let { response -&gt;&#10;                    val captured = response.move.captured&#10;                    if (captured != null &amp;&amp; captured.type != null &amp;&amp; captured.color != null) {&#10;                        val capturedPiece = app.chesspresso.model.game.PieceInfo(&#10;                            type = captured.type,&#10;                            color = captured.color&#10;                        )&#10;                        when (captured.color) {&#10;                            TeamColor.WHITE -&gt; _capturedWhitePieces.value =&#10;                                _capturedWhitePieces.value + capturedPiece&#10;&#10;                            TeamColor.BLACK -&gt; _capturedBlackPieces.value =&#10;                                _capturedBlackPieces.value + capturedPiece&#10;&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                    val newBoard = response.board&#10;                    _currentGameState.value = response&#10;                    _currentBoard.value = newBoard&#10;                    _possibleMoves.value = emptyList()&#10;                    if (response.nextPlayer != lastActivePlayer) {&#10;                        startTimer(response.nextPlayer)&#10;                        lastActivePlayer = response.nextPlayer&#10;                    }&#10;                    _currentPlayer.value = response.nextPlayer&#10;                    // Promotion-UI ausblenden, sobald ein Zug vom Server kommt&#10;                    _promotionRequest.value = null&#10;                    // Zug zur History hinzufügen&#10;                    _moveHistory.value = _moveHistory.value + response&#10;&#10;                    val highlights = mutableMapOf&lt;String, FieldHighlight&gt;()&#10;                    val checkmateFields = response.checkMatePositions&#10;                    val kingField = response.isCheck&#10;                    if (checkmateFields != null &amp;&amp; checkmateFields.isNotEmpty() &amp;&amp; kingField.isNotEmpty()) {&#10;                        // Schachmatt: König dunkelrot, Angreifer hellrot&#10;                        highlights[kingField] = FieldHighlight.CHECKMATE_KING&#10;                        checkmateFields.forEach { field: String -&gt;&#10;                            highlights[field] = FieldHighlight.CHECKMATE_ATTACKER&#10;                        }&#10;                    } else if(kingField.isNotEmpty()){&#10;                        // Schach: König hellrot&#10;                        highlights[kingField] = FieldHighlight.CHECK_KING&#10;                    }&#10;                    _fieldHighlights.value = highlights&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.promotionRequest.collect { request -&gt;&#10;                _promotionRequest.value = request&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.gameEndEvent.collect { event -&gt;&#10;                _gameEndEvent.value = event&#10;                stopTimer()&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.rematchOfferEvent.collectLatest { offer -&gt;&#10;                val lobbyId = _initialGameData.value?.lobbyId ?: return@collectLatest&#10;                val myId = webSocketService.playerId?.trim()?.lowercase()&#10;                val toId = offer?.toPlayerId?.trim()?.lowercase()&#10;                android.util.Log.d(&quot;RematchDebug&quot;, &quot;Vergleich: myId=$myId, toId=$toId, offer=$offer&quot;)&#10;                if (offer != null &amp;&amp; offer.lobbyId == lobbyId &amp;&amp; myId == toId) {&#10;                    android.util.Log.d(&quot;RematchDebug&quot;, &quot;Rematch-Dialog wird angezeigt für playerId=$myId&quot;)&#10;                    _rematchDialogState.value = RematchDialogState.OfferReceived(offer)&#10;                }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            webSocketService.rematchResultEvent.collectLatest { result -&gt;&#10;                val lobbyId = _initialGameData.value?.lobbyId ?: return@collectLatest&#10;                if (result != null &amp;&amp; result.lobbyId == lobbyId) {&#10;                    if (result.result == &quot;accepted&quot; &amp;&amp; result.newlobbyid != null) {&#10;                        _rematchDialogState.value = RematchDialogState.Accepted&#10;                        webSocketService.resetGameFlows()&#10;                        webSocketService.subscribeToLobby(result.newlobbyid)&#10;                        _rematchResult.value = result&#10;                    }&#10;                    else _rematchDialogState.value = RematchDialogState.Declined&#10;                }&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            webSocketService.remisRequest.collect { remisMessage -&gt;&#10;                // Nur anzeigen, wenn es eine Anfrage vom Gegner ist (responder == null, requester != ich)&#10;                if (remisMessage != null &amp;&amp; !remisMessage.accept &amp;&amp; remisMessage.responder == null) {&#10;                    _pendingRemisRequest.value = remisMessage&#10;                } else {&#10;                    _pendingRemisRequest.value = null&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun resetGameState() {&#10;        _currentGameState.value = null&#10;        _initialGameData.value = null&#10;        _currentBoard.value = emptyMap()&#10;        _currentPlayer.value = null&#10;        _whiteTime.value = 0&#10;        _blackTime.value = 0&#10;        _myColor.value = null&#10;        _possibleMoves.value = emptyList()&#10;        _capturedWhitePieces.value = emptyList()&#10;        _capturedBlackPieces.value = emptyList()&#10;        _promotionRequest.value = null&#10;        _gameEndEvent.value = null&#10;        _moveHistory.value = emptyList()&#10;        timerJob?.cancel()&#10;        timerJob = null&#10;        lastActivePlayer = null&#10;        timeoutSent = false&#10;        _rematchDialogState.value = RematchDialogState.None&#10;        _rematchResult.value = null&#10;        _fieldHighlights.value = emptyMap()&#10;        _pendingRemisRequest.value = null&#10;    }&#10;&#10;    fun initializeGame(gameStartResponse: GameStartResponse) {&#10;        resetGameState()&#10;        viewModelScope.launch {&#10;            // Warte, bis playerId gesetzt ist&#10;            var myId = webSocketService.playerId&#10;            var retry = 0&#10;            while (myId == null &amp;&amp; retry &lt; 50) { // max. 5 Sekunden warten&#10;                delay(100)&#10;                myId = webSocketService.playerId&#10;                retry++&#10;            }&#10;            if (myId == null) {&#10;                // Fehlerfall: ID konnte nicht ermittelt werden&#10;                Log.e(&#10;                    &quot;ChessGameViewModel&quot;,&#10;                    &quot;playerId ist nach 5 Sekunden immer noch null!&quot;&#10;                )&#10;            }&#10;            _currentGameState.value = null&#10;            _initialGameData.value = gameStartResponse&#10;            _currentBoard.value = gameStartResponse.board&#10;            _currentPlayer.value = TeamColor.WHITE // Weiß beginnt immer&#10;&#10;            _myColor.value = when (myId) {&#10;                gameStartResponse.whitePlayer -&gt; TeamColor.WHITE&#10;                gameStartResponse.blackPlayer -&gt; TeamColor.BLACK&#10;                else -&gt; null&#10;            }&#10;&#10;            // Zeit direkt aus gameTime (jetzt Int in Sekunden)&#10;            _whiteTime.value = gameStartResponse.gameTime.seconds&#10;            _blackTime.value = gameStartResponse.gameTime.seconds&#10;            lastActivePlayer = TeamColor.WHITE&#10;            startTimer(TeamColor.WHITE)&#10;&#10;            // Subscribe zu Spiel-Updates für diese Lobby&#10;            webSocketService.subscribeToGame(gameStartResponse.lobbyId)&#10;        }&#10;    }&#10;&#10;    private fun startTimer(activePlayer: TeamColor) {&#10;        timerJob?.cancel()&#10;        timerJob = viewModelScope.launch {&#10;            timeoutSent = false // Timer-Start: Reset Flag&#10;            while (true) {&#10;                delay(1000)&#10;                if (activePlayer == TeamColor.WHITE) {&#10;                    if (_whiteTime.value &gt; 0) {&#10;                        _whiteTime.value = _whiteTime.value - 1&#10;                        if (_whiteTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.WHITE) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.WHITE)&#10;                        }&#10;                    }&#10;                } else {&#10;                    if (_blackTime.value &gt; 0) {&#10;                        _blackTime.value = _blackTime.value - 1&#10;                        if (_blackTime.value == 0 &amp;&amp; !timeoutSent &amp;&amp; _myColor.value == TeamColor.BLACK) {&#10;                            timeoutSent = true&#10;                            sendTimeoutEndMessage(TeamColor.BLACK)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopTimer() {&#10;        timerJob?.cancel()&#10;        timerJob = null&#10;    }&#10;&#10;    private fun sendTimeoutEndMessage(teamColor: TeamColor) {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.TIMEOUT&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun sendPositionRequest(lobbyId: String, position: String) {&#10;        viewModelScope.launch {&#10;            val message = app.chesspresso.model.game.PositionRequestMessage(lobbyId, position)&#10;            webSocketService.sendPositionRequest(message)&#10;        }&#10;    }&#10;&#10;    fun sendGameMoveMessage(&#10;        lobbyId: String,&#10;        from: String,&#10;        to: String,&#10;        teamColor: TeamColor,&#10;        promotedPiece: PieceType? = null&#10;    ) {&#10;        val message = app.chesspresso.model.game.GameMoveMessage(&#10;            lobbyId = lobbyId,&#10;            from = from,&#10;            to = to,&#10;            teamColor = teamColor,&#10;            promotedPiece = promotedPiece&#10;        )&#10;        webSocketService.sendGameMoveMessage(message)&#10;    }&#10;&#10;    fun resignGame(teamColor: TeamColor, lobbyId: String) {&#10;        val gameEndMessage = GameEndMessage(&#10;            lobbyId = lobbyId,&#10;            player = teamColor.name,&#10;            endType = EndType.RESIGNATION&#10;        )&#10;        webSocketService.sendEndGameMessage(gameEndMessage)&#10;    }&#10;&#10;    fun closeLobby(lobbyId: String) {&#10;        webSocketService.sendLobbyCloseMessage(lobbyId)&#10;        webSocketService.resetGameFlows()&#10;        webSocketService.unsubscribeFromLobby()&#10;        webSocketService.unsubscribeFromGame()&#10;        resetViewModel()&#10;    }&#10;&#10;    fun clearGameEndEvent() {&#10;        _gameEndEvent.value = null&#10;    }&#10;&#10;    fun requestRematch() {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        _rematchDialogState.value = RematchDialogState.WaitingForResponse&#10;        webSocketService.sendRematchRequest(lobbyId)&#10;    }&#10;&#10;    fun respondRematch(accept: Boolean) {&#10;        val lobbyId = _initialGameData.value?.lobbyId ?: return&#10;        webSocketService.sendRematchResponse(lobbyId, if (accept) &quot;accepted&quot; else &quot;declined&quot;)&#10;        _rematchDialogState.value = RematchDialogState.WaitingForResult&#10;    }&#10;&#10;    fun clearRematchDialog() {&#10;        _rematchDialogState.value = RematchDialogState.None&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        timerJob?.cancel()&#10;    }&#10;&#10;    fun offerDraw(lobbyId: String, player: TeamColor) {&#10;        val remisMessage = app.chesspresso.model.lobby.RemisMessage(&#10;            lobbyId = lobbyId,&#10;            requester = player,&#10;            responder = TeamColor.NULL,&#10;            accept = false // Remis wird angeboten&#10;        )&#10;        webSocketService.sendRemisMessage(remisMessage)&#10;    }&#10;&#10;    fun respondToRemisRequest(accept: Boolean) {&#10;        val request = _pendingRemisRequest.value ?: return&#10;        val response = app.chesspresso.model.lobby.RemisMessage(&#10;            lobbyId = request.lobbyId,&#10;            requester = request.requester,&#10;            responder = myColor.value ?: TeamColor.NULL,&#10;            accept = accept&#10;        )&#10;        webSocketService.sendRemisMessage(response)&#10;        _pendingRemisRequest.value = null&#10;    }&#10;&#10;    fun resetViewModel(){&#10;        _currentGameState.value = null&#10;        _initialGameData.value = null&#10;        _currentBoard.value = emptyMap()&#10;        _currentPlayer.value = null&#10;        _whiteTime.value = 0&#10;        _blackTime.value = 0&#10;        _myColor.value = null&#10;        _possibleMoves.value = emptyList()&#10;        _capturedWhitePieces.value = emptyList()&#10;        _capturedBlackPieces.value = emptyList()&#10;        _promotionRequest.value = null&#10;        _gameEndEvent.value = null&#10;        _moveHistory.value = emptyList()&#10;        timerJob?.cancel()&#10;        timerJob = null&#10;        lastActivePlayer = null&#10;        timeoutSent = false&#10;        _rematchDialogState.value = RematchDialogState.None&#10;        _rematchResult.value = null&#10;        _fieldHighlights.value = emptyMap()&#10;        _pendingRemisRequest.value = null&#10;        webSocketService.unsubscribeFromGame()&#10;        webSocketService.resetGameFlows()&#10;        Log.d(&quot;ChessGameViewModel&quot;, &quot;ViewModel wurde zurückgesetzt.&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>