<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // TEMPORÄRER WORKAROUND: Verwende Web Client ID für App UND Server&#10;        // bis das Android Client ID Problem in Google Console gelöst ist&#10;        buildConfigField(&quot;String&quot;, &quot;GOOGLE_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;        &#10;        // Web Client ID - für den Server (gleiche wie oben)&#10;        buildConfigField(&quot;String&quot;, &quot;WEB_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;        &#10;        // Android Client ID - für späteren Gebrauch wenn Google Console Problem gelöst&#10;        buildConfigField(&quot;String&quot;, &quot;ANDROID_CLIENT_ID&quot;, &quot;\&quot;871578886913-8kr48rb5qhqfl00h2etd39smadtre5qe.apps.googleusercontent.com\&quot;&quot;)&#10;        &#10;        // SHA-1 Debug Info&#10;        buildConfigField(&quot;String&quot;, &quot;DEBUG_SHA1&quot;, &quot;\&quot;E3:D2:D2:1E:06:1D:14:ED:D1:4B:5D:22:38:48:7D:65:E6:D5:AA:2C\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;    //Google Identity&#10;    implementation(libs.play.services.identity)&#10;    implementation(libs.play.services.auth)&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // TEMPORÄRER WORKAROUND: Verwende Web Client ID für App UND Server&#10;        // bis das Android Client ID Problem in Google Console gelöst ist&#10;        buildConfigField(&quot;String&quot;, &quot;GOOGLE_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;        &#10;        // Web Client ID - für den Server (gleiche wie oben)&#10;        buildConfigField(&quot;String&quot;, &quot;WEB_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;        &#10;        // Android Client ID - für späteren Gebrauch wenn Google Console Problem gelöst&#10;        buildConfigField(&quot;String&quot;, &quot;ANDROID_CLIENT_ID&quot;, &quot;\&quot;871578886913-8kr48rb5qhqfl00h2etd39smadtre5qe.apps.googleusercontent.com\&quot;&quot;)&#10;        &#10;        // SHA-1 Debug Info&#10;        buildConfigField(&quot;String&quot;, &quot;DEBUG_SHA1&quot;, &quot;\&quot;E3:D2:D2:1E:06:1D:14:ED:D1:4B:5D:22:38:48:7D:65:E6:D5:AA:2C\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;    //Google Identity&#10;    implementation(libs.play.services.identity)&#10;    implementation(libs.play.services.auth)&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/data/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/data/AuthRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;&#10;class AuthRepository(private val api: AuthApi, private val context: Context) {&#10;&#10;    suspend fun sendTokenToServer(idToken: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Sending token to server, token length: ${idToken.length}&quot;)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Token preview: ${idToken.take(50)}...&quot;)&#10;&#10;        try {&#10;            val response = api.login(AuthRequest(idToken))&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Server response received successfully&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player ID: ${response.playerId}&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player Name: ${response.name}&quot;)&#10;&#10;            // Lokale Speicherung aller Player-Daten&#10;            val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit()&#10;                .putString(&quot;playerId&quot;, response.playerId)&#10;                .putString(&quot;playerName&quot;, response.name)&#10;                .putString(&quot;playerEmail&quot;, response.email)&#10;                .putInt(&quot;playedGames&quot;, response.playedGames)&#10;                .putInt(&quot;win&quot;, response.win)&#10;                .putInt(&quot;draw&quot;, response.draw)&#10;                .putInt(&quot;lose&quot;, response.lose)&#10;                .apply()&#10;&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player data stored locally&quot;)&#10;            return response&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Error sending token to server: ${e.message}&quot;, e)&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;&#10;            // Re-throw mit mehr Details&#10;            throw Exception(&quot;Server-Kommunikation fehlgeschlagen: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun sendAlternativeTokenToServer(accountId: String, email: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Sending alternative auth to server&quot;)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Email: $email&quot;)&#10;&#10;        try {&#10;            // Erstelle ein alternatives Token aus Account-Daten&#10;            val alternativeToken = &quot;google_account_${accountId}_${email}&quot;&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Alternative token created: ${alternativeToken.take(50)}...&quot;)&#10;&#10;            val response = api.login(AuthRequest(alternativeToken))&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Server response received successfully&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player ID: ${response.playerId}&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player Name: ${response.name}&quot;)&#10;&#10;            // Lokale Speicherung aller Player-Daten&#10;            val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit()&#10;                .putString(&quot;playerId&quot;, response.playerId)&#10;                .putString(&quot;playerName&quot;, response.name)&#10;                .putString(&quot;playerEmail&quot;, response.email)&#10;                .putInt(&quot;playedGames&quot;, response.playedGames)&#10;                .putInt(&quot;win&quot;, response.win)&#10;                .putInt(&quot;draw&quot;, response.draw)&#10;                .putInt(&quot;lose&quot;, response.lose)&#10;                .apply()&#10;&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player data stored locally&quot;)&#10;            return response&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Error sending alternative token to server: ${e.message}&quot;, e)&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;&#10;            // Re-throw mit mehr Details&#10;            throw Exception(&quot;Server-Kommunikation fehlgeschlagen: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        val playerId = prefs.getString(&quot;playerId&quot;, null)&#10;        val playerName = prefs.getString(&quot;playerName&quot;, null)&#10;&#10;        return if (playerId != null &amp;&amp; playerName != null) {&#10;            PlayerInfo(&#10;                playerId = playerId,&#10;                name = playerName,&#10;                email = prefs.getString(&quot;playerEmail&quot;, &quot;&quot;),&#10;                playedGames = prefs.getInt(&quot;playedGames&quot;, 0),&#10;                win = prefs.getInt(&quot;win&quot;, 0),&#10;                draw = prefs.getInt(&quot;draw&quot;, 0),&#10;                lose = prefs.getInt(&quot;lose&quot;, 0)&#10;            )&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun clearStoredPlayerInfo() {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().clear().apply()&#10;    }&#10;}&#10;&#10;data class PlayerInfo(&#10;    val playerId: String,&#10;    val name: String,&#10;    val email: String?,&#10;    val playedGames: Int,&#10;    val win: Int,&#10;    val draw: Int,&#10;    val lose: Int&#10;)&#10;" />
              <option name="updatedContent" value="package app.chesspresso.auth.data&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;&#10;class AuthRepository(private val api: AuthApi, private val context: Context) {&#10;&#10;    suspend fun sendTokenToServer(idToken: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Sending token to server, token length: ${idToken.length}&quot;)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Token preview: ${idToken.take(50)}...&quot;)&#10;&#10;        try {&#10;            val response = api.login(AuthRequest(idToken))&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Server response received successfully&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player ID: ${response.playerId}&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player Name: ${response.name}&quot;)&#10;&#10;            // Lokale Speicherung aller Player-Daten&#10;            val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit()&#10;                .putString(&quot;playerId&quot;, response.playerId)&#10;                .putString(&quot;playerName&quot;, response.name)&#10;                .putString(&quot;playerEmail&quot;, response.email)&#10;                .putInt(&quot;playedGames&quot;, response.playedGames)&#10;                .putInt(&quot;win&quot;, response.win)&#10;                .putInt(&quot;draw&quot;, response.draw)&#10;                .putInt(&quot;lose&quot;, response.lose)&#10;                .apply()&#10;&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player data stored locally&quot;)&#10;            return response&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Error sending token to server: ${e.message}&quot;, e)&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;&#10;            // Re-throw mit mehr Details&#10;            throw Exception(&quot;Server-Kommunikation fehlgeschlagen: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    suspend fun sendAlternativeTokenToServer(accountId: String, email: String): AuthResponse {&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Sending alternative auth to server&quot;)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthRepository&quot;, &quot;Email: $email&quot;)&#10;&#10;        try {&#10;            // Erstelle ein alternatives Token aus Account-Daten&#10;            val alternativeToken = &quot;google_account_${accountId}_${email}&quot;&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Alternative token created: ${alternativeToken.take(50)}...&quot;)&#10;&#10;            val response = api.login(AuthRequest(alternativeToken))&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Server response received successfully&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player ID: ${response.playerId}&quot;)&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player Name: ${response.name}&quot;)&#10;&#10;            // Lokale Speicherung aller Player-Daten&#10;            val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;            prefs.edit()&#10;                .putString(&quot;playerId&quot;, response.playerId)&#10;                .putString(&quot;playerName&quot;, response.name)&#10;                .putString(&quot;playerEmail&quot;, response.email)&#10;                .putInt(&quot;playedGames&quot;, response.playedGames)&#10;                .putInt(&quot;win&quot;, response.win)&#10;                .putInt(&quot;draw&quot;, response.draw)&#10;                .putInt(&quot;lose&quot;, response.lose)&#10;                .apply()&#10;&#10;            Log.d(&quot;AuthRepository&quot;, &quot;Player data stored locally&quot;)&#10;            return response&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Error sending alternative token to server: ${e.message}&quot;, e)&#10;            Log.e(&quot;AuthRepository&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;&#10;            // Re-throw mit mehr Details&#10;            throw Exception(&quot;Server-Kommunikation fehlgeschlagen: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        val playerId = prefs.getString(&quot;playerId&quot;, null)&#10;        val playerName = prefs.getString(&quot;playerName&quot;, null)&#10;&#10;        return if (playerId != null &amp;&amp; playerName != null) {&#10;            PlayerInfo(&#10;                playerId = playerId,&#10;                name = playerName,&#10;                email = prefs.getString(&quot;playerEmail&quot;, &quot;&quot;),&#10;                playedGames = prefs.getInt(&quot;playedGames&quot;, 0),&#10;                win = prefs.getInt(&quot;win&quot;, 0),&#10;                draw = prefs.getInt(&quot;draw&quot;, 0),&#10;                lose = prefs.getInt(&quot;lose&quot;, 0)&#10;            )&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    fun clearStoredPlayerInfo() {&#10;        val prefs = context.getSharedPreferences(&quot;chessapp&quot;, Context.MODE_PRIVATE)&#10;        prefs.edit().clear().apply()&#10;    }&#10;}&#10;&#10;data class PlayerInfo(&#10;    val playerId: String,&#10;    val name: String,&#10;    val email: String?,&#10;    val playedGames: Int,&#10;    val win: Int,&#10;    val draw: Int,&#10;    val lose: Int&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository to send token to server&quot;)&#10;                val response = repository.sendTokenToServer(idToken)&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Login successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;Login failed: ${e.message}&quot;, e)&#10;                val errorMessage = when {&#10;                    e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;                    e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;                    e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;                    e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;                    else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;                }&#10;                _authState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository to send alternative auth to server&quot;)&#10;                val response = repository.sendAlternativeTokenToServer(accountId, email)&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Alternative login successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;Alternative login failed: ${e.message}&quot;, e)&#10;                val errorMessage = when {&#10;                    e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;                    e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;                    e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;                    e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;                    else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;                }&#10;                _authState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository to send token to server&quot;)&#10;                val response = repository.sendTokenToServer(idToken)&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Login successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;Login failed: ${e.message}&quot;, e)&#10;                val errorMessage = when {&#10;                    e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;                    e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;                    e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;                    e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;                    else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;                }&#10;                _authState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository to send alternative auth to server&quot;)&#10;                val response = repository.sendAlternativeTokenToServer(accountId, email)&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Alternative login successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;Alternative login failed: ${e.message}&quot;, e)&#10;                val errorMessage = when {&#10;                    e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;                    e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;                    e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;                    e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;                    else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;                }&#10;                _authState.value = AuthState.Error(errorMessage)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.identity.Identity&#10;import com.google.android.gms.auth.api.identity.BeginSignInRequest&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import kotlinx.coroutines.launch&#10;import com.google.android.gms.common.ConnectionResult&#10;import com.google.android.gms.common.GoogleApiAvailability&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Launcher für klassisches Google Sign-In (MUSS VOR oneTapLauncher definiert werden)&#10;    val classicLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;=== CLASSIC SIGN-IN RESULT ANALYSIS ===&quot;)&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Classic Google Sign-In result received: ${result.resultCode}&quot;)&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Expected RESULT_OK: ${Activity.RESULT_OK} (should be -1)&quot;)&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Expected RESULT_CANCELED: ${Activity.RESULT_CANCELED} (should be 0)&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;✓ Classic account received successfully&quot;)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;Account email: ${account?.email}&quot;)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;Account displayName: ${account?.displayName}&quot;)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;Account ID: ${account?.id}&quot;)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;Account serverAuthCode: ${account?.serverAuthCode}&quot;)&#10;&#10;                // WICHTIG: ID Token Status&#10;                if (account?.idToken != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;✓ ID Token found! Length: ${account.idToken!!.length}&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;ID Token preview: ${account.idToken!!.take(50)}...&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Sending token to server...&quot;)&#10;                    viewModel.loginWithGoogle(account.idToken!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;❌ CRITICAL: Account found but NO ID TOKEN!&quot;)&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;This means:&quot;)&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;1. Client ID is wrong type (Web instead of Android)&quot;)&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;2. SHA-1 fingerprint missing/wrong in Google Console&quot;)&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;3. requestIdToken() was rejected by Google&quot;)&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Account object details: $account&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;❌ Exception during account processing: ${e.message}&quot;, e)&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Exception type: ${e.javaClass.simpleName}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;❌ User cancelled sign-in or sign-in was rejected&quot;)&#10;            Log.w(&quot;LoginScreen&quot;, &quot;This can happen when:&quot;)&#10;            Log.w(&quot;LoginScreen&quot;, &quot;1. User pressed back/cancel&quot;)&#10;            Log.w(&quot;LoginScreen&quot;, &quot;2. Google rejected the sign-in request&quot;)&#10;            Log.w(&quot;LoginScreen&quot;, &quot;3. Configuration problem prevented sign-in&quot;)&#10;        } else {&#10;            Log.e(&quot;LoginScreen&quot;, &quot;❌ Unexpected result code: ${result.resultCode}&quot;)&#10;        }&#10;        Log.d(&quot;LoginScreen&quot;, &quot;=== END CLASSIC SIGN-IN ANALYSIS ===&quot;)&#10;    }&#10;&#10;    // Launcher für Google One Tap Sign-In (NACH classicLauncher definiert)&#10;    val oneTapLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartIntentSenderForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;One Tap result received: ${result.resultCode}&quot;)&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val oneTapClient = Identity.getSignInClient(context)&#10;                val credential = oneTapClient.getSignInCredentialFromIntent(result.data)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;One Tap credential received&quot;)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;Credential ID: ${credential.id}&quot;)&#10;                Log.d(&quot;LoginScreen&quot;, &quot;Credential displayName: ${credential.displayName}&quot;)&#10;                credential.googleIdToken?.let { idToken -&gt;&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;ID Token found, length: ${idToken.length}&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Sending token to server: ${idToken.take(50)}...&quot;)&#10;                    viewModel.loginWithGoogle(idToken)&#10;                } ?: run {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;No Google ID Token found in One Tap credential&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;One Tap Sign-In error: ${e.message}&quot;, e)&#10;            }&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;One Tap cancelled or failed, result code: ${result.resultCode}&quot;)&#10;            // Automatischer Fallback zu klassischem Google Sign-In wenn One Tap abgebrochen wird&#10;            Log.d(&quot;LoginScreen&quot;, &quot;Starting automatic fallback to classic Google Sign-In&quot;)&#10;            try {&#10;                val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                    .requestIdToken(app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID)&#10;                    .requestEmail()&#10;                    .build()&#10;                val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;                classicLauncher.launch(googleSignInClient.signInIntent)&#10;            } catch (fallbackError: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Error with automatic fallback: ${fallbackError.message}&quot;, fallbackError)&#10;            }&#10;        }&#10;    }&#10;&#10;&#10;    // UI - Zentriertes Layout&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;            modifier = Modifier.padding(24.dp)&#10;        ) {&#10;            // Google Sign-In Button (versucht One Tap, fällt auf klassisch zurück)&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In button clicked&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Client ID: ${app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID}&quot;)&#10;&#10;                    // Definiere startClassicSignIn ZUERST&#10;                    fun startClassicSignIn() {&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Starting classic Google Sign-In with Client ID: ${app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID}&quot;)&#10;                        try {&#10;                            val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                                .requestIdToken(app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID)&#10;                                .requestEmail()&#10;                                .requestProfile()&#10;                                .build()&#10;&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;GSO configured, creating client&quot;)&#10;                            val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Launching classic sign-in intent&quot;)&#10;                            classicLauncher.launch(googleSignInClient.signInIntent)&#10;                        } catch (fallbackError: Exception) {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Error with classic sign-in: ${fallbackError.message}&quot;, fallbackError)&#10;                        }&#10;                    }&#10;&#10;                    scope.launch {&#10;                        try {&#10;                            val oneTapClient = Identity.getSignInClient(context)&#10;&#10;                            val signInRequest = BeginSignInRequest.builder()&#10;                                .setGoogleIdTokenRequestOptions(&#10;                                    BeginSignInRequest.GoogleIdTokenRequestOptions.builder()&#10;                                        .setSupported(true)&#10;                                        .setServerClientId(app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID)&#10;                                        .setFilterByAuthorizedAccounts(false)&#10;                                        .build()&#10;                                )&#10;                                .setAutoSelectEnabled(false)&#10;                                .build()&#10;&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Trying One Tap Sign-In first&quot;)&#10;                            oneTapClient.beginSignIn(signInRequest)&#10;                                .addOnSuccessListener { result -&gt;&#10;                                    Log.d(&quot;LoginScreen&quot;, &quot;One Tap available, launching One Tap&quot;)&#10;                                    try {&#10;                                        oneTapLauncher.launch(&#10;                                            androidx.activity.result.IntentSenderRequest.Builder(&#10;                                                result.pendingIntent.intentSender&#10;                                            ).build()&#10;                                        )&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;LoginScreen&quot;, &quot;Error launching One Tap intent: ${e.message}&quot;, e)&#10;                                        startClassicSignIn()&#10;                                    }&#10;                                }&#10;                                .addOnFailureListener { e -&gt;&#10;                                    Log.d(&quot;LoginScreen&quot;, &quot;One Tap not available, falling back to classic: ${e.message}&quot;)&#10;                                    startClassicSignIn()&#10;                                }&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Error setting up One Tap, falling back to classic: ${e.message}&quot;, e)&#10;                            startClassicSignIn()&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // DEBUG: Direkter klassischer Google Sign-In Button mit mehr Logging&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== DIRECT CLASSIC GOOGLE SIGN-IN DEBUG START ===&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Direct classic Google Sign-In button clicked&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Client ID: ${app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID}&quot;)&#10;&#10;                    // Prüfe aktuell angemeldeten Google Account&#10;                    val currentAccount = GoogleSignIn.getLastSignedInAccount(context)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Current signed in account: ${currentAccount?.email}&quot;)&#10;&#10;                    try {&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestIdToken(app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .build()&#10;&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;GoogleSignInOptions created successfully&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Requested scopes: ID Token, Email, Profile&quot;)&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;GoogleSignInClient created successfully&quot;)&#10;&#10;                        // Lösche vorherige Anmeldung für frischen Test&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching new sign-in&quot;)&#10;                            classicLauncher.launch(googleSignInClient.signInIntent)&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Direct classic sign-in intent launched&quot;)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error with direct classic sign-in: ${e.message}&quot;, e)&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Exception class: ${e.javaClass.simpleName}&quot;)&#10;                    }&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== DIRECT CLASSIC GOOGLE SIGN-IN DEBUG END ===&quot;)&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;DEBUG: Direkt klassisch anmelden&quot;)&#10;            }&#10;&#10;            // DEBUG: Server-Verbindung testen (mit gültigem Format)&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Testing server connection with proper error handling&quot;)&#10;                    scope.launch {&#10;                        try {&#10;                            // Teste mit einem Dummy-Token, aber erwarte einen Fehler&#10;                            viewModel.loginWithGoogle(&quot;dummy.token.testing&quot;)&#10;                        } catch (e: Exception) {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Expected server test error (this is normal): ${e.message}&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;DEBUG: Server-Verbindung testen&quot;)&#10;            }&#10;&#10;            // DEBUG: Google Play Services Status Check&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Checking Google Play Services status&quot;)&#10;                    val googleApiAvailability = GoogleApiAvailability.getInstance()&#10;                    val resultCode = googleApiAvailability.isGooglePlayServicesAvailable(context)&#10;&#10;                    when (resultCode) {&#10;                        ConnectionResult.SUCCESS -&gt; {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Google Play Services: SUCCESS - Available&quot;)&#10;                        }&#10;                        ConnectionResult.SERVICE_MISSING -&gt; {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Google Play Services: SERVICE_MISSING&quot;)&#10;                        }&#10;                        ConnectionResult.SERVICE_VERSION_UPDATE_REQUIRED -&gt; {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Google Play Services: UPDATE_REQUIRED&quot;)&#10;                        }&#10;                        ConnectionResult.SERVICE_DISABLED -&gt; {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Google Play Services: DISABLED&quot;)&#10;                        }&#10;                        else -&gt; {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Google Play Services: ERROR - Code: $resultCode&quot;)&#10;                        }&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;DEBUG: Google Play Services Status&quot;)&#10;            }&#10;&#10;&#10;            // DEBUG: Prüfe Google Sign-In Konfiguration&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== GOOGLE CONFIGURATION CHECK ===&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Client ID in use: ${app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID}&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Package name: ${context.packageName}&quot;)&#10;&#10;                    // Prüfe die letzte Anmeldung&#10;                    val lastAccount = GoogleSignIn.getLastSignedInAccount(context)&#10;                    if (lastAccount != null) {&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Last signed in account found:&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;  Email: ${lastAccount.email}&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;  Display Name: ${lastAccount.displayName}&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;  ID Token available: ${lastAccount.idToken != null}&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;  ID Token length: ${lastAccount.idToken?.length ?: 0}&quot;)&#10;&#10;                        if (lastAccount.idToken != null) {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;ID Token preview: ${lastAccount.idToken!!.take(50)}...&quot;)&#10;                            // Versuche Token an Server zu senden&#10;                            viewModel.loginWithGoogle(lastAccount.idToken!!)&#10;                        } else {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;PROBLEM: Account gefunden aber kein ID Token!&quot;)&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;Das bedeutet: Client ID ist falsch konfiguriert&quot;)&#10;                        }&#10;                    } else {&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;No previously signed in account found&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Use 'Direct Classic Sign-In' first to authenticate&quot;)&#10;                    }&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== END CONFIGURATION CHECK ===&quot;)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;DEBUG: Prüfe Google Konfiguration&quot;)&#10;            }&#10;&#10;&#10;            // DEBUG: Erweiterte Konfigurationsprüfung&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== EXTENSIVE CONFIGURATION DEBUG ===&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Current Android Client ID: ${app.chesspresso.BuildConfig.GOOGLE_CLIENT_ID}&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Web Client ID: ${app.chesspresso.BuildConfig.WEB_CLIENT_ID}&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Package Name: ${context.packageName}&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Application ID: app.chesspresso&quot;)&#10;&#10;                    // Test alle möglichen Client IDs&#10;                    val testClientIds = listOf(&#10;                        &quot;871578886913-8kr48rb5qhqfl00h2etd39smadtre5qe.apps.googleusercontent.com&quot;, // Android&#10;                        &quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com&quot;  // Web&#10;                    )&#10;&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Testing multiple Client IDs...&quot;)&#10;                    testClientIds.forEachIndexed { index, clientId -&gt;&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Test ${index + 1}: $clientId&quot;)&#10;                        try {&#10;                            val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                                .requestIdToken(clientId)&#10;                                .requestEmail()&#10;                                .build()&#10;                            val client = GoogleSignIn.getClient(context, gso)&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;  ✓ Client creation successful for: ${clientId.substring(0, 20)}...&quot;)&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;  ✗ Client creation failed for: ${clientId.substring(0, 20)}...&quot;, e)&#10;                        }&#10;                    }&#10;&#10;                    // Prüfe Google Play Services im Detail&#10;                    val gpsAvailability = GoogleApiAvailability.getInstance()&#10;                    val gpsResult = gpsAvailability.isGooglePlayServicesAvailable(context)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Play Services detailed status: $gpsResult&quot;)&#10;&#10;                    when (gpsResult) {&#10;                        ConnectionResult.SUCCESS -&gt; Log.d(&quot;LoginScreen&quot;, &quot;✓ Google Play Services: AVAILABLE&quot;)&#10;                        else -&gt; Log.e(&quot;LoginScreen&quot;, &quot;✗ Google Play Services: NOT AVAILABLE (Code: $gpsResult)&quot;)&#10;                    }&#10;&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== END EXTENSIVE DEBUG ===&quot;)&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;DEBUG: Erweiterte Diagnose&quot;)&#10;            }&#10;&#10;&#10;            // DEBUG: Einfachster Google Sign-In ohne ID Token&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== SIMPLE GOOGLE SIGN-IN TEST ===&quot;)&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Testing Google Sign-In WITHOUT ID Token request&quot;)&#10;&#10;                    try {&#10;                        // Extrem einfacher Test - NUR Email und Profile, KEIN ID Token&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            // WICHTIG: Kein .requestIdToken() hier!&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Simple GSO created without ID Token request&quot;)&#10;                        Log.d(&quot;LoginScreen&quot;, &quot;Launching simple sign-in...&quot;)&#10;&#10;                        classicLauncher.launch(googleSignInClient.signInIntent)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error with simple sign-in: ${e.message}&quot;, e)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;DEBUG: Einfacher Test (ohne ID Token)&quot;)&#10;            }&#10;&#10;&#10;            // DEBUG: Alternative Authentifizierung ohne ID Token&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== ALTERNATIVE AUTH WITHOUT ID TOKEN ===&quot;)&#10;&#10;                    try {&#10;                        // Teste mit Account ID statt ID Token&#10;                        val lastAccount = GoogleSignIn.getLastSignedInAccount(context)&#10;                        if (lastAccount != null) {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Using account ID for authentication&quot;)&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Account ID: ${lastAccount.id}&quot;)&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Account Email: ${lastAccount.email}&quot;)&#10;&#10;                            // Sende Account-Details an Server über das ViewModel&#10;                            if (lastAccount.id != null &amp;&amp; lastAccount.email != null) {&#10;                                Log.d(&quot;LoginScreen&quot;, &quot;Sending alternative auth to server...&quot;)&#10;                                viewModel.loginWithGoogleAlternative(lastAccount.id!!, lastAccount.email!!)&#10;                            } else {&#10;                                Log.e(&quot;LoginScreen&quot;, &quot;Account ID or Email is null&quot;)&#10;                            }&#10;&#10;                        } else {&#10;                            Log.e(&quot;LoginScreen&quot;, &quot;No signed in account found. Please sign in first.&quot;)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error with alternative auth: ${e.message}&quot;, e)&#10;                    }&#10;&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;=== END ALTERNATIVE AUTH ===&quot;)&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot; Mit Google anmelden (Alternative)&quot;)&#10;            }&#10;&#10;&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;            }&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In cancelled or failed&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Verwende einfaches Google Sign-In ohne ID Token (funktioniert immer)&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;                        googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package app.chesspresso.di&#10;&#10;import android.content.Context&#10;import app.chesspresso.auth.data.AuthApi&#10;import app.chesspresso.auth.data.AuthRepository&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;        &#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://10.0.2.2:8080&quot;) // Android Emulator localhost&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#10;        return retrofit.create(AuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApi: AuthApi,&#10;        @ApplicationContext context: Context&#10;    ): AuthRepository {&#10;        return AuthRepository(authApi, context)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>