<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // TEMPORÄRER WORKAROUND: Verwende Web Client ID für App UND Server&#10;        // bis das Android Client ID Problem in Google Console gelöst ist&#10;        buildConfigField(&quot;String&quot;, &quot;GOOGLE_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;&#10;        // Web Client ID - für den Server (gleiche wie oben)&#10;        buildConfigField(&quot;String&quot;, &quot;WEB_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;&#10;        // Android Client ID - für späteren Gebrauch wenn Google Console Problem gelöst&#10;        buildConfigField(&quot;String&quot;, &quot;ANDROID_CLIENT_ID&quot;, &quot;\&quot;871578886913-8kr48rb5qhqfl00h2etd39smadtre5qe.apps.googleusercontent.com\&quot;&quot;)&#10;&#10;        // SHA-1 Debug Info&#10;        buildConfigField(&quot;String&quot;, &quot;DEBUG_SHA1&quot;, &quot;\&quot;E3:D2:D2:1E:06:1D:14:ED:D1:4B:5D:22:38:48:7D:65:E6:D5:AA:2C\&quot;&quot;)&#10;    }&#10;&#10;    buildFeatures {&#10;        buildConfig = true // Aktiviere BuildConfig&#10;        compose = true&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;    //Google Identity&#10;    implementation(libs.play.services.identity)&#10;    implementation(libs.play.services.auth)&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // TEMPORÄRER WORKAROUND: Verwende Web Client ID für App UND Server&#10;        // bis das Android Client ID Problem in Google Console gelöst ist&#10;        buildConfigField(&quot;String&quot;, &quot;GOOGLE_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;&#10;        // Web Client ID - für den Server (gleiche wie oben)&#10;        buildConfigField(&quot;String&quot;, &quot;WEB_CLIENT_ID&quot;, &quot;\&quot;871578886913-glsn59sioeea2t0qjdkevr1mhiiivfvj.apps.googleusercontent.com\&quot;&quot;)&#10;&#10;        // Android Client ID - für späteren Gebrauch wenn Google Console Problem gelöst&#10;        buildConfigField(&quot;String&quot;, &quot;ANDROID_CLIENT_ID&quot;, &quot;\&quot;871578886913-8kr48rb5qhqfl00h2etd39smadtre5qe.apps.googleusercontent.com\&quot;&quot;)&#10;&#10;        // SHA-1 Debug Info&#10;        buildConfigField(&quot;String&quot;, &quot;DEBUG_SHA1&quot;, &quot;\&quot;E3:D2:D2:1E:06:1D:14:ED:D1:4B:5D:22:38:48:7D:65:E6:D5:AA:2C\&quot;&quot;)&#10;    }&#10;&#10;    buildFeatures {&#10;        buildConfig = true // Aktiviere BuildConfig&#10;        compose = true&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;    //Google Identity&#10;    implementation(libs.play.services.identity)&#10;    implementation(libs.play.services.auth)&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    package=&quot;app.chesspresso&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;        &#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;        &#10;        &lt;!-- Google Sign-In Meta-Data --&gt;&#10;        &lt;meta-data&#10;            android:name=&quot;com.google.android.gms.version&quot;&#10;            android:value=&quot;@integer/google_play_services_version&quot; /&gt;&#10;            &#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#13;&#10;    package=&quot;app.chesspresso&quot;&gt;&#13;&#10;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.GET_ACCOUNTS&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:name=&quot;.ChessPressoApplication&quot;&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#13;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#13;&#10;        tools:targetApi=&quot;31&quot;&gt;&#13;&#10;        &#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:label=&quot;@string/app_name&quot;&#13;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#13;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;        &#13;&#10;        &lt;!-- Google Sign-In Meta-Data --&gt;&#13;&#10;        &lt;meta-data&#13;&#10;            android:name=&quot;com.google.android.gms.version&quot;&#13;&#10;            android:value=&quot;@integer/google_play_services_version&quot; /&gt;&#13;&#10;            &#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/MainActivity.kt" />
              <option name="originalContent" value="package app.chesspresso&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import app.chesspresso.ui.theme.ChessPressoAppTheme&#10;import app.chesspresso.ui.theme.Creme1&#10;import app.chesspresso.ui.theme.Creme2&#10;import app.chesspresso.ui.theme.DarkBrown1&#10;import app.chesspresso.ui.theme.MidBrown2&#10;import app.chesspresso.auth.presemtation.LoginScreen&#10;import app.chesspresso.auth.presemtation.AuthViewModel&#10;import app.chesspresso.auth.presemtation.AuthState&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            ChessPressoAppTheme {&#10;                MainScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onRegisterClick(){&#10;        //register&#10;    }&#10;&#10;    @Composable&#10;    fun MainScreen(){&#10;        val navController = rememberNavController()&#10;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = &quot;main_screen&quot;&#10;        ){&#10;            composable(&quot;main_screen&quot;) {&#10;                HomeScreen(&#10;                    onLoginClick = { navController.navigate(&quot;login_screen&quot;) }, &#10;                    onRegisterClick = { onRegisterClick() }&#10;                )&#10;            }&#10;&#10;            composable(&quot;login_screen&quot;) {&#10;                val authViewModel: AuthViewModel = hiltViewModel()&#10;                LoginScreen(authViewModel)&#10;            }&#10;&#10;            //andere Seiten werden hier geaddet&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun HomeScreen(&#10;        onLoginClick: () -&gt; Unit,&#10;        onRegisterClick: () -&gt; Unit&#10;    ) {&#10;        var isConnected by remember { mutableStateOf(false) }&#10;        var connectionStatus by remember { mutableStateOf(&quot;Nicht verbunden&quot;) }&#10;        var isConnecting by remember { mutableStateOf(false) }&#10;&#10;        val authViewModel: AuthViewModel = hiltViewModel()&#10;&#10;        var isConnected by remember { mutableStateOf(false) }&#10;        var connectionStatus by remember { mutableStateOf(&quot;Nicht verbunden&quot;) }&#10;        var isConnecting by remember { mutableStateOf(false) }&#10;&#10;        val authViewModel: AuthViewModel = hiltViewModel()&#10;&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    brush = Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            DarkBrown1, MidBrown2&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.watermark_chess),&#10;                    contentDescription = &quot;ChessPresso Logo&quot;,&#10;                    modifier = Modifier.size(400.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;ChessPresso&quot;,&#10;                    fontSize = 36.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Creme1&#10;                )&#10;&#10;                Text(&#10;                // Server Verbindungs Status&#10;                Text(&#10;                    text = &quot;Server Status: $connectionStatus&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = when {&#10;                        isConnecting -&gt; Color.Yellow&#10;                        isConnected -&gt; Color.Green&#10;                        else -&gt; Color.Red&#10;                    },&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                )&#10;&#10;                // Server Verbindungs Button&#10;                    fontSize = 20.sp,&#10;                    onClick = {&#10;                        if (!isConnected &amp;&amp; !isConnecting) {&#10;                            isConnecting = true&#10;                            connectionStatus = &quot;Verbinde...&quot;&#10;&#10;                            val playerId = authViewModel.getStoredPlayerInfo()?.playerId ?: &quot;anonymous_user&quot;&#10;                            WebSocketManager.init(&#10;                                playerId = playerId,&#10;                                onSuccess = {&#10;                                    isConnected = true&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Verbunden&quot;&#10;                                },&#10;                                onFailure = { error -&gt;&#10;                                    isConnected = false&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Fehler: $error&quot;&#10;                                },&#10;                                onDisconnect = {&#10;                                    isConnected = false&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Verbindung getrennt&quot;&#10;                                }&#10;                            )&#10;                        } else if (isConnected) {&#10;                            WebSocketManager.disconnect()&#10;                        }&#10;                    },&#10;                    modifier = Modifier.padding(32.dp)&#10;                )&#10;&#10;                    enabled = !isConnecting,&#10;                // Server Verbindungs Status&#10;                        containerColor = when {&#10;                            isConnecting -&gt; MaterialTheme.colorScheme.secondary&#10;                            isConnected -&gt; MaterialTheme.colorScheme.error&#10;                            else -&gt; MaterialTheme.colorScheme.primary&#10;                        }&#10;                    text = &quot;Server Status: $connectionStatus&quot;,&#10;                    fontSize = 14.sp,&#10;                    color = when {&#10;                        text = when {&#10;                            isConnecting -&gt; &quot;Verbinde...&quot;&#10;                            isConnected -&gt; &quot;Verbindung trennen&quot;&#10;                            else -&gt; &quot;Mit Server verbinden&quot;&#10;                        },&#10;                        isConnected -&gt; Color.Green&#10;                        else -&gt; Color.Red&#10;                    },&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                Button(&#10;                    onClick = onLoginClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Einloggen&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;&#10;                // Server Verbindungs Button&#10;                Button(&#10;                    onClick = {&#10;                        if (!isConnected &amp;&amp; !isConnecting) {&#10;                    colors = ButtonDefaults.buttonColors()&#10;                            val playerId = authViewModel.getStoredPlayerInfo()?.playerId ?: &quot;anonymous_user&quot;&#10;                            WebSocketManager.init(&#10;                                playerId = playerId,&#10;                                onSuccess = {&#10;                                    isConnected = true&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Verbunden&quot;&#10;                                },&#10;                                onFailure = { error -&gt;&#10;                                    isConnected = false&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Fehler: $error&quot;&#10;                                },&#10;                                onDisconnect = {&#10;                                    isConnected = false&#10;                                    isConnecting = false&#10;                                    connectionStatus = &quot;Verbindung getrennt&quot;&#10;                                }&#10;                            )&#10;                        } else if (isConnected) {&#10;                            WebSocketManager.disconnect()&#10;                        }&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    enabled = !isConnecting,&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = when {&#10;                            isConnecting -&gt; MaterialTheme.colorScheme.secondary&#10;                            isConnected -&gt; MaterialTheme.colorScheme.error&#10;                            else -&gt; MaterialTheme.colorScheme.primary&#10;                        }&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = when {&#10;                            isConnecting -&gt; &quot;Verbinde...&quot;&#10;                            isConnected -&gt; &quot;Verbindung trennen&quot;&#10;                            else -&gt; &quot;Mit Server verbinden&quot;&#10;                        },&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                Button(&#10;                    onClick = onLoginClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Einloggen&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;&#10;                Button(&#10;                    onClick = onRegisterClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    colors = ButtonDefaults.buttonColors()&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Registrieren&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Brush&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.rememberNavController&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import dagger.hilt.android.AndroidEntryPoint&#10;import app.chesspresso.ui.theme.ChessPressoAppTheme&#10;import app.chesspresso.ui.theme.Creme1&#10;import app.chesspresso.ui.theme.Creme2&#10;import app.chesspresso.ui.theme.DarkBrown1&#10;import app.chesspresso.ui.theme.MidBrown2&#10;import app.chesspresso.auth.presemtation.LoginScreen&#10;import app.chesspresso.auth.presemtation.AuthViewModel&#10;import app.chesspresso.auth.presemtation.AuthState&#10;&#10;@AndroidEntryPoint&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            ChessPressoAppTheme {&#10;                MainScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun MainScreen(){&#10;        val navController = rememberNavController()&#10;        val authViewModel: AuthViewModel = hiltViewModel()&#10;        val authState by authViewModel.authState.collectAsState()&#10;&#10;        NavHost(&#10;            navController = navController,&#10;            startDestination = &quot;main_screen&quot;&#10;        ){&#10;            composable(&quot;main_screen&quot;) {&#10;                HomeScreen(&#10;                    onLoginClick = { navController.navigate(&quot;login_screen&quot;) }&#10;                )&#10;            }&#10;&#10;            composable(&quot;login_screen&quot;) {&#10;                LoginScreen(authViewModel)&#10;            }&#10;&#10;            composable(&quot;main_app&quot;) {&#10;                MainAppScreen(&#10;                    authViewModel = authViewModel,&#10;                    onLogout = { &#10;                        authViewModel.logout()&#10;                        navController.navigate(&quot;main_screen&quot;) {&#10;                            popUpTo(&quot;main_app&quot;) { inclusive = true }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;&#10;        // Automatische Navigation bei erfolgreicher Anmeldung&#10;        LaunchedEffect(authState) {&#10;            when (authState) {&#10;                is AuthState.Success -&gt; {&#10;                    if (navController.currentDestination?.route != &quot;main_app&quot;) {&#10;                        navController.navigate(&quot;main_app&quot;) {&#10;                            popUpTo(&quot;main_screen&quot;) { inclusive = true }&#10;                            popUpTo(&quot;login_screen&quot;) { inclusive = true }&#10;                        }&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    // Bleibe auf dem aktuellen Screen&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun MainAppScreen(&#10;        authViewModel: AuthViewModel,&#10;        onLogout: () -&gt; Unit&#10;    ) {&#10;        val authState by authViewModel.authState.collectAsState()&#10;        &#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    brush = Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            DarkBrown1, MidBrown2&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                when (val state = authState) {&#10;                    is AuthState.Success -&gt; {&#10;                        Text(&#10;                            text = &quot;Willkommen zurück!&quot;,&#10;                            fontSize = 28.sp,&#10;                            fontWeight = FontWeight.Bold,&#10;                            color = Creme1,&#10;                            modifier = Modifier.padding(bottom = 16.dp)&#10;                        )&#10;                        &#10;                        Text(&#10;                            text = state.response.name,&#10;                            fontSize = 24.sp,&#10;                            color = Creme2,&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                        &#10;                        Text(&#10;                            text = state.response.email,&#10;                            fontSize = 16.sp,&#10;                            color = Creme2,&#10;                            modifier = Modifier.padding(bottom = 32.dp)&#10;                        )&#10;                        &#10;                        Text(&#10;                            text = &quot;Verbunden mit Server ✓&quot;,&#10;                            fontSize = 16.sp,&#10;                            color = Color.Green,&#10;                            modifier = Modifier.padding(bottom = 32.dp)&#10;                        )&#10;                        &#10;                        // Hier könnten weitere App-Features wie Spiellobby, etc. kommen&#10;                        &#10;                        Button(&#10;                            onClick = onLogout,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 8.dp),&#10;                            colors = ButtonDefaults.buttonColors(&#10;                                containerColor = MaterialTheme.colorScheme.error&#10;                            )&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Abmelden&quot;,&#10;                                color = Color.White&#10;                            )&#10;                        }&#10;                    }&#10;                    else -&gt; {&#10;                        Text(&#10;                            text = &quot;Laden...&quot;,&#10;                            fontSize = 18.sp,&#10;                            color = Creme1&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    @Composable&#10;    fun HomeScreen(&#10;        onLoginClick: () -&gt; Unit&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(&#10;                    brush = Brush.verticalGradient(&#10;                        colors = listOf(&#10;                            DarkBrown1, MidBrown2&#10;                        )&#10;                    )&#10;                )&#10;        ) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.watermark_chess),&#10;                    contentDescription = &quot;ChessPresso Logo&quot;,&#10;                    modifier = Modifier.size(400.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;ChessPresso&quot;,&#10;                    fontSize = 36.sp,&#10;                    fontWeight = FontWeight.Bold,&#10;                    color = Creme1&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;Schach für Koffeinabhängige&quot;,&#10;                    fontSize = 20.sp,&#10;                    color = Creme2,&#10;                    modifier = Modifier.padding(32.dp)&#10;                )&#10;&#10;                Button(&#10;                    onClick = onLoginClick,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 8.dp),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = MaterialTheme.colorScheme.primary&#10;                    )&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Anmelden&quot;,&#10;                        color = Color.White&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presentation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presentation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presentation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with real ID token, length: ${idToken.length}&quot;)&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Sending real Google ID token to server&quot;)&#10;                val response = repository.sendTokenToServer(idToken)&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Google login successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;Google login failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;&#10;            // Wichtig: WebSocket-Verbindung auch beim automatischen Login herstellen&#10;            connectToWebSocket()&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presentation&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import javax.inject.Inject&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import app.chesspresso.auth.data.AuthRepository&#13;&#10;import app.chesspresso.auth.data.AuthResponse&#13;&#10;import app.chesspresso.auth.data.PlayerInfo&#13;&#10;import app.chesspresso.websocket.WebSocketManager&#13;&#10;import android.util.Log&#13;&#10;&#13;&#10;@HiltViewModel&#13;&#10;class AuthViewModel @Inject constructor(&#13;&#10;    private val repository: AuthRepository,&#13;&#10;    private val webSocketManager: WebSocketManager&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#13;&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#13;&#10;        checkStoredAuth()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun setErrorMessage(message: String) {&#13;&#10;        _authState.value = AuthState.Error(message)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun loginWithGoogle(idToken: String) {&#13;&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with real ID token, length: ${idToken.length}&quot;)&#13;&#10;        viewModelScope.launch {&#13;&#10;            _authState.value = AuthState.Loading&#13;&#10;            try {&#13;&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Sending real Google ID token to server&quot;)&#13;&#10;                val response = repository.sendTokenToServer(idToken)&#13;&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Google login successful for user: ${response.name}&quot;)&#13;&#10;                _authState.value = AuthState.Success(response)&#13;&#10;                connectToWebSocket()&#13;&#10;            } catch (e: Exception) {&#13;&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;Google login failed: ${e.message}&quot;, e)&#13;&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun mapErrorMessage(e: Exception): String {&#13;&#10;        return when {&#13;&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#13;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#13;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#13;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#13;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun connectToWebSocket() {&#13;&#10;        try {&#13;&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#13;&#10;            val playerInfo = repository.getStoredPlayerInfo()&#13;&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#13;&#10;&#13;&#10;            webSocketManager.init(&#13;&#10;                playerId = playerId,&#13;&#10;                onSuccess = {&#13;&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#13;&#10;                },&#13;&#10;                onFailure = { error -&gt;&#13;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#13;&#10;                },&#13;&#10;                onDisconnect = {&#13;&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#13;&#10;                }&#13;&#10;            )&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun logout() {&#13;&#10;        repository.clearStoredPlayerInfo()&#13;&#10;        webSocketManager.disconnect()&#13;&#10;        _authState.value = AuthState.Idle&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun checkStoredAuth() {&#13;&#10;        val playerInfo = repository.getStoredPlayerInfo()&#13;&#10;        if (playerInfo != null) {&#13;&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#13;&#10;            val authResponse = AuthResponse(&#13;&#10;                playerId = playerInfo.playerId,&#13;&#10;                name = playerInfo.name,&#13;&#10;                email = playerInfo.email ?: &quot;&quot;,&#13;&#10;                playedGames = playerInfo.playedGames,&#13;&#10;                win = playerInfo.win,&#13;&#10;                draw = playerInfo.draw,&#13;&#10;                lose = playerInfo.lose&#13;&#10;            )&#13;&#10;            _authState.value = AuthState.Success(authResponse)&#13;&#10;&#13;&#10;            // Wichtig: WebSocket-Verbindung auch beim automatischen Login herstellen&#13;&#10;            connectToWebSocket()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#13;&#10;        return repository.getStoredPlayerInfo()&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;sealed class AuthState {&#13;&#10;    object Idle : AuthState()&#13;&#10;    object Loading : AuthState()&#13;&#10;    data class Success(val response: AuthResponse) : AuthState()&#13;&#10;    data class Error(val message: String) : AuthState()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt" />
              <option name="originalContent" value="package app.chesspresso.di&#10;&#10;import android.content.Context&#10;import app.chesspresso.auth.data.AuthApi&#10;import app.chesspresso.auth.data.AuthRepository&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://10.0.2.2:8080&quot;) // Android Emulator localhost&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#10;        return retrofit.create(AuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApi: AuthApi,&#10;        @ApplicationContext context: Context&#10;    ): AuthRepository {&#10;        return AuthRepository(authApi, context)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.di&#10;&#10;import android.content.Context&#10;import app.chesspresso.auth.data.AuthApi&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.websocket.WebSocketManager&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://10.0.2.2:8080&quot;) // Android Emulator localhost&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#10;        return retrofit.create(AuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApi: AuthApi,&#10;        @ApplicationContext context: Context&#10;    ): AuthRepository {&#10;        return AuthRepository(authApi, context)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideWebSocketManager(): WebSocketManager {&#10;        return WebSocketManager&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>