<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/MainScaffoldScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/MainScaffoldScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.DividerDefaults&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.HorizontalDivider&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.rememberDrawerState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import app.chesspresso.R&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.screens.game.ChessGameScreen&#10;import app.chesspresso.screens.lobby.LobbyWaitingScreen&#10;import app.chesspresso.screens.lobby.PrivateLobbyScreen&#10;import app.chesspresso.screens.lobby.QuickMatchScreen&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;import app.chesspresso.viewmodel.GameViewModel&#10;import app.chesspresso.viewmodel.QuickMatchViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScaffoldScreen(&#10;    authViewModel: AuthViewModel,&#10;    outerNavController: NavHostController&#10;) {&#10;    val innerNavController = rememberNavController()&#10;    val currentRoute by innerNavController.currentBackStackEntryAsState()&#10;    val selectedRoute = currentRoute?.destination?.route ?: &quot;home&quot;&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;    val gameViewModel: GameViewModel = hiltViewModel()&#10;    val isLobbyScreen =&#10;        selectedRoute == NavRoutes.QUICK_MATCH || selectedRoute == NavRoutes.PRIVATE_LOBBY&#10;    val isGameScreen = selectedRoute.startsWith(&quot;game/&quot;)&#10;    val chessGameViewModel: ChessGameViewModel = hiltViewModel()&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        scrimColor = MaterialTheme.colorScheme.scrim.copy(alpha = 0.5f),&#10;        drawerContent = {&#10;            if (isGameScreen) {&#10;                val currentGameState by chessGameViewModel.currentGameState.collectAsState()&#10;                val myColor by chessGameViewModel.myColor.collectAsState()&#10;                val initialGameData by chessGameViewModel.initialGameData.collectAsState()&#10;                val moveHistory by chessGameViewModel.moveHistory.collectAsState()&#10;                ModalDrawerSheet(&#10;                    modifier = Modifier.background(app.chesspresso.ui.theme.CoffeeCremeLight)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .background(app.chesspresso.ui.theme.CoffeeCremeLight)&#10;                            .padding(16.dp)&#10;                    ) {&#10;                        Spacer(modifier = Modifier.height(32.dp))&#10;                        GameDrawerContent(&#10;                            currentGameState = currentGameState,&#10;                            moves = moveHistory,&#10;                            onResign = {&#10;                                if (myColor != null) {&#10;                                    chessGameViewModel.resignGame(myColor!!, &quot;&quot;)&#10;                                }&#10;                            },&#10;                            onOfferDraw = {&#10;                                if (myColor != null) {&#10;                                    chessGameViewModel.offerDraw(&quot;&quot;, myColor!!)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(&#10;            topBar = {&#10;                MainTopAppBar(&#10;                    isGameScreen = isGameScreen,&#10;                    isLobbyScreen = isLobbyScreen,&#10;                    onMenuClick = { scope.launch { drawerState.open() } },&#10;                    onBackClick = { innerNavController.navigateUp() }&#10;                )&#10;            },&#10;            bottomBar = {&#10;                MainBottomBar(&#10;                    isGameScreen = isGameScreen,&#10;                    selectedRoute = selectedRoute,&#10;                    onItemClick = { item -&gt;&#10;                        if (selectedRoute != item.route) {&#10;                            if (item.route == NavRoutes.STATS) {&#10;                                innerNavController.navigate(NavRoutes.STATS) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = false }&#10;                                    launchSingleTop = true&#10;                                }&#10;                            } else {&#10;                                innerNavController.navigate(item.route) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = false }&#10;                                    launchSingleTop = true&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            MainNavHost(&#10;                innerNavController = innerNavController,&#10;                modifier = Modifier.padding(padding),&#10;                authViewModel = authViewModel,&#10;                outerNavController = outerNavController,&#10;                gameViewModel = gameViewModel,&#10;                chessGameViewModel = chessGameViewModel,&#10;                scope = scope,&#10;                drawerState = drawerState&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameDrawerContent(&#10;    currentGameState: GameMoveResponse?,&#10;    moves: List&lt;GameMoveResponse&gt;,&#10;    onResign: () -&gt; Unit = {},&#10;    onOfferDraw: () -&gt; Unit = {}&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .padding(16.dp)&#10;            .fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            &quot;Spielverlauf&quot;,&#10;            style = MaterialTheme.typography.titleLarge&#10;        )&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Display game state information&#10;        currentGameState?.let { gameState -&gt;&#10;            if (gameState.isCheck != &quot;&quot;) {&#10;                Text(&#10;                    &quot;Schach!&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.error&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;        }&#10;&#10;        Button(&#10;            onClick = onResign,&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = MaterialTheme.colorScheme.error&#10;            ),&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Aufgeben&quot;)&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(&#10;            onClick = onOfferDraw,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Remis anbieten&quot;)&#10;        }&#10;        HorizontalDivider(&#10;            modifier = Modifier.padding(vertical = 16.dp),&#10;            thickness = DividerDefaults.Thickness,&#10;            color = DividerDefaults.color&#10;        )&#10;&#10;        // Anzeige der getätigten Züge&#10;        Text(&quot;Getätigte Züge:&quot;, style = MaterialTheme.typography.titleMedium, color = MaterialTheme.colorScheme.primary)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        if (moves.isEmpty()) {&#10;            Text(&quot;Noch keine Züge.&quot;, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurface)&#10;        } else {&#10;            LazyColumn(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                this@LazyColumn.itemsIndexed(moves) { index: Int, move: GameMoveResponse -&gt;&#10;                    val color = getMoveColor(index)&#10;                    val pieceUnicode = getPieceUnicode(move.move.piece, color)&#10;                    val pieceColor = if (color == TeamColor.WHITE) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurfaceVariant&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .background(app.chesspresso.ui.theme.CoffeeCremeLight),&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = app.chesspresso.ui.theme.CoffeeCremeMid&#10;                        ),&#10;                        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier.padding(8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;${index + 1}.&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            Text(&#10;                                text = pieceUnicode + &quot;: &quot;,&#10;                                color = pieceColor,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                modifier = Modifier.width(28.dp)&#10;                            )&#10;                            Text(&#10;                                text = &quot;${move.move.start} -&gt; ${move.move.end}&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurface,&#10;                                modifier = Modifier.padding(start = 8.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;                            if (move.move.specialMove != null) {&#10;                                Text(&#10;                                    text = move.move.specialMove.toString(),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.secondary&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun getPieceUnicode(piece: PieceType, color: TeamColor): String = when (piece) {&#10;    PieceType.KING   -&gt; if (color == TeamColor.WHITE) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;    PieceType.QUEEN  -&gt; if (color == TeamColor.WHITE) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;    PieceType.ROOK   -&gt; if (color == TeamColor.WHITE) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;    PieceType.BISHOP -&gt; if (color == TeamColor.WHITE) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;    PieceType.KNIGHT -&gt; if (color == TeamColor.WHITE) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;    PieceType.PAWN   -&gt; if (color == TeamColor.WHITE) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;    else -&gt; &quot;&quot;&#10;}&#10;&#10;private fun getMoveColor(index: Int, firstMoveColor: TeamColor = TeamColor.WHITE): TeamColor =&#10;    if (index % 2 == 0) firstMoveColor else if (firstMoveColor == TeamColor.WHITE) TeamColor.BLACK else TeamColor.WHITE&#10;&#10;enum class NavigationItem(val label: String, val icon: ImageVector, val route: String) {&#10;    Profile(&quot;Profil&quot;, Icons.Default.Person, NavRoutes.PROFILE),&#10;    Stats(&quot;Statistik&quot;, Icons.Default.Search, NavRoutes.STATS), //durch Statistik Icon ersetzen&#10;    Gameplay(&quot;Spielen&quot;, Icons.Default.Home, NavRoutes.HOME), //durch Schach-Icon ersetzen&#10;    Settings(&quot;Optionen&quot;, Icons.Default.Settings, NavRoutes.SETTINGS)&#10;}&#10;&#10;&#10;object NavRoutes {&#10;    const val HOME = &quot;home&quot;&#10;    const val PROFILE = &quot;profile&quot;&#10;    const val STATS = &quot;stats&quot;&#10;    const val SETTINGS = &quot;settings&quot;&#10;    const val QUICK_MATCH = &quot;quick_match&quot;&#10;    const val PRIVATE_LOBBY = &quot;private_lobby&quot;&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainTopAppBar(&#10;    isGameScreen: Boolean,&#10;    isLobbyScreen: Boolean,&#10;    onMenuClick: () -&gt; Unit,&#10;    onBackClick: () -&gt; Unit&#10;) {&#10;    TopAppBar(&#10;        navigationIcon = {&#10;            when {&#10;                isGameScreen -&gt; {&#10;                    IconButton(onClick = onMenuClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Menu,&#10;                            contentDescription = &quot;Menü&quot;&#10;                        )&#10;                    }&#10;                }&#10;                isLobbyScreen -&gt; {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Zurück&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.watermark_chess),&#10;                    contentDescription = &quot;App-Logo&quot;,&#10;                    modifier = Modifier&#10;                        .size(32.dp)&#10;                        .padding(end = 8.dp),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;                Text(&quot;ChessPresso&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MainBottomBar(&#10;    isGameScreen: Boolean,&#10;    selectedRoute: String,&#10;    onItemClick: (NavigationItem) -&gt; Unit&#10;) {&#10;    if (!isGameScreen) {&#10;        NavigationBar(&#10;            containerColor = MaterialTheme.colorScheme.surface,&#10;            contentColor = MaterialTheme.colorScheme.onSurface&#10;        ) {&#10;            NavigationItem.entries.forEach { item -&gt;&#10;                NavigationBarItem(&#10;                    icon = { Icon(item.icon, contentDescription = item.label) },&#10;                    label = { Text(item.label) },&#10;                    selected = item.route == selectedRoute,&#10;                    onClick = { onItemClick(item) },&#10;                    colors = androidx.compose.material3.NavigationBarItemDefaults.colors(&#10;                        selectedIconColor = MaterialTheme.colorScheme.primary,&#10;                        unselectedIconColor = MaterialTheme.colorScheme.onSurface,&#10;                        selectedTextColor = MaterialTheme.colorScheme.primary,&#10;                        unselectedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                        indicatorColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainNavHost(&#10;    innerNavController: NavHostController,&#10;    modifier: Modifier,&#10;    authViewModel: AuthViewModel,&#10;    outerNavController: NavHostController,&#10;    gameViewModel: GameViewModel,&#10;    chessGameViewModel: ChessGameViewModel,&#10;    scope: kotlinx.coroutines.CoroutineScope,&#10;    drawerState: androidx.compose.material3.DrawerState&#10;) {&#10;    val currentRoute by innerNavController.currentBackStackEntryAsState()&#10;    val selectedRoute = currentRoute?.destination?.route ?: &quot;home&quot;&#10;    // Wenn sich der Screen ändert, Drawer schließen, falls es ein GameScreen ist&#10;    LaunchedEffect(selectedRoute) {&#10;        if (selectedRoute.startsWith(&quot;game/&quot;)) {&#10;            drawerState.close()&#10;        }&#10;    }&#10;&#10;    NavHost(&#10;        navController = innerNavController,&#10;        startDestination = NavRoutes.HOME,&#10;        modifier = modifier&#10;    ) {&#10;        composable(NavRoutes.HOME) {&#10;            HomeScreen(&#10;                onPrivateGameClick = { innerNavController.navigate(NavRoutes.PRIVATE_LOBBY) },&#10;                onPublicGameClick = { innerNavController.navigate(NavRoutes.QUICK_MATCH) }&#10;            )&#10;        }&#10;        composable(NavRoutes.QUICK_MATCH) {&#10;            val quickMatchViewModel: QuickMatchViewModel = hiltViewModel()&#10;            LaunchedEffect(Unit) { quickMatchViewModel.reset() }&#10;            QuickMatchScreen(&#10;                onGameStart = { lobbyId -&gt; innerNavController.navigate(&quot;game/$lobbyId&quot;) },&#10;                viewModel = quickMatchViewModel&#10;            )&#10;        }&#10;        composable(NavRoutes.PRIVATE_LOBBY) {&#10;            PrivateLobbyScreen(&#10;                onLobbyCreated = { lobbyCode -&gt; innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/true&quot;) },&#10;                onLobbyJoined = { lobbyCode -&gt; innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/false&quot;) }&#10;            )&#10;        }&#10;        composable(&quot;lobby_waiting/{lobbyCode}/{isCreator}&quot;) { backStackEntry -&gt;&#10;            val lobbyCode = backStackEntry.arguments?.getString(&quot;lobbyCode&quot;) ?: &quot;&quot;&#10;            val isCreator = backStackEntry.arguments?.getString(&quot;isCreator&quot;)?.toBoolean() ?: false&#10;            LobbyWaitingScreen(&#10;                isCreator = isCreator,&#10;                lobbyCode = lobbyCode,&#10;                onBackClick = {&#10;                    gameViewModel.reset()&#10;                    innerNavController.navigate(NavRoutes.HOME) {&#10;                        popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                        launchSingleTop = true&#10;                    }&#10;                },&#10;                onGameStart = { lobbyId -&gt; innerNavController.navigate(&quot;game/$lobbyId&quot;) },&#10;                chessGameViewModel = chessGameViewModel&#10;            )&#10;        }&#10;        composable(NavRoutes.STATS) { StatsScreen(navController = innerNavController) }&#10;        composable(&quot;game_detail/{gameId}&quot;) { backStackEntry -&gt;&#10;            val gameId = backStackEntry.arguments?.getString(&quot;gameId&quot;) ?: &quot;&quot;&#10;            GameDetailScreen(navController = innerNavController, gameId = gameId, gameViewModel = gameViewModel)&#10;        }&#10;        composable(NavRoutes.PROFILE) {&#10;            ProfileScreen(&#10;                authViewModel = authViewModel,&#10;                onLogout = {&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;welcome&quot;) { popUpTo(0) }&#10;                },&#10;                outerNavController = outerNavController&#10;            )&#10;        }&#10;        composable(NavRoutes.SETTINGS) { SettingsScreen() }&#10;        composable(&quot;game/{lobbyId}&quot;) { backStackEntry -&gt;&#10;            val gameStartResponse by chessGameViewModel.initialGameData.collectAsState()&#10;            val playerId = chessGameViewModel.webSocketService.playerId ?: &quot;&quot;&#10;            if (gameStartResponse != null) {&#10;                ChessGameScreen(&#10;                    gameStartResponse = gameStartResponse!!,&#10;                    viewModel = chessGameViewModel,&#10;                    playerId = playerId,&#10;                    navController = innerNavController,&#10;                    onGameEnd = { scope.launch { drawerState.close() } }&#10;                )&#10;            } else {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.automirrored.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Menu&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.DividerDefaults&#10;import androidx.compose.material3.DrawerValue&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.HorizontalDivider&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.ModalDrawerSheet&#10;import androidx.compose.material3.ModalNavigationDrawer&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.material3.rememberDrawerState&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import app.chesspresso.R&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.model.PieceType&#10;import app.chesspresso.model.TeamColor&#10;import app.chesspresso.model.game.GameMoveResponse&#10;import app.chesspresso.screens.game.ChessGameScreen&#10;import app.chesspresso.screens.lobby.LobbyWaitingScreen&#10;import app.chesspresso.screens.lobby.PrivateLobbyScreen&#10;import app.chesspresso.screens.lobby.QuickMatchScreen&#10;import app.chesspresso.viewmodel.ChessGameViewModel&#10;import app.chesspresso.viewmodel.GameViewModel&#10;import app.chesspresso.viewmodel.QuickMatchViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScaffoldScreen(&#10;    authViewModel: AuthViewModel,&#10;    outerNavController: NavHostController&#10;) {&#10;    val innerNavController = rememberNavController()&#10;    val currentRoute by innerNavController.currentBackStackEntryAsState()&#10;    val selectedRoute = currentRoute?.destination?.route ?: &quot;home&quot;&#10;&#10;    val drawerState = rememberDrawerState(initialValue = DrawerValue.Closed)&#10;    val scope = rememberCoroutineScope()&#10;    val gameViewModel: GameViewModel = hiltViewModel()&#10;    val isLobbyScreen =&#10;        selectedRoute == NavRoutes.QUICK_MATCH || selectedRoute == NavRoutes.PRIVATE_LOBBY&#10;    val isGameScreen = selectedRoute.startsWith(&quot;game/&quot;)&#10;    val chessGameViewModel: ChessGameViewModel = hiltViewModel()&#10;&#10;    ModalNavigationDrawer(&#10;        drawerState = drawerState,&#10;        scrimColor = MaterialTheme.colorScheme.scrim.copy(alpha = 0.5f),&#10;        drawerContent = {&#10;            if (isGameScreen) {&#10;                val currentGameState by chessGameViewModel.currentGameState.collectAsState()&#10;                val myColor by chessGameViewModel.myColor.collectAsState()&#10;                val initialGameData by chessGameViewModel.initialGameData.collectAsState()&#10;                val moveHistory by chessGameViewModel.moveHistory.collectAsState()&#10;                ModalDrawerSheet(&#10;                    modifier = Modifier.background(app.chesspresso.ui.theme.CoffeeCremeLight)&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .background(app.chesspresso.ui.theme.CoffeeCremeLight)&#10;                            .padding(16.dp)&#10;                    ) {&#10;                        Spacer(modifier = Modifier.height(32.dp))&#10;                        GameDrawerContent(&#10;                            currentGameState = currentGameState,&#10;                            moves = moveHistory,&#10;                            onResign = {&#10;                                if (myColor != null) {&#10;                                    chessGameViewModel.resignGame(myColor!!, &quot;&quot;)&#10;                                }&#10;                            },&#10;                            onOfferDraw = {&#10;                                if (myColor != null) {&#10;                                    chessGameViewModel.offerDraw(&quot;&quot;, myColor!!)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    ) {&#10;        Scaffold(&#10;            topBar = {&#10;                MainTopAppBar(&#10;                    isGameScreen = isGameScreen,&#10;                    isLobbyScreen = isLobbyScreen,&#10;                    onMenuClick = { scope.launch { drawerState.open() } },&#10;                    onBackClick = { innerNavController.navigateUp() }&#10;                )&#10;            },&#10;            bottomBar = {&#10;                MainBottomBar(&#10;                    isGameScreen = isGameScreen,&#10;                    selectedRoute = selectedRoute,&#10;                    onItemClick = { item -&gt;&#10;                        if (selectedRoute != item.route) {&#10;                            if (item.route == NavRoutes.STATS) {&#10;                                innerNavController.navigate(NavRoutes.STATS) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = false }&#10;                                    launchSingleTop = true&#10;                                }&#10;                            } else {&#10;                                innerNavController.navigate(item.route) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = false }&#10;                                    launchSingleTop = true&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        ) { padding -&gt;&#10;            MainNavHost(&#10;                innerNavController = innerNavController,&#10;                modifier = Modifier.padding(padding),&#10;                authViewModel = authViewModel,&#10;                outerNavController = outerNavController,&#10;                gameViewModel = gameViewModel,&#10;                chessGameViewModel = chessGameViewModel,&#10;                scope = scope,&#10;                drawerState = drawerState&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun GameDrawerContent(&#10;    currentGameState: GameMoveResponse?,&#10;    moves: List&lt;GameMoveResponse&gt;,&#10;    onResign: () -&gt; Unit = {},&#10;    onOfferDraw: () -&gt; Unit = {}&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .padding(16.dp)&#10;            .fillMaxSize(),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        Text(&#10;            &quot;Spielverlauf&quot;,&#10;            style = MaterialTheme.typography.titleLarge&#10;        )&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Display game state information&#10;        currentGameState?.let { gameState -&gt;&#10;            if (gameState.isCheck != &quot;&quot;) {&#10;                Text(&#10;                    &quot;Schach!&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    color = MaterialTheme.colorScheme.error&#10;                )&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;            }&#10;        }&#10;&#10;        Button(&#10;            onClick = onResign,&#10;            colors = ButtonDefaults.buttonColors(&#10;                containerColor = MaterialTheme.colorScheme.error&#10;            ),&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Aufgeben&quot;)&#10;        }&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        Button(&#10;            onClick = onOfferDraw,&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Text(&quot;Remis anbieten&quot;)&#10;        }&#10;        HorizontalDivider(&#10;            modifier = Modifier.padding(vertical = 16.dp),&#10;            thickness = DividerDefaults.Thickness,&#10;            color = DividerDefaults.color&#10;        )&#10;&#10;        // Anzeige der getätigten Züge&#10;        Text(&quot;Getätigte Züge:&quot;, style = MaterialTheme.typography.titleMedium, color = MaterialTheme.colorScheme.primary)&#10;        Spacer(modifier = Modifier.height(8.dp))&#10;        if (moves.isEmpty()) {&#10;            Text(&quot;Noch keine Züge.&quot;, style = MaterialTheme.typography.bodySmall, color = MaterialTheme.colorScheme.onSurface)&#10;        } else {&#10;            LazyColumn(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                this@LazyColumn.itemsIndexed(moves) { index: Int, move: GameMoveResponse -&gt;&#10;                    val color = getMoveColor(index)&#10;                    val pieceUnicode = getPieceUnicode(move.move.piece, color)&#10;                    val pieceColor = if (color == TeamColor.WHITE) MaterialTheme.colorScheme.onSurface else MaterialTheme.colorScheme.onSurfaceVariant&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .background(app.chesspresso.ui.theme.CoffeeCremeLight),&#10;                        colors = CardDefaults.cardColors(&#10;                            containerColor = app.chesspresso.ui.theme.CoffeeCremeMid&#10;                        ),&#10;                        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)&#10;                    ) {&#10;                        Row(&#10;                            modifier = Modifier.padding(8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;${index + 1}.&quot;,&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            Text(&#10;                                text = pieceUnicode + &quot;: &quot;,&#10;                                color = pieceColor,&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                modifier = Modifier.width(28.dp)&#10;                            )&#10;                            Text(&#10;                                text = &quot;${move.move.start} -&gt; ${move.move.end}&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.onSurface,&#10;                                modifier = Modifier.padding(start = 8.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.weight(1f))&#10;                            if (move.move.specialMove != null) {&#10;                                Text(&#10;                                    text = move.move.specialMove.toString(),&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.secondary&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;private fun getPieceUnicode(piece: PieceType, color: TeamColor): String = when (piece) {&#10;    PieceType.KING   -&gt; if (color == TeamColor.WHITE) &quot;\u2654&quot; else &quot;\u265A&quot;&#10;    PieceType.QUEEN  -&gt; if (color == TeamColor.WHITE) &quot;\u2655&quot; else &quot;\u265B&quot;&#10;    PieceType.ROOK   -&gt; if (color == TeamColor.WHITE) &quot;\u2656&quot; else &quot;\u265C&quot;&#10;    PieceType.BISHOP -&gt; if (color == TeamColor.WHITE) &quot;\u2657&quot; else &quot;\u265D&quot;&#10;    PieceType.KNIGHT -&gt; if (color == TeamColor.WHITE) &quot;\u2658&quot; else &quot;\u265E&quot;&#10;    PieceType.PAWN   -&gt; if (color == TeamColor.WHITE) &quot;\u2659&quot; else &quot;\u265F&quot;&#10;    else -&gt; &quot;&quot;&#10;}&#10;&#10;private fun getMoveColor(index: Int, firstMoveColor: TeamColor = TeamColor.WHITE): TeamColor =&#10;    if (index % 2 == 0) firstMoveColor else if (firstMoveColor == TeamColor.WHITE) TeamColor.BLACK else TeamColor.WHITE&#10;&#10;enum class NavigationItem(val label: String, val icon: ImageVector, val route: String) {&#10;    Profile(&quot;Profil&quot;, Icons.Default.Person, NavRoutes.PROFILE),&#10;    Stats(&quot;Statistik&quot;, Icons.Default.Search, NavRoutes.STATS), //durch Statistik Icon ersetzen&#10;    Gameplay(&quot;Spielen&quot;, Icons.Default.Home, NavRoutes.HOME), //durch Schach-Icon ersetzen&#10;    Settings(&quot;Optionen&quot;, Icons.Default.Settings, NavRoutes.SETTINGS)&#10;}&#10;&#10;&#10;object NavRoutes {&#10;    const val HOME = &quot;home&quot;&#10;    const val PROFILE = &quot;profile&quot;&#10;    const val STATS = &quot;stats&quot;&#10;    const val SETTINGS = &quot;settings&quot;&#10;    const val QUICK_MATCH = &quot;quick_match&quot;&#10;    const val PRIVATE_LOBBY = &quot;private_lobby&quot;&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainTopAppBar(&#10;    isGameScreen: Boolean,&#10;    isLobbyScreen: Boolean,&#10;    onMenuClick: () -&gt; Unit,&#10;    onBackClick: () -&gt; Unit&#10;) {&#10;    TopAppBar(&#10;        navigationIcon = {&#10;            when {&#10;                isGameScreen -&gt; {&#10;                    IconButton(onClick = onMenuClick) {&#10;                        Icon(&#10;                            imageVector = Icons.Default.Menu,&#10;                            contentDescription = &quot;Menü&quot;&#10;                        )&#10;                    }&#10;                }&#10;                isLobbyScreen -&gt; {&#10;                    IconButton(onClick = onBackClick) {&#10;                        Icon(&#10;                            imageVector = Icons.AutoMirrored.Filled.ArrowBack,&#10;                            contentDescription = &quot;Zurück&quot;&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        },&#10;        title = {&#10;            Row(verticalAlignment = Alignment.CenterVertically) {&#10;                Image(&#10;                    painter = painterResource(id = R.drawable.watermark_chess),&#10;                    contentDescription = &quot;App-Logo&quot;,&#10;                    modifier = Modifier&#10;                        .size(32.dp)&#10;                        .padding(end = 8.dp),&#10;                    contentScale = ContentScale.Fit&#10;                )&#10;                Text(&quot;ChessPresso&quot;)&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;@Composable&#10;fun MainBottomBar(&#10;    isGameScreen: Boolean,&#10;    selectedRoute: String,&#10;    onItemClick: (NavigationItem) -&gt; Unit&#10;) {&#10;    if (!isGameScreen) {&#10;        NavigationBar(&#10;            containerColor = MaterialTheme.colorScheme.surface,&#10;            contentColor = MaterialTheme.colorScheme.onSurface&#10;        ) {&#10;            NavigationItem.entries.forEach { item -&gt;&#10;                NavigationBarItem(&#10;                    icon = { Icon(item.icon, contentDescription = item.label) },&#10;                    label = { Text(item.label) },&#10;                    selected = item.route == selectedRoute,&#10;                    onClick = { onItemClick(item) },&#10;                    colors = androidx.compose.material3.NavigationBarItemDefaults.colors(&#10;                        selectedIconColor = MaterialTheme.colorScheme.primary,&#10;                        unselectedIconColor = MaterialTheme.colorScheme.onSurface,&#10;                        selectedTextColor = MaterialTheme.colorScheme.primary,&#10;                        unselectedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                        indicatorColor = MaterialTheme.colorScheme.surface&#10;                    )&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainNavHost(&#10;    innerNavController: NavHostController,&#10;    modifier: Modifier,&#10;    authViewModel: AuthViewModel,&#10;    outerNavController: NavHostController,&#10;    gameViewModel: GameViewModel,&#10;    chessGameViewModel: ChessGameViewModel,&#10;    scope: kotlinx.coroutines.CoroutineScope,&#10;    drawerState: androidx.compose.material3.DrawerState&#10;) {&#10;    val currentRoute by innerNavController.currentBackStackEntryAsState()&#10;    val selectedRoute = currentRoute?.destination?.route ?: &quot;home&quot;&#10;    // Wenn sich der Screen ändert, Drawer schließen, falls es ein GameScreen ist&#10;    LaunchedEffect(selectedRoute) {&#10;        if (selectedRoute.startsWith(&quot;game/&quot;)) {&#10;            drawerState.close()&#10;        }&#10;    }&#10;&#10;    NavHost(&#10;        navController = innerNavController,&#10;        startDestination = NavRoutes.HOME,&#10;        modifier = modifier&#10;    ) {&#10;        composable(NavRoutes.HOME) {&#10;            HomeScreen(&#10;                onPrivateGameClick = { innerNavController.navigate(NavRoutes.PRIVATE_LOBBY) },&#10;                onPublicGameClick = { innerNavController.navigate(NavRoutes.QUICK_MATCH) }&#10;            )&#10;        }&#10;        composable(NavRoutes.QUICK_MATCH) {&#10;            val quickMatchViewModel: QuickMatchViewModel = hiltViewModel()&#10;            LaunchedEffect(Unit) { quickMatchViewModel.reset() }&#10;            QuickMatchScreen(&#10;                onGameStart = { lobbyId -&gt; innerNavController.navigate(&quot;game/$lobbyId&quot;) },&#10;                viewModel = quickMatchViewModel&#10;            )&#10;        }&#10;        composable(NavRoutes.PRIVATE_LOBBY) {&#10;            PrivateLobbyScreen(&#10;                onLobbyCreated = { lobbyCode -&gt; innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/true&quot;) },&#10;                onLobbyJoined = { lobbyCode -&gt; innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/false&quot;) }&#10;            )&#10;        }&#10;        composable(&quot;lobby_waiting/{lobbyCode}/{isCreator}&quot;) { backStackEntry -&gt;&#10;            val lobbyCode = backStackEntry.arguments?.getString(&quot;lobbyCode&quot;) ?: &quot;&quot;&#10;            val isCreator = backStackEntry.arguments?.getString(&quot;isCreator&quot;)?.toBoolean() ?: false&#10;            LobbyWaitingScreen(&#10;                isCreator = isCreator,&#10;                lobbyCode = lobbyCode,&#10;                onBackClick = {&#10;                    gameViewModel.reset()&#10;                    innerNavController.navigate(NavRoutes.HOME) {&#10;                        popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                        launchSingleTop = true&#10;                    }&#10;                },&#10;                onGameStart = { lobbyId -&gt; innerNavController.navigate(&quot;game/$lobbyId&quot;) },&#10;                chessGameViewModel = chessGameViewModel&#10;            )&#10;        }&#10;        composable(NavRoutes.STATS) { StatsScreen(navController = innerNavController) }&#10;        composable(&quot;game_detail/{gameId}&quot;) { backStackEntry -&gt;&#10;            val gameId = backStackEntry.arguments?.getString(&quot;gameId&quot;) ?: &quot;&quot;&#10;            GameDetailScreen(navController = innerNavController, gameId = gameId, gameViewModel = gameViewModel)&#10;        }&#10;        composable(NavRoutes.PROFILE) {&#10;            ProfileScreen(&#10;                authViewModel = authViewModel,&#10;                onLogout = {&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;welcome&quot;) { popUpTo(0) }&#10;                },&#10;                outerNavController = outerNavController&#10;            )&#10;        }&#10;        composable(NavRoutes.SETTINGS) { SettingsScreen() }&#10;        composable(&quot;game/{lobbyId}&quot;) { backStackEntry -&gt;&#10;            val gameStartResponse by chessGameViewModel.initialGameData.collectAsState()&#10;            val playerId = chessGameViewModel.webSocketService.playerId ?: &quot;&quot;&#10;            if (gameStartResponse != null) {&#10;                ChessGameScreen(&#10;                    gameStartResponse = gameStartResponse!!,&#10;                    viewModel = chessGameViewModel,&#10;                    playerId = playerId,&#10;                    navController = innerNavController,&#10;                    onGameEnd = { scope.launch { drawerState.close() } }&#10;                )&#10;            } else {&#10;                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                    CircularProgressIndicator()&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>