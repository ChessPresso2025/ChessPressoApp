<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/workflows/sonarcloud.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/workflows/sonarcloud.yml" />
              <option name="originalContent" value="name: SonarCloud&#10;&#10;on:&#10;  pull_request:&#10;    branches:&#10;      - main&#10;      - development&#10;  push:&#10;    branches:&#10;      - main&#10;      - development&#10;&#10;jobs:&#10;  build:&#10;    name: Build and analyze on SonarCloud&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;      - uses: actions/checkout@v4&#10;      - name: Set up JDK 17&#10;        uses: actions/setup-java@v4&#10;        with:&#10;          distribution: 'temurin'&#10;          java-version: '17'&#10;      - name: Cache Gradle packages&#10;        uses: actions/cache@v4&#10;        with:&#10;          path: |&#10;            ~/.gradle/caches&#10;            ~/.gradle/wrapper&#10;          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}&#10;          restore-keys: |&#10;            ${{ runner.os }}-gradle-&#10;      - name: Grant execute permission for gradlew&#10;        run: chmod +x ./gradlew&#10;      - name: Build&#10;        run: ./gradlew build --info --stacktrace&#10;      - name: Analyze with SonarCloud&#10;        env:&#10;          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}&#10;        run: ./gradlew sonar --info --stacktrace" />
              <option name="updatedContent" value="name: SonarCloud&#10;&#10;on:&#10;  pull_request:&#10;    branches:&#10;      - main&#10;      - development&#10;  push:&#10;    branches:&#10;      - main&#10;      - development&#10;&#10;jobs:&#10;  build:&#10;    name: Build and analyze on SonarCloud&#10;    runs-on: ubuntu-latest&#10;    steps:&#10;      - uses: actions/checkout@v4&#10;      - name: Set up JDK 17&#10;        uses: actions/setup-java@v4&#10;        with:&#10;          distribution: 'temurin'&#10;          java-version: '17'&#10;      - name: Cache Gradle packages&#10;        uses: actions/cache@v4&#10;        with:&#10;          path: |&#10;            ~/.gradle/caches&#10;            ~/.gradle/wrapper&#10;          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}&#10;          restore-keys: |&#10;            ${{ runner.os }}-gradle-&#10;      - name: Grant execute permission for gradlew&#10;        run: chmod +x ./gradlew&#10;      - name: Build&#10;        run: ./gradlew build --info --stacktrace&#10;      - name: Analyze with SonarCloud&#10;        env:&#10;          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}&#10;        run: ./gradlew sonar --info --stacktrace" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Casino&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    isCreator: Boolean,&#10;    lobbyCode: String,&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val navigationEvent by viewModel.navigationEvent.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameTime by remember { mutableStateOf(GameTime.MIDDLE) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;    // Farbauswahl-State auf Composable-Ebene&#10;    var colorChoice by remember { mutableStateOf(&quot;random&quot;) } // Werte: &quot;black&quot;, &quot;white&quot;, &quot;random&quot;&#10;&#10;&#10;&#10;    // Navigation nach Home wenn Lobby verlassen wurde&#10;    LaunchedEffect(navigationEvent) {&#10;        if (navigationEvent == &quot;home&quot;) {&#10;            onBackClick()&#10;            viewModel.onNavigated()&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        CoffeeHeadlineText(&#10;            text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;&#10;        )&#10;&#10;        // nur wenn nur ein Spieler in der Lobby ist&#10;        if (currentLobby?.players?.size != 2) {&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CoffeeText(&#10;                            text = &quot;Teile diesen Code mit deinem Freund&quot;,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                },&#10;            )&#10;        }&#10;&#10;        // QR-Code für Lobby-Ersteller anzeigen (nur wenn noch Platz frei ist)&#10;        if (isCreator &amp;&amp; currentLobby?.players?.size != 2) {&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Spieler-Status&#10;        CoffeeCard(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            content = {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2):&quot;&#10;                    )&#10;&#10;                    currentLobby?.let { lobby -&gt;&#10;                        lobby.players.forEachIndexed { _, player -&gt;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Person,&#10;                                    contentDescription = null,&#10;                                    tint = MaterialTheme.colorScheme.primary&#10;                                )&#10;                                CoffeeText(&#10;                                    text = &quot;${player}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        if (currentLobby?.players?.size != 2) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(24.dp),&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                                CoffeeText(&#10;                                    text = &quot;Warte auf zweiten Spieler...&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            },&#10;        )&#10;        CoffeeHeadlineText(&#10;            text = &quot;Spiel-Einstellungen&quot;,&#10;            fontSizeSp = 24&#10;        )&#10;&#10;        // Spieleinstellungen Card (nur für Ersteller)&#10;        currentLobby?.let { lobby -&gt;&#10;            if (isCreator) {&#10;                CoffeeCard(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    content = {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;&#10;                            CoffeeText(&#10;                                text = &quot;Spielzeit:&quot;&#10;                            )&#10;                            GameTimeSelectionRow(&#10;                                selectedGameTime = selectedGameTime,&#10;                                onGameTimeSelected = { selectedGameTime = it },&#10;                                allowedTimes = GameTime.entries.toList()&#10;                            )&#10;                        }&#10;                    },&#10;                )&#10;&#10;                // Farbauswahl Card (nur wenn beide Spieler da sind)&#10;                if (lobby.players.size == 2) {&#10;                    CoffeeCard(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        content = {&#10;                            Column(&#10;                                modifier = Modifier.padding(16.dp),&#10;                                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                            ) {&#10;                                CoffeeText(&#10;                                    text = &quot;Farbauswahl:&quot;&#10;                                )&#10;&#10;                                Row(&#10;                                    modifier = Modifier.fillMaxWidth(),&#10;                                    horizontalArrangement = Arrangement.SpaceEvenly,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    val iconSize: Dp = 56.dp&#10;                                    val cardSize: Dp = 80.dp&#10;                                    val borderWidth = 3.dp&#10;                                    val defaultBorderColor = MaterialTheme.colorScheme.primary&#10;                                    val selectedBorderColor = MaterialTheme.colorScheme.secondary&#10;                                    val cardShape = RoundedCornerShape(16.dp)&#10;&#10;                                    // Helper für Card&#10;                                    fun cardBorder(selected: Boolean) = BorderStroke(&#10;                                        borderWidth,&#10;                                        if (selected) selectedBorderColor else defaultBorderColor&#10;                                    )&#10;&#10;&#10;                                    // Weiß-Icon (Bauer)&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .weight(1f)&#10;                                            .padding(8.dp)&#10;                                            .size(cardSize)&#10;                                            .clickable {&#10;                                                colorChoice = &quot;white&quot;&#10;                                                randomColors = false},&#10;                                        shape = cardShape,&#10;                                        border = cardBorder(colorChoice == &quot;white&quot;),&#10;                                        elevation = CardDefaults.cardElevation(8.dp),&#10;                                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;                                    ) {&#10;                                        Column(&#10;                                            modifier = Modifier.fillMaxSize(),&#10;                                            verticalArrangement = Arrangement.Center,&#10;                                            horizontalAlignment = Alignment.CenterHorizontally&#10;                                        ) {&#10;                                            Icon(&#10;                                                painter = painterResource(id = app.chesspresso.R.drawable.pawn_white),&#10;                                                contentDescription = &quot;Weiß&quot;,&#10;                                                tint = null,&#10;                                                modifier = Modifier.size(iconSize)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                    // Würfel-Icon (Zufall)&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .weight(1f)&#10;                                            .padding(8.dp)&#10;                                            .size(cardSize)&#10;                                            .clickable {&#10;                                                colorChoice = &quot;random&quot;&#10;                                                randomColors = true },&#10;                                        shape = cardShape,&#10;                                        border = cardBorder(colorChoice == &quot;random&quot;),&#10;                                        elevation = CardDefaults.cardElevation(8.dp),&#10;                                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;                                    ) {&#10;                                        Column(&#10;                                            modifier = Modifier.fillMaxSize(),&#10;                                            verticalArrangement = Arrangement.Center,&#10;                                            horizontalAlignment = Alignment.CenterHorizontally&#10;                                        ) {&#10;                                            Icon(&#10;                                                imageVector = Icons.Filled.Casino,&#10;                                                contentDescription = &quot;Zufällig&quot;,&#10;                                                tint = MaterialTheme.colorScheme.primary,&#10;                                                modifier = Modifier.size(iconSize)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                    // Schwarz-Icon (Bauer)&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .weight(1f)&#10;                                            .padding(8.dp)&#10;                                            .size(cardSize)&#10;                                            .clickable {&#10;                                                colorChoice = &quot;black&quot;&#10;                                                randomColors = false },&#10;                                        shape = cardShape,&#10;                                        border = cardBorder(colorChoice == &quot;black&quot;),&#10;                                        elevation = CardDefaults.cardElevation(8.dp),&#10;                                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;                                    ) {&#10;                                        Column(&#10;                                            modifier = Modifier.fillMaxSize(),&#10;                                            verticalArrangement = Arrangement.Center,&#10;                                            horizontalAlignment = Alignment.CenterHorizontally&#10;                                        ) {&#10;                                            Icon(&#10;                                                painter = painterResource(id = app.chesspresso.R.drawable.pawn_black),&#10;                                                contentDescription = &quot;Schwarz&quot;,&#10;                                                tint = null,&#10;                                                modifier = Modifier.size(iconSize)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        },&#10;                    )&#10;&#10;                    // Spiel starten Button&#10;                    CoffeeButton(&#10;                        onClick = {&#10;                            val whitePlayerFinal = when (colorChoice) {&#10;                                &quot;random&quot; -&gt; null&#10;                                &quot;white&quot; -&gt; lobby.creator&#10;                                &quot;black&quot; -&gt; lobby.players.find { it != lobby.creator }&#10;                                else -&gt; null&#10;                            }&#10;                            val blackPlayerFinal =&#10;                                if (randomColors) null else lobby.players.find { it != whitePlayerFinal }&#10;&#10;                            viewModel.configureAndStartGame(&#10;                                lobbyCode = lobbyCode,&#10;                                gameTime = selectedGameTime,&#10;                                whitePlayer = whitePlayerFinal,&#10;                                blackPlayer = blackPlayerFinal,&#10;                                randomColors = randomColors&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        enabled = !uiState.isLoading,&#10;                        content = {&#10;                            if (uiState.isLoading) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(20.dp),&#10;                                    color = MaterialTheme.colorScheme.onPrimary&#10;                                )&#10;                                Spacer(modifier = Modifier.width(8.dp))&#10;                            }&#10;                            Text(&quot;Spiel starten&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            } else if (lobby.players.size == 2) {&#10;                // Warte-Status für den zweiten Spieler&#10;                CoffeeCard(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    content = {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(24.dp)&#10;                                .fillMaxWidth(),&#10;                            horizontalAlignment = Alignment.CenterHorizontally,&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                            CoffeeText(&#10;                                text = &quot;Warte auf Spiel-Start...&quot;&#10;                            )&#10;                            CoffeeText(&#10;                                text = &quot;Der Lobby-Ersteller richtet das Spiel ein.&quot;,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    },&#10;                )&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    CoffeeText(&#10;                        text = errorMessage,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        color = MaterialTheme.colorScheme.onErrorContainer&#10;                    )&#10;                },&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Lobby verlassen Button&#10;        CoffeeButton(&#10;            onClick = {&#10;                viewModel.leaveLobby()&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            error = true,&#10;            content = {&#10;                Text(&quot;Lobby verlassen&quot;)&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Casino&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.Dp&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    isCreator: Boolean,&#10;    lobbyCode: String,&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val navigationEvent by viewModel.navigationEvent.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameTime by remember { mutableStateOf(GameTime.MIDDLE) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;    // Farbauswahl-State auf Composable-Ebene&#10;    var colorChoice by remember { mutableStateOf(&quot;random&quot;) } // Werte: &quot;black&quot;, &quot;white&quot;, &quot;random&quot;&#10;&#10;&#10;&#10;    // Navigation nach Home wenn Lobby verlassen wurde&#10;    LaunchedEffect(navigationEvent) {&#10;        if (navigationEvent == &quot;home&quot;) {&#10;            onBackClick()&#10;            viewModel.onNavigated()&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp),&#10;        horizontalAlignment = Alignment.CenterHorizontally&#10;    ) {&#10;        CoffeeHeadlineText(&#10;            text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;&#10;        )&#10;&#10;        // nur wenn nur ein Spieler in der Lobby ist&#10;        if (currentLobby?.players?.size != 2) {&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CoffeeText(&#10;                            text = &quot;Teile diesen Code mit deinem Freund&quot;,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                        )&#10;                    }&#10;                },&#10;            )&#10;        }&#10;&#10;        // QR-Code für Lobby-Ersteller anzeigen (nur wenn noch Platz frei ist)&#10;        if (isCreator &amp;&amp; currentLobby?.players?.size != 2) {&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Spieler-Status&#10;        CoffeeCard(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            content = {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                ) {&#10;                    CoffeeText(&#10;                        text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2):&quot;&#10;                    )&#10;&#10;                    currentLobby?.let { lobby -&gt;&#10;                        lobby.players.forEachIndexed { _, player -&gt;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Icon(&#10;                                    imageVector = Icons.Default.Person,&#10;                                    contentDescription = null,&#10;                                    tint = MaterialTheme.colorScheme.primary&#10;                                )&#10;                                CoffeeText(&#10;                                    text = &quot;${player}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;&#10;                        if (currentLobby?.players?.size != 2) {&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(24.dp),&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                                CoffeeText(&#10;                                    text = &quot;Warte auf zweiten Spieler...&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            },&#10;        )&#10;        CoffeeHeadlineText(&#10;            text = &quot;Spiel-Einstellungen&quot;,&#10;            fontSizeSp = 24&#10;        )&#10;&#10;        // Spieleinstellungen Card (nur für Ersteller)&#10;        currentLobby?.let { lobby -&gt;&#10;            if (isCreator) {&#10;                CoffeeCard(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    content = {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;&#10;                            CoffeeText(&#10;                                text = &quot;Spielzeit:&quot;&#10;                            )&#10;                            GameTimeSelectionRow(&#10;                                selectedGameTime = selectedGameTime,&#10;                                onGameTimeSelected = { selectedGameTime = it },&#10;                                allowedTimes = GameTime.entries.toList()&#10;                            )&#10;                        }&#10;                    },&#10;                )&#10;&#10;                // Farbauswahl Card (nur wenn beide Spieler da sind)&#10;                if (lobby.players.size == 2) {&#10;                    CoffeeCard(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        content = {&#10;                            Column(&#10;                                modifier = Modifier.padding(16.dp),&#10;                                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                            ) {&#10;                                CoffeeText(&#10;                                    text = &quot;Farbauswahl:&quot;&#10;                                )&#10;&#10;                                Row(&#10;                                    modifier = Modifier.fillMaxWidth(),&#10;                                    horizontalArrangement = Arrangement.SpaceEvenly,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    val iconSize: Dp = 56.dp&#10;                                    val cardSize: Dp = 80.dp&#10;                                    val borderWidth = 3.dp&#10;                                    val defaultBorderColor = MaterialTheme.colorScheme.primary&#10;                                    val selectedBorderColor = MaterialTheme.colorScheme.secondary&#10;                                    val cardShape = RoundedCornerShape(16.dp)&#10;&#10;                                    // Helper für Card&#10;                                    fun cardBorder(selected: Boolean) = BorderStroke(&#10;                                        borderWidth,&#10;                                        if (selected) selectedBorderColor else defaultBorderColor&#10;                                    )&#10;&#10;&#10;                                    // Weiß-Icon (Bauer)&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .weight(1f)&#10;                                            .padding(8.dp)&#10;                                            .size(cardSize)&#10;                                            .clickable {&#10;                                                colorChoice = &quot;white&quot;&#10;                                                randomColors = false},&#10;                                        shape = cardShape,&#10;                                        border = cardBorder(colorChoice == &quot;white&quot;),&#10;                                        elevation = CardDefaults.cardElevation(8.dp),&#10;                                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;                                    ) {&#10;                                        Column(&#10;                                            modifier = Modifier.fillMaxSize(),&#10;                                            verticalArrangement = Arrangement.Center,&#10;                                            horizontalAlignment = Alignment.CenterHorizontally&#10;                                        ) {&#10;                                            Icon(&#10;                                                painter = painterResource(id = app.chesspresso.R.drawable.pawn_white),&#10;                                                contentDescription = &quot;Weiß&quot;,&#10;                                                tint = null,&#10;                                                modifier = Modifier.size(iconSize)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                    // Würfel-Icon (Zufall)&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .weight(1f)&#10;                                            .padding(8.dp)&#10;                                            .size(cardSize)&#10;                                            .clickable {&#10;                                                colorChoice = &quot;random&quot;&#10;                                                randomColors = true },&#10;                                        shape = cardShape,&#10;                                        border = cardBorder(colorChoice == &quot;random&quot;),&#10;                                        elevation = CardDefaults.cardElevation(8.dp),&#10;                                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;                                    ) {&#10;                                        Column(&#10;                                            modifier = Modifier.fillMaxSize(),&#10;                                            verticalArrangement = Arrangement.Center,&#10;                                            horizontalAlignment = Alignment.CenterHorizontally&#10;                                        ) {&#10;                                            Icon(&#10;                                                imageVector = Icons.Filled.Casino,&#10;                                                contentDescription = &quot;Zufällig&quot;,&#10;                                                tint = MaterialTheme.colorScheme.primary,&#10;                                                modifier = Modifier.size(iconSize)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                    // Schwarz-Icon (Bauer)&#10;                                    Card(&#10;                                        modifier = Modifier&#10;                                            .weight(1f)&#10;                                            .padding(8.dp)&#10;                                            .size(cardSize)&#10;                                            .clickable {&#10;                                                colorChoice = &quot;black&quot;&#10;                                                randomColors = false },&#10;                                        shape = cardShape,&#10;                                        border = cardBorder(colorChoice == &quot;black&quot;),&#10;                                        elevation = CardDefaults.cardElevation(8.dp),&#10;                                        colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;                                    ) {&#10;                                        Column(&#10;                                            modifier = Modifier.fillMaxSize(),&#10;                                            verticalArrangement = Arrangement.Center,&#10;                                            horizontalAlignment = Alignment.CenterHorizontally&#10;                                        ) {&#10;                                            Icon(&#10;                                                painter = painterResource(id = app.chesspresso.R.drawable.pawn_black),&#10;                                                contentDescription = &quot;Schwarz&quot;,&#10;                                                tint = null,&#10;                                                modifier = Modifier.size(iconSize)&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        },&#10;                    )&#10;&#10;                    // Spiel starten Button&#10;                    CoffeeButton(&#10;                        onClick = {&#10;                            val whitePlayerFinal = when (colorChoice) {&#10;                                &quot;random&quot; -&gt; null&#10;                                &quot;white&quot; -&gt; lobby.creator&#10;                                &quot;black&quot; -&gt; lobby.players.find { it != lobby.creator }&#10;                                else -&gt; null&#10;                            }&#10;                            val blackPlayerFinal =&#10;                                if (randomColors) null else lobby.players.find { it != whitePlayerFinal }&#10;&#10;                            viewModel.configureAndStartGame(&#10;                                lobbyCode = lobbyCode,&#10;                                gameTime = selectedGameTime,&#10;                                whitePlayer = whitePlayerFinal,&#10;                                blackPlayer = blackPlayerFinal,&#10;                                randomColors = randomColors&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        enabled = !uiState.isLoading,&#10;                        content = {&#10;                            if (uiState.isLoading) {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(20.dp),&#10;                                    color = MaterialTheme.colorScheme.onPrimary&#10;                                )&#10;                                Spacer(modifier = Modifier.width(8.dp))&#10;                            }&#10;                            Text(&quot;Spiel starten&quot;)&#10;                        }&#10;                    )&#10;                }&#10;            } else if (lobby.players.size == 2) {&#10;                // Warte-Status für den zweiten Spieler&#10;                CoffeeCard(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    content = {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .padding(24.dp)&#10;                                .fillMaxWidth(),&#10;                            horizontalAlignment = Alignment.CenterHorizontally,&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;                            CircularProgressIndicator()&#10;                            CoffeeText(&#10;                                text = &quot;Warte auf Spiel-Start...&quot;&#10;                            )&#10;                            CoffeeText(&#10;                                text = &quot;Der Lobby-Ersteller richtet das Spiel ein.&quot;,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    },&#10;                )&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    CoffeeText(&#10;                        text = errorMessage,&#10;                        modifier = Modifier.padding(16.dp),&#10;                        color = MaterialTheme.colorScheme.onErrorContainer&#10;                    )&#10;                },&#10;            )&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Lobby verlassen Button&#10;        CoffeeButton(&#10;            onClick = {&#10;                viewModel.leaveLobby()&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            error = true,&#10;            content = {&#10;                Text(&quot;Lobby verlassen&quot;)&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import app.chesspresso.ui.theme.CoffeeTextField&#10;&#10;const val CHANGE_USERNAME_TITLE = &quot;Benutzernamen ändern&quot;&#10;const val CHANGE_PASSWORD_TITLE = &quot;Passwort ändern&quot;&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel = hiltViewModel(),&#10;    authViewModel: AuthViewModel,&#10;    onLogout: () -&gt; Unit,&#10;    outerNavController: NavHostController&#10;) {&#10;    val usernameChangeState by viewModel.usernameChangeState.collectAsState()&#10;    val passwordChangeState by viewModel.passwordChangeState.collectAsState()&#10;    var newUsername by remember { mutableStateOf(&quot;&quot;) }&#10;    var oldPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var showUsernameConfirmDialog by remember { mutableStateOf(false) }&#10;    var showPasswordConfirmDialog by remember { mutableStateOf(false) }&#10;    var oldPasswordVisible by remember { mutableStateOf(false) }&#10;    var newPasswordVisible by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadUserProfile()&#10;    }&#10;&#10;    LaunchedEffect(usernameChangeState) {&#10;        if (usernameChangeState is UsernameChangeState.Success) {&#10;            newUsername = &quot;&quot; // Clear input after success&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(passwordChangeState) {&#10;        if (passwordChangeState is PasswordChangeState.Success) {&#10;            oldPassword = &quot;&quot;&#10;            newPassword = &quot;&quot;&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.events.collect { event -&gt;&#10;            when (event) {&#10;                is ProfileEvent.LogoutAndNavigateToLogin -&gt; {&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;login&quot;) {&#10;                        popUpTo(&quot;login&quot;) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(bottom = 16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            CoffeeHeadlineText(&#10;                text = &quot;Mein Profil&quot;&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // User Profile Info Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        val userProfileState = viewModel.userProfileState.collectAsState().value&#10;                        when (userProfileState) {&#10;                            is UserProfileUiState.Loading -&gt; CircularProgressIndicator()&#10;                            is UserProfileUiState.Error -&gt; CoffeeText(&#10;                                &quot;Fehler: &quot; + userProfileState.message,&#10;                                color = MaterialTheme.colorScheme.error&#10;                            )&#10;&#10;                            is UserProfileUiState.Success -&gt; {&#10;                                val profile = userProfileState.profile&#10;                                CoffeeText(&quot;Name: ${profile.username}&quot;)&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CoffeeText(&quot;E-Mail: ${profile.email}&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Username Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CoffeeText(&#10;                            text = CHANGE_USERNAME_TITLE,&#10;                            modifier = Modifier.padding(bottom = 16.dp)&#10;                        )&#10;                        CoffeeTextField(&#10;                            value = newUsername,&#10;                            onValueChange = { newUsername = it },&#10;                            label = &quot;Neuer Benutzername&quot;,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            singleLine = true,&#10;                            leadingIcon = { Icon(Icons.Default.Person, contentDescription = &quot;Benutzername&quot;) }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CoffeeButton(&#10;                            onClick = { showUsernameConfirmDialog = true },&#10;                            enabled = usernameChangeState !is UsernameChangeState.Loading &amp;&amp; newUsername.length in 3..32,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            content = {&#10;                                Text(CHANGE_USERNAME_TITLE)&#10;                            }&#10;                        )&#10;                        when (val state = usernameChangeState) {&#10;                            is UsernameChangeState.Loading -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CircularProgressIndicator()&#10;                            }&#10;&#10;                            is UsernameChangeState.Success -&gt; {&#10;                                // Message handled by logout navigation&#10;                            }&#10;&#10;                            is UsernameChangeState.Error -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                },&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Password Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CoffeeText(&#10;                            text = CHANGE_PASSWORD_TITLE,&#10;                            modifier = Modifier.padding(bottom = 16.dp)&#10;                        )&#10;                        CoffeeTextField(&#10;                            value = oldPassword,&#10;                            onValueChange = { oldPassword = it },&#10;                            label = &quot;Altes Passwort&quot;,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            singleLine = true,&#10;                            visualTransformation = if (oldPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Altes Passwort&quot;) },&#10;                            trailingIcon = {&#10;                                val image = if (oldPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                                val desc = if (oldPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                                IconButton(onClick = { oldPasswordVisible = !oldPasswordVisible }) {&#10;                                    Icon(image, contentDescription = desc)&#10;                                }&#10;                            }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CoffeeTextField(&#10;                            value = newPassword,&#10;                            onValueChange = { newPassword = it },&#10;                            label = &quot;Neues Passwort&quot;,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            singleLine = true,&#10;                            visualTransformation = if (newPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Neues Passwort&quot;) },&#10;                            trailingIcon = {&#10;                                val image = if (newPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                                val desc = if (newPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                                IconButton(onClick = { newPasswordVisible = !newPasswordVisible }) {&#10;                                    Icon(image, contentDescription = desc)&#10;                                }&#10;                            }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CoffeeButton(&#10;                            onClick = { showPasswordConfirmDialog = true },&#10;                            enabled = passwordChangeState !is PasswordChangeState.Loading &amp;&amp; oldPassword.length &gt;= 4 &amp;&amp; newPassword.length in 4..64,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            content = {&#10;                                Text(CHANGE_PASSWORD_TITLE)&#10;                            }&#10;                        )&#10;                        when (val state = passwordChangeState) {&#10;                            is PasswordChangeState.Loading -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CircularProgressIndicator()&#10;                            }&#10;&#10;                            is PasswordChangeState.Success -&gt; {&#10;                                // Message handled by logout navigation&#10;                            }&#10;&#10;                            is PasswordChangeState.Error -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                },&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        }&#10;&#10;        CoffeeButton(&#10;            onClick = onLogout,&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .fillMaxWidth(),&#10;            error = true,&#10;            content = {&#10;                Text(&quot;Abmelden&quot;)&#10;            }&#10;        )&#10;    }&#10;&#10;&#10;    if (showUsernameConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showUsernameConfirmDialog = false },&#10;            title = { CoffeeText(CHANGE_USERNAME_TITLE) },&#10;            text = { CoffeeText(&quot;Um den Benutzernamen zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showUsernameConfirmDialog = false&#10;                    viewModel.changeUsername(newUsername)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showUsernameConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showPasswordConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPasswordConfirmDialog = false },&#10;            title = { CoffeeText(CHANGE_PASSWORD_TITLE) },&#10;            text = { CoffeeText(&quot;Um das Passwort zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showPasswordConfirmDialog = false&#10;                    viewModel.changePassword(oldPassword, newPassword)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showPasswordConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Lock&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Visibility&#10;import androidx.compose.material.icons.filled.VisibilityOff&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TextButton&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.navigation.NavHostController&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.ui.theme.CoffeeButton&#10;import app.chesspresso.ui.theme.CoffeeCard&#10;import app.chesspresso.ui.theme.CoffeeHeadlineText&#10;import app.chesspresso.ui.theme.CoffeeText&#10;import app.chesspresso.ui.theme.CoffeeTextField&#10;&#10;const val CHANGE_USERNAME_TITLE = &quot;Benutzernamen ändern&quot;&#10;const val CHANGE_PASSWORD_TITLE = &quot;Passwort ändern&quot;&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel = hiltViewModel(),&#10;    authViewModel: AuthViewModel,&#10;    onLogout: () -&gt; Unit,&#10;    outerNavController: NavHostController&#10;) {&#10;    val usernameChangeState by viewModel.usernameChangeState.collectAsState()&#10;    val passwordChangeState by viewModel.passwordChangeState.collectAsState()&#10;    var newUsername by remember { mutableStateOf(&quot;&quot;) }&#10;    var oldPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var newPassword by remember { mutableStateOf(&quot;&quot;) }&#10;    var showUsernameConfirmDialog by remember { mutableStateOf(false) }&#10;    var showPasswordConfirmDialog by remember { mutableStateOf(false) }&#10;    var oldPasswordVisible by remember { mutableStateOf(false) }&#10;    var newPasswordVisible by remember { mutableStateOf(false) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadUserProfile()&#10;    }&#10;&#10;    LaunchedEffect(usernameChangeState) {&#10;        if (usernameChangeState is UsernameChangeState.Success) {&#10;            newUsername = &quot;&quot; // Clear input after success&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(passwordChangeState) {&#10;        if (passwordChangeState is PasswordChangeState.Success) {&#10;            oldPassword = &quot;&quot;&#10;            newPassword = &quot;&quot;&#10;            // Navigation is handled by the event below&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.events.collect { event -&gt;&#10;            when (event) {&#10;                is ProfileEvent.LogoutAndNavigateToLogin -&gt; {&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;login&quot;) {&#10;                        popUpTo(&quot;login&quot;) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(bottom = 16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally&#10;        ) {&#10;            CoffeeHeadlineText(&#10;                text = &quot;Mein Profil&quot;&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // User Profile Info Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        val userProfileState = viewModel.userProfileState.collectAsState().value&#10;                        when (userProfileState) {&#10;                            is UserProfileUiState.Loading -&gt; CircularProgressIndicator()&#10;                            is UserProfileUiState.Error -&gt; CoffeeText(&#10;                                &quot;Fehler: &quot; + userProfileState.message,&#10;                                color = MaterialTheme.colorScheme.error&#10;                            )&#10;&#10;                            is UserProfileUiState.Success -&gt; {&#10;                                val profile = userProfileState.profile&#10;                                CoffeeText(&quot;Name: ${profile.username}&quot;)&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CoffeeText(&quot;E-Mail: ${profile.email}&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Username Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CoffeeText(&#10;                            text = CHANGE_USERNAME_TITLE,&#10;                            modifier = Modifier.padding(bottom = 16.dp)&#10;                        )&#10;                        CoffeeTextField(&#10;                            value = newUsername,&#10;                            onValueChange = { newUsername = it },&#10;                            label = &quot;Neuer Benutzername&quot;,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            singleLine = true,&#10;                            leadingIcon = { Icon(Icons.Default.Person, contentDescription = &quot;Benutzername&quot;) }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CoffeeButton(&#10;                            onClick = { showUsernameConfirmDialog = true },&#10;                            enabled = usernameChangeState !is UsernameChangeState.Loading &amp;&amp; newUsername.length in 3..32,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            content = {&#10;                                Text(CHANGE_USERNAME_TITLE)&#10;                            }&#10;                        )&#10;                        when (val state = usernameChangeState) {&#10;                            is UsernameChangeState.Loading -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CircularProgressIndicator()&#10;                            }&#10;&#10;                            is UsernameChangeState.Success -&gt; {&#10;                                // Message handled by logout navigation&#10;                            }&#10;&#10;                            is UsernameChangeState.Error -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                },&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Change Password Card&#10;            CoffeeCard(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                content = {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(16.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CoffeeText(&#10;                            text = CHANGE_PASSWORD_TITLE,&#10;                            modifier = Modifier.padding(bottom = 16.dp)&#10;                        )&#10;                        CoffeeTextField(&#10;                            value = oldPassword,&#10;                            onValueChange = { oldPassword = it },&#10;                            label = &quot;Altes Passwort&quot;,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            singleLine = true,&#10;                            visualTransformation = if (oldPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Altes Passwort&quot;) },&#10;                            trailingIcon = {&#10;                                val image = if (oldPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                                val desc = if (oldPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                                IconButton(onClick = { oldPasswordVisible = !oldPasswordVisible }) {&#10;                                    Icon(image, contentDescription = desc)&#10;                                }&#10;                            }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CoffeeTextField(&#10;                            value = newPassword,&#10;                            onValueChange = { newPassword = it },&#10;                            label = &quot;Neues Passwort&quot;,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            singleLine = true,&#10;                            visualTransformation = if (newPasswordVisible) androidx.compose.ui.text.input.VisualTransformation.None else PasswordVisualTransformation(),&#10;                            leadingIcon = { Icon(Icons.Default.Lock, contentDescription = &quot;Neues Passwort&quot;) },&#10;                            trailingIcon = {&#10;                                val image = if (newPasswordVisible) Icons.Default.VisibilityOff else Icons.Default.Visibility&#10;                                val desc = if (newPasswordVisible) &quot;Passwort verbergen&quot; else &quot;Passwort anzeigen&quot;&#10;                                IconButton(onClick = { newPasswordVisible = !newPasswordVisible }) {&#10;                                    Icon(image, contentDescription = desc)&#10;                                }&#10;                            }&#10;                        )&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;                        CoffeeButton(&#10;                            onClick = { showPasswordConfirmDialog = true },&#10;                            enabled = passwordChangeState !is PasswordChangeState.Loading &amp;&amp; oldPassword.length &gt;= 4 &amp;&amp; newPassword.length in 4..64,&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            content = {&#10;                                Text(CHANGE_PASSWORD_TITLE)&#10;                            }&#10;                        )&#10;                        when (val state = passwordChangeState) {&#10;                            is PasswordChangeState.Loading -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CircularProgressIndicator()&#10;                            }&#10;&#10;                            is PasswordChangeState.Success -&gt; {&#10;                                // Message handled by logout navigation&#10;                            }&#10;&#10;                            is PasswordChangeState.Error -&gt; {&#10;                                Spacer(modifier = Modifier.height(8.dp))&#10;                                CoffeeText(state.message, color = MaterialTheme.colorScheme.error)&#10;                            }&#10;&#10;                            else -&gt; {}&#10;                        }&#10;                    }&#10;                },&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(24.dp))&#10;&#10;        }&#10;&#10;        CoffeeButton(&#10;            onClick = onLogout,&#10;            modifier = Modifier&#10;                .align(Alignment.BottomCenter)&#10;                .fillMaxWidth(),&#10;            error = true,&#10;            content = {&#10;                Text(&quot;Abmelden&quot;)&#10;            }&#10;        )&#10;    }&#10;&#10;&#10;    if (showUsernameConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showUsernameConfirmDialog = false },&#10;            title = { CoffeeText(CHANGE_USERNAME_TITLE) },&#10;            text = { CoffeeText(&quot;Um den Benutzernamen zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showUsernameConfirmDialog = false&#10;                    viewModel.changeUsername(newUsername)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showUsernameConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showPasswordConfirmDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPasswordConfirmDialog = false },&#10;            title = { CoffeeText(CHANGE_PASSWORD_TITLE) },&#10;            text = { CoffeeText(&quot;Um das Passwort zu ändern, musst du dich neu anmelden. Bist du sicher, dass du fortfahren möchtest?&quot;) },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    showPasswordConfirmDialog = false&#10;                    viewModel.changePassword(oldPassword, newPassword)&#10;                }) { CoffeeText(&quot;Ja, ändern&quot;) }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showPasswordConfirmDialog = false }) { CoffeeText(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.data.api.ChangeUsernameRequest&#10;import app.chesspresso.data.api.UserApi&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;const val UNKNOWN_ERROR_MESSAGE = &quot;Unbekannter Fehler&quot;&#10;&#10;sealed class UsernameChangeState {&#10;    object Idle : UsernameChangeState()&#10;    object Loading : UsernameChangeState()&#10;    object Success : UsernameChangeState()&#10;    data class Error(val message: String) : UsernameChangeState()&#10;}&#10;&#10;sealed class PasswordChangeState {&#10;    object Idle : PasswordChangeState()&#10;    object Loading : PasswordChangeState()&#10;    object Success : PasswordChangeState()&#10;    data class Error(val message: String) : PasswordChangeState()&#10;}&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val userApi: UserApi&#10;) : ViewModel() {&#10;    // --- UserProfile State ---&#10;    private val _userProfileState = MutableStateFlow&lt;UserProfileUiState&gt;(UserProfileUiState.Loading)&#10;    val userProfileState: StateFlow&lt;UserProfileUiState&gt; = _userProfileState.asStateFlow()&#10;&#10;    private val _usernameChangeState = MutableStateFlow&lt;UsernameChangeState&gt;(UsernameChangeState.Idle)&#10;    val usernameChangeState: StateFlow&lt;UsernameChangeState&gt; = _usernameChangeState.asStateFlow()&#10;&#10;    private val _passwordChangeState = MutableStateFlow&lt;PasswordChangeState&gt;(PasswordChangeState.Idle)&#10;    val passwordChangeState: StateFlow&lt;PasswordChangeState&gt; = _passwordChangeState.asStateFlow()&#10;&#10;    private val _eventChannel = Channel&lt;ProfileEvent&gt;(Channel.BUFFERED)&#10;    val events = _eventChannel.receiveAsFlow()&#10;&#10;    fun changeUsername(newUsername: String) {&#10;        _usernameChangeState.value = UsernameChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changeUsername(ChangeUsernameRequest(newUsername))&#10;                if (response.isSuccessful) {&#10;                    _usernameChangeState.value = UsernameChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: UNKNOWN_ERROR_MESSAGE&#10;                    _usernameChangeState.value = UsernameChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _usernameChangeState.value = UsernameChangeState.Error(e.localizedMessage ?: UNKNOWN_ERROR_MESSAGE)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changePassword(oldPassword: String, newPassword: String) {&#10;        _passwordChangeState.value = PasswordChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changePassword(&#10;                    app.chesspresso.data.api.ChangePasswordRequest(oldPassword, newPassword)&#10;                )&#10;                if (response.isSuccessful) {&#10;                    _passwordChangeState.value = PasswordChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: UNKNOWN_ERROR_MESSAGE&#10;                    _passwordChangeState.value = PasswordChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _passwordChangeState.value = PasswordChangeState.Error(e.localizedMessage ?: UNKNOWN_ERROR_MESSAGE)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            _userProfileState.value = UserProfileUiState.Loading&#10;            try {&#10;                val profile = userApi.getProfile()&#10;                _userProfileState.value = UserProfileUiState.Success(profile)&#10;            } catch (e: Exception) {&#10;                _userProfileState.value = UserProfileUiState.Error(e.localizedMessage ?: UNKNOWN_ERROR_MESSAGE)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;sealed class ProfileEvent {&#10;    object LogoutAndNavigateToLogin : ProfileEvent()&#10;}&#10;&#10;sealed class UserProfileUiState {&#10;    object Loading : UserProfileUiState()&#10;    data class Success(val profile: app.chesspresso.data.api.UserProfileResponse) : UserProfileUiState()&#10;    data class Error(val message: String) : UserProfileUiState()&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.data.api.ChangeUsernameRequest&#10;import app.chesspresso.data.api.UserApi&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;const val UNKNOWN_ERROR_MESSAGE = &quot;Unbekannter Fehler&quot;&#10;&#10;sealed class UsernameChangeState {&#10;    object Idle : UsernameChangeState()&#10;    object Loading : UsernameChangeState()&#10;    object Success : UsernameChangeState()&#10;    data class Error(val message: String) : UsernameChangeState()&#10;}&#10;&#10;sealed class PasswordChangeState {&#10;    object Idle : PasswordChangeState()&#10;    object Loading : PasswordChangeState()&#10;    object Success : PasswordChangeState()&#10;    data class Error(val message: String) : PasswordChangeState()&#10;}&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val userApi: UserApi&#10;) : ViewModel() {&#10;    // --- UserProfile State ---&#10;    private val _userProfileState = MutableStateFlow&lt;UserProfileUiState&gt;(UserProfileUiState.Loading)&#10;    val userProfileState: StateFlow&lt;UserProfileUiState&gt; = _userProfileState.asStateFlow()&#10;&#10;    private val _usernameChangeState = MutableStateFlow&lt;UsernameChangeState&gt;(UsernameChangeState.Idle)&#10;    val usernameChangeState: StateFlow&lt;UsernameChangeState&gt; = _usernameChangeState.asStateFlow()&#10;&#10;    private val _passwordChangeState = MutableStateFlow&lt;PasswordChangeState&gt;(PasswordChangeState.Idle)&#10;    val passwordChangeState: StateFlow&lt;PasswordChangeState&gt; = _passwordChangeState.asStateFlow()&#10;&#10;    private val _eventChannel = Channel&lt;ProfileEvent&gt;(Channel.BUFFERED)&#10;    val events = _eventChannel.receiveAsFlow()&#10;&#10;    fun changeUsername(newUsername: String) {&#10;        _usernameChangeState.value = UsernameChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changeUsername(ChangeUsernameRequest(newUsername))&#10;                if (response.isSuccessful) {&#10;                    _usernameChangeState.value = UsernameChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: UNKNOWN_ERROR_MESSAGE&#10;                    _usernameChangeState.value = UsernameChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _usernameChangeState.value = UsernameChangeState.Error(e.localizedMessage ?: UNKNOWN_ERROR_MESSAGE)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changePassword(oldPassword: String, newPassword: String) {&#10;        _passwordChangeState.value = PasswordChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changePassword(&#10;                    app.chesspresso.data.api.ChangePasswordRequest(oldPassword, newPassword)&#10;                )&#10;                if (response.isSuccessful) {&#10;                    _passwordChangeState.value = PasswordChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: UNKNOWN_ERROR_MESSAGE&#10;                    _passwordChangeState.value = PasswordChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _passwordChangeState.value = PasswordChangeState.Error(e.localizedMessage ?: UNKNOWN_ERROR_MESSAGE)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun loadUserProfile() {&#10;        viewModelScope.launch {&#10;            _userProfileState.value = UserProfileUiState.Loading&#10;            try {&#10;                val profile = userApi.getProfile()&#10;                _userProfileState.value = UserProfileUiState.Success(profile)&#10;            } catch (e: Exception) {&#10;                _userProfileState.value = UserProfileUiState.Error(e.localizedMessage ?: UNKNOWN_ERROR_MESSAGE)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;sealed class ProfileEvent {&#10;    object LogoutAndNavigateToLogin : ProfileEvent()&#10;}&#10;&#10;sealed class UserProfileUiState {&#10;    object Loading : UserProfileUiState()&#10;    data class Success(val profile: app.chesspresso.data.api.UserProfileResponse) : UserProfileUiState()&#10;    data class Error(val message: String) : UserProfileUiState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;adaptive-icon xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;background android:drawable=&quot;@drawable/ic_launcher_background&quot; /&gt;&#10;    &lt;foreground android:drawable=&quot;@mipmap/ic_launcher_foreground&quot; android:monochrome=&quot;@drawable/ic_launcher_foreground&quot; /&gt;&#10;&lt;/adaptive-icon&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;adaptive-icon xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;background android:drawable=&quot;@drawable/ic_launcher_background&quot; /&gt;&#10;    &lt;foreground android:drawable=&quot;@mipmap/ic_launcher_foreground&quot; android:monochrome=&quot;@drawable/ic_launcher_foreground&quot; /&gt;&#10;&lt;/adaptive-icon&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.57&quot; apply false&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;2.2.10&quot; apply false&#10;    id(&quot;org.sonarqube&quot;) version &quot;4.4.1.3373&quot;&#10;}&#10;sonarqube {&#10;    properties {&#10;        property(&quot;sonar.projectKey&quot;, &quot;ChessPresso2025_ChessPressoApp&quot;)&#10;        property(&quot;sonar.organization&quot;, &quot;chesspresso2025&quot;)&#10;        property(&quot;sonar.host.url&quot;, &quot;https://sonarcloud.io&quot;)&#10;        property(&quot;sonar.token&quot;, System.getenv(&quot;SONAR_TOKEN&quot;) ?: &quot;&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.57&quot; apply false&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;2.2.10&quot; apply false&#10;    id(&quot;org.sonarqube&quot;) version &quot;4.4.1.3373&quot;&#10;}&#10;sonarqube {&#10;    properties {&#10;        property(&quot;sonar.projectKey&quot;, &quot;ChessPresso2025_ChessPressoApp&quot;)&#10;        property(&quot;sonar.organization&quot;, &quot;chesspresso2025&quot;)&#10;        property(&quot;sonar.host.url&quot;, &quot;https://sonarcloud.io&quot;)&#10;        property(&quot;sonar.token&quot;, System.getenv(&quot;SONAR_TOKEN&quot;) ?: &quot;&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/gradle.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/gradle.properties" />
              <option name="originalContent" value="# Project-wide Gradle settings.&#10;# IDE (e.g. Android Studio) users:&#10;# Gradle settings configured through the IDE *will override*&#10;# any settings specified in this file.&#10;# For more details on how to configure your build environment visit&#10;# http://www.gradle.org/docs/current/userguide/build_environment.html&#10;# Specifies the JVM arguments used for the daemon process.&#10;# The setting is particularly useful for tweaking memory settings.&#10;org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8&#10;# When configured, Gradle will run in incubating parallel mode.&#10;# This option should only be used with decoupled projects. For more details, visit&#10;# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects&#10;# org.gradle.parallel=true&#10;# AndroidX package structure to make it clearer which packages are bundled with the&#10;# Android operating system, and which are packaged with your app's APK&#10;# https://developer.android.com/topic/libraries/support-library/androidx-rn&#10;android.useAndroidX=true&#10;# Kotlin code style for this project: &quot;official&quot; or &quot;obsolete&quot;:&#10;kotlin.code.style=official&#10;# Enables namespacing of each library's R class so that its R class includes only the&#10;# resources declared in the library itself and none from the library's dependencies,&#10;# thereby reducing the size of the R class for that library&#10;android.nonTransitiveRClass=true&#10;sonar.gradle.skipCompile=true" />
              <option name="updatedContent" value="# Project-wide Gradle settings.&#13;&#10;# IDE (e.g. Android Studio) users:&#13;&#10;# Gradle settings configured through the IDE *will override*&#13;&#10;# any settings specified in this file.&#13;&#10;# For more details on how to configure your build environment visit&#13;&#10;# http://www.gradle.org/docs/current/userguide/build_environment.html&#13;&#10;# Specifies the JVM arguments used for the daemon process.&#13;&#10;# The setting is particularly useful for tweaking memory settings.&#13;&#10;org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8&#13;&#10;# When configured, Gradle will run in incubating parallel mode.&#13;&#10;# This option should only be used with decoupled projects. For more details, visit&#13;&#10;# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects&#13;&#10;# org.gradle.parallel=true&#13;&#10;# AndroidX package structure to make it clearer which packages are bundled with the&#13;&#10;# Android operating system, and which are packaged with your app's APK&#13;&#10;# https://developer.android.com/topic/libraries/support-library/androidx-rn&#13;&#10;android.useAndroidX=true&#13;&#10;# Kotlin code style for this project: &quot;official&quot; or &quot;obsolete&quot;:&#13;&#10;kotlin.code.style=official&#13;&#10;# Enables namespacing of each library's R class so that its R class includes only the&#13;&#10;# resources declared in the library itself and none from the library's dependencies,&#13;&#10;# thereby reducing the size of the R class for that library&#13;&#10;android.nonTransitiveRClass=true&#13;&#10;sonar.gradle.skipCompile=true" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>