<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Base URL für API konfigurierbar&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.1&quot;&#10;    }&#10;    packagingOptions {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.material3)&#10;&#10;    // Lifecycle Process dependency für ProcessLifecycleOwner&#10;    implementation(&quot;androidx.lifecycle:lifecycle-process:2.7.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;    // DataStore für Token-Speicherung&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // STOMP WebSocket dependencies&#10;    implementation(&quot;org.java-websocket:Java-WebSocket:1.5.3&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // QR Code Scanner dependencies&#10;    implementation(&quot;com.journeyapps:zxing-android-embedded:4.3.0&quot;)&#10;    implementation(&quot;com.google.zxing:core:3.5.2&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.3.1&quot;)&#10;&#10;    // AppCompat für QRScannerActivity&#10;    implementation(&quot;androidx.appcompat:appcompat:1.6.1&quot;)&#10;&#10;    // ML Kit für QR-Code Erkennung&#10;    implementation(&quot;com.google.mlkit:barcode-scanning:17.2.0&quot;)&#10;}" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.hilt.android)&#10;    kotlin(&quot;kapt&quot;)&#10;}&#10;&#10;android {&#10;    namespace = &quot;app.chesspresso&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;app.chesspresso&quot;&#10;        minSdk = 24&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        // Base URL für API konfigurierbar&#10;        buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://10.0.2.2:8080/\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    composeOptions {&#10;        kotlinCompilerExtensionVersion = &quot;1.5.1&quot;&#10;    }&#10;    packagingOptions {&#10;        resources {&#10;            excludes += &quot;/META-INF/{AL2.0,LGPL2.1}&quot;&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.material3)&#10;&#10;    // Lifecycle Process dependency für ProcessLifecycleOwner&#10;    implementation(&quot;androidx.lifecycle:lifecycle-process:2.7.0&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;&#10;    //Hilt dependencies&#10;    implementation(libs.hilt.android)&#10;    kapt(libs.dagger.hilt.compiler)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    //javax.inject&#10;    implementation(libs.javax.inject)&#10;&#10;&#10;    // Retrofit dependencies&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:logging-interceptor:4.11.0&quot;)&#10;&#10;    // DataStore für Token-Speicherung&#10;    implementation(&quot;androidx.datastore:datastore-preferences:1.0.0&quot;)&#10;&#10;    // STOMP WebSocket dependencies&#10;    implementation(&quot;org.java-websocket:Java-WebSocket:1.5.3&quot;)&#10;    implementation(&quot;com.squareup.okhttp3:okhttp:4.11.0&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&quot;)&#10;    implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&quot;)&#10;&#10;    // QR Code Scanner dependencies&#10;    implementation(&quot;com.journeyapps:zxing-android-embedded:4.3.0&quot;)&#10;    implementation(&quot;com.google.zxing:core:3.5.2&quot;)&#10;    implementation(&quot;androidx.camera:camera-camera2:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-lifecycle:1.3.1&quot;)&#10;    implementation(&quot;androidx.camera:camera-view:1.3.1&quot;)&#10;&#10;    // AppCompat für QRScannerActivity&#10;    implementation(&quot;androidx.appcompat:appcompat:1.6.1&quot;)&#10;&#10;    // ML Kit für QR-Code Erkennung&#10;    implementation(&quot;com.google.mlkit:barcode-scanning:17.2.0&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.qr.QRScannerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&#10;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera&quot; android:required=&quot;true&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.ChessPressoApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;        android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&#10;        tools:targetApi=&quot;31&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:label=&quot;@string/app_name&quot;&#10;            android:theme=&quot;@style/Theme.ChessPressoApp&quot;&#10;            android:launchMode=&quot;singleTop&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;.ui.qr.QRScannerActivity&quot;&#10;            android:exported=&quot;false&quot;&#10;            android:screenOrientation=&quot;portrait&quot; /&gt;&#10;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/AuthViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.auth.data.AuthResponse&#10;import app.chesspresso.auth.data.PlayerInfo&#10;import app.chesspresso.websocket.WebSocketManager&#10;import android.util.Log&#10;&#10;@HiltViewModel&#10;class AuthViewModel @Inject constructor(&#10;    private val repository: AuthRepository,&#10;    private val webSocketManager: WebSocketManager&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    init {&#10;        // Prüfe beim Start, ob bereits ein eingeloggter Spieler vorhanden ist&#10;        checkStoredAuth()&#10;    }&#10;&#10;    fun setErrorMessage(message: String) {&#10;        _authState.value = AuthState.Error(message)&#10;    }&#10;&#10;    fun loginWithGoogle(idToken: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting Google login with token length: ${idToken.length}&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendTokenToServer(idToken) },&#10;            loginType = &quot;Google login&quot;&#10;        )&#10;    }&#10;&#10;    fun loginWithGoogleAlternative(accountId: String, email: String) {&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Starting alternative Google login&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Account ID: $accountId&quot;)&#10;        Log.d(&quot;AuthViewModel&quot;, &quot;Email: $email&quot;)&#10;        performLogin(&#10;            loginAction = { repository.sendAlternativeTokenToServer(accountId, email) },&#10;            loginType = &quot;Alternative Google login&quot;&#10;        )&#10;    }&#10;&#10;    private fun performLogin(&#10;        loginAction: suspend () -&gt; AuthResponse,&#10;        loginType: String&#10;    ) {&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            try {&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;Calling repository for $loginType&quot;)&#10;                val response = loginAction()&#10;                Log.d(&quot;AuthViewModel&quot;, &quot;$loginType successful for user: ${response.name}&quot;)&#10;                _authState.value = AuthState.Success(response)&#10;                // Automatische WebSocket-Verbindung nach erfolgreicher Anmeldung&#10;                connectToWebSocket()&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;AuthViewModel&quot;, &quot;$loginType failed: ${e.message}&quot;, e)&#10;                _authState.value = AuthState.Error(mapErrorMessage(e))&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun mapErrorMessage(e: Exception): String {&#10;        return when {&#10;            e.message?.contains(&quot;ConnectException&quot;) == true -&gt; &quot;Server nicht erreichbar. Ist der Backend-Server gestartet?&quot;&#10;            e.message?.contains(&quot;SocketTimeoutException&quot;) == true -&gt; &quot;Verbindung zum Server zeitüberschritten&quot;&#10;            e.message?.contains(&quot;UnknownHostException&quot;) == true -&gt; &quot;Server-Adresse nicht gefunden&quot;&#10;            e.message?.contains(&quot;HTTP&quot;) == true -&gt; &quot;Server-Fehler: ${e.message}&quot;&#10;            else -&gt; e.message ?: &quot;Unbekannter Fehler bei der Anmeldung&quot;&#10;        }&#10;    }&#10;&#10;    private fun connectToWebSocket() {&#10;        try {&#10;            Log.d(&quot;AuthViewModel&quot;, &quot;Starting automatic WebSocket connection after login...&quot;)&#10;            val playerInfo = repository.getStoredPlayerInfo()&#10;            val playerId = playerInfo?.playerId ?: &quot;anonymous_user&quot;&#10;&#10;            webSocketManager.init(&#10;                playerId = playerId,&#10;                onSuccess = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket connection successful&quot;)&#10;                },&#10;                onFailure = { error -&gt;&#10;                    Log.e(&quot;AuthViewModel&quot;, &quot;WebSocket connection failed: $error&quot;)&#10;                },&#10;                onDisconnect = {&#10;                    Log.d(&quot;AuthViewModel&quot;, &quot;WebSocket disconnected&quot;)&#10;                }&#10;            )&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AuthViewModel&quot;, &quot;Failed to connect to WebSocket: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        repository.clearStoredPlayerInfo()&#10;        webSocketManager.disconnect()&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    private fun checkStoredAuth() {&#10;        val playerInfo = repository.getStoredPlayerInfo()&#10;        if (playerInfo != null) {&#10;            // Konvertiere PlayerInfo zu AuthResponse für konsistente State-Behandlung&#10;            val authResponse = AuthResponse(&#10;                playerId = playerInfo.playerId,&#10;                name = playerInfo.name,&#10;                email = playerInfo.email ?: &quot;&quot;,&#10;                playedGames = playerInfo.playedGames,&#10;                win = playerInfo.win,&#10;                draw = playerInfo.draw,&#10;                lose = playerInfo.lose&#10;            )&#10;            _authState.value = AuthState.Success(authResponse)&#10;        }&#10;    }&#10;&#10;    fun getStoredPlayerInfo(): PlayerInfo? {&#10;        return repository.getStoredPlayerInfo()&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val response: AuthResponse) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/auth/presemtation/LoginScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.auth.presemtation&#10;&#10;import android.app.Activity&#10;import android.util.Log&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Text&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import com.google.android.gms.auth.api.signin.GoogleSignIn&#10;import com.google.android.gms.auth.api.signin.GoogleSignInOptions&#10;&#10;@Composable&#10;fun LoginScreen(viewModel: AuthViewModel) {&#10;    val context = LocalContext.current&#10;    val authState by viewModel.authState.collectAsState()&#10;&#10;    // Launcher für Google Sign-In ohne ID Token (funktioniert immer)&#10;    val googleSignInLauncher = rememberLauncherForActivityResult(&#10;        contract = ActivityResultContracts.StartActivityForResult()&#10;    ) { result -&gt;&#10;        Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In result: ${result.resultCode}&quot;)&#10;&#10;        if (result.resultCode == Activity.RESULT_OK) {&#10;            try {&#10;                val task = GoogleSignIn.getSignedInAccountFromIntent(result.data)&#10;                val account = task.getResult(Exception::class.java)&#10;&#10;                if (account?.id != null &amp;&amp; account.email != null) {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Google Sign-In successful, sending to server...&quot;)&#10;                    viewModel.loginWithGoogleAlternative(account.id!!, account.email!!)&#10;                } else {&#10;                    Log.e(&quot;LoginScreen&quot;, &quot;Google account data incomplete&quot;)&#10;                    viewModel.setErrorMessage(&quot;Google-Account-Daten unvollständig&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;LoginScreen&quot;, &quot;Google Sign-In error: ${e.message}&quot;, e)&#10;                viewModel.setErrorMessage(&quot;Google Sign-In Fehler: ${e.message}&quot;)&#10;            }&#10;        } else if (result.resultCode == Activity.RESULT_CANCELED) {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In was cancelled by user&quot;)&#10;            viewModel.setErrorMessage(&quot;Anmeldung wurde abgebrochen&quot;)&#10;        } else {&#10;            Log.w(&quot;LoginScreen&quot;, &quot;Google Sign-In failed with result code: ${result.resultCode}&quot;)&#10;            viewModel.setErrorMessage(&quot;Google Sign-In fehlgeschlagen&quot;)&#10;        }&#10;    }&#10;&#10;    // UI&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp),&#10;            modifier = Modifier.padding(32.dp)&#10;        ) {&#10;            // Haupt Google Sign-In Button&#10;            Button(&#10;                onClick = {&#10;                    Log.d(&quot;LoginScreen&quot;, &quot;Starting Google Sign-In...&quot;)&#10;&#10;                    try {&#10;                        // Erweiterte Google Sign-In Konfiguration für bessere Kompatibilität&#10;                        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)&#10;                            .requestEmail()&#10;                            .requestProfile()&#10;                            .requestId()&#10;                            .build()&#10;&#10;                        val googleSignInClient = GoogleSignIn.getClient(context, gso)&#10;&#10;                        // Lösche vorherige Anmeldungen um sicherzustellen, dass der Account-Auswahl Dialog angezeigt wird&#10;                        googleSignInClient.signOut().addOnCompleteListener {&#10;                            Log.d(&quot;LoginScreen&quot;, &quot;Previous sign-out completed, launching sign-in&quot;)&#10;                            googleSignInLauncher.launch(googleSignInClient.signInIntent)&#10;                        }&#10;                    } catch (e: Exception) {&#10;                        Log.e(&quot;LoginScreen&quot;, &quot;Error starting Google Sign-In: ${e.message}&quot;, e)&#10;                        viewModel.setErrorMessage(&quot;Fehler beim Starten der Google-Anmeldung: ${e.message}&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                enabled = authState !is AuthState.Loading&#10;            ) {&#10;                Text(&quot;Mit Google anmelden&quot;)&#10;            }&#10;&#10;            // Status anzeigen&#10;            when (val state = authState) {&#10;                is AuthState.Loading -&gt; Text(&quot;Anmeldung läuft...&quot;)&#10;                is AuthState.Success -&gt; Text(&quot;Willkommen ${state.response.name}!&quot;)&#10;                is AuthState.Error -&gt; Text(&quot;Fehler: ${state.message}&quot;)&#10;                AuthState.Idle -&gt; Text(&quot;Bereit zum Anmelden&quot;)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/UserApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/api/UserApi.kt" />
              <option name="originalContent" value="package app.chesspresso.data.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.PATCH&#10;&#10;// Datenklasse für die Anfrage&#10; data class ChangeUsernameRequest(val newUsername: String)&#10;&#10;// Datenklasse für die Passwortänderung&#10; data class ChangePasswordRequest(&#10;     val oldPassword: String,&#10;     val newPassword: String&#10; )&#10;&#10;interface UserApi {&#10;    @PATCH(&quot;/user/username&quot;)&#10;    suspend fun changeUsername(@Body request: ChangeUsernameRequest): Response&lt;Unit&gt;&#10;&#10;    @PATCH(&quot;/user/password&quot;)&#10;    suspend fun changePassword(@Body request: ChangePasswordRequest): Response&lt;Unit&gt;&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.data.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.PATCH&#10;&#10;// Datenklasse für die Anfrage&#10; data class ChangeUsernameRequest(val newUsername: String)&#10;&#10;// Datenklasse für die Passwortänderung&#10; data class ChangePasswordRequest(&#10;     val oldPassword: String,&#10;     val newPassword: String&#10; )&#10;&#10;interface UserApi {&#10;    @PATCH(&quot;/user/username&quot;)&#10;    suspend fun changeUsername(@Body request: ChangeUsernameRequest): Response&lt;Unit&gt;&#10;&#10;    @PATCH(&quot;/user/password&quot;)&#10;    suspend fun changePassword(@Body request: ChangePasswordRequest): Response&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/data/repository/StatsRepository.kt" />
              <option name="originalContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.data.repository&#10;&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.StatsResponse&#10;import javax.inject.Inject&#10;&#10;class StatsRepository @Inject constructor(&#10;    private val statsApi: StatsApi&#10;) {&#10;    suspend fun getMyStats(): StatsResponse {&#10;        val response = statsApi.getMyStats()&#10;        if (response.isSuccessful) {&#10;            val body = response.body()&#10;            if (body != null) {&#10;                return body&#10;            } else {&#10;                throw Exception(&quot;Leere Antwort vom Server.&quot;)&#10;            }&#10;        } else {&#10;            throw Exception(&quot;Fehler beim Laden der Stats: ${response.code()} ${response.message()}&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/di/AppModule.kt" />
              <option name="originalContent" value="package app.chesspresso.di&#10;&#10;import android.content.Context&#10;import app.chesspresso.api.LobbyApiService&#10;import app.chesspresso.auth.data.AuthApi&#10;import app.chesspresso.auth.data.AuthRepository&#10;import app.chesspresso.data.api.GameApi&#10;import app.chesspresso.data.api.StatsApi&#10;import app.chesspresso.data.api.UserApi&#10;import app.chesspresso.data.network.AuthInterceptor&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyService&#10;import app.chesspresso.websocket.StompWebSocketService&#10;import com.google.gson.Gson&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import okhttp3.OkHttpClient&#10;import okhttp3.logging.HttpLoggingInterceptor&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Singleton&#10;import app.chesspresso.data.api.AuthApi as JwtAuthApi&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object AppModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideTokenStorage(@ApplicationContext context: Context): TokenStorage {&#10;        return TokenStorage(context)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthInterceptor(tokenStorage: TokenStorage): AuthInterceptor {&#10;        return AuthInterceptor(tokenStorage)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient {&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#10;            level = HttpLoggingInterceptor.Level.BODY&#10;        }&#10;&#10;        return OkHttpClient.Builder()&#10;            .addInterceptor(authInterceptor)&#10;            .addInterceptor(loggingInterceptor)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#10;        return Retrofit.Builder()&#10;            .baseUrl(&quot;http://10.0.2.2:8080/&quot;) // Android Emulator localhost&#10;            .client(okHttpClient)&#10;            .addConverterFactory(GsonConverterFactory.create())&#10;            .build()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#10;        return retrofit.create(AuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideJwtAuthApi(retrofit: Retrofit): JwtAuthApi {&#10;        return retrofit.create(JwtAuthApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGameApi(retrofit: Retrofit): GameApi {&#10;        return retrofit.create(GameApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLobbyApiService(retrofit: Retrofit): LobbyApiService {&#10;        return retrofit.create(LobbyApiService::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideGson(): Gson {&#10;        return Gson()&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideLobbyService(&#10;        lobbyApiService: LobbyApiService,&#10;        webSocketService: StompWebSocketService,&#10;        gson: Gson&#10;    ): LobbyService {&#10;        return LobbyService(lobbyApiService, webSocketService, gson)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAuthRepository(&#10;        authApi: AuthApi,&#10;        jwtAuthApi: JwtAuthApi,&#10;        tokenStorage: TokenStorage,&#10;        @ApplicationContext context: Context,&#10;        webSocketService: StompWebSocketService&#10;    ): AuthRepository {&#10;        return AuthRepository(authApi, jwtAuthApi, tokenStorage, context, webSocketService)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideStompWebSocketService(&#10;        tokenStorage: TokenStorage&#10;    ): StompWebSocketService {&#10;        return StompWebSocketService(tokenStorage)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideStatsApi(retrofit: Retrofit): StatsApi {&#10;        return retrofit.create(StatsApi::class.java)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideStatsRepository(statsApi: StatsApi): app.chesspresso.data.repository.StatsRepository {&#10;        return app.chesspresso.data.repository.StatsRepository(statsApi)&#10;    }&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideUserApi(retrofit: Retrofit): UserApi {&#10;        return retrofit.create(UserApi::class.java)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.di&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import app.chesspresso.api.LobbyApiService&#13;&#10;import app.chesspresso.auth.data.AuthApi&#13;&#10;import app.chesspresso.auth.data.AuthRepository&#13;&#10;import app.chesspresso.data.api.GameApi&#13;&#10;import app.chesspresso.data.api.StatsApi&#13;&#10;import app.chesspresso.data.api.UserApi&#13;&#10;import app.chesspresso.data.network.AuthInterceptor&#13;&#10;import app.chesspresso.data.storage.TokenStorage&#13;&#10;import app.chesspresso.service.LobbyService&#13;&#10;import app.chesspresso.websocket.StompWebSocketService&#13;&#10;import com.google.gson.Gson&#13;&#10;import dagger.Module&#13;&#10;import dagger.Provides&#13;&#10;import dagger.hilt.InstallIn&#13;&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#13;&#10;import dagger.hilt.components.SingletonComponent&#13;&#10;import okhttp3.OkHttpClient&#13;&#10;import okhttp3.logging.HttpLoggingInterceptor&#13;&#10;import retrofit2.Retrofit&#13;&#10;import retrofit2.converter.gson.GsonConverterFactory&#13;&#10;import java.util.concurrent.TimeUnit&#13;&#10;import javax.inject.Singleton&#13;&#10;import app.chesspresso.data.api.AuthApi as JwtAuthApi&#13;&#10;&#13;&#10;@Module&#13;&#10;@InstallIn(SingletonComponent::class)&#13;&#10;object AppModule {&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideTokenStorage(@ApplicationContext context: Context): TokenStorage {&#13;&#10;        return TokenStorage(context)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideAuthInterceptor(tokenStorage: TokenStorage): AuthInterceptor {&#13;&#10;        return AuthInterceptor(tokenStorage)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideOkHttpClient(authInterceptor: AuthInterceptor): OkHttpClient {&#13;&#10;        val loggingInterceptor = HttpLoggingInterceptor().apply {&#13;&#10;            level = HttpLoggingInterceptor.Level.BODY&#13;&#10;        }&#13;&#10;&#13;&#10;        return OkHttpClient.Builder()&#13;&#10;            .addInterceptor(authInterceptor)&#13;&#10;            .addInterceptor(loggingInterceptor)&#13;&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#13;&#10;            .readTimeout(30, TimeUnit.SECONDS)&#13;&#10;            .writeTimeout(30, TimeUnit.SECONDS)&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {&#13;&#10;        return Retrofit.Builder()&#13;&#10;            .baseUrl(&quot;http://10.0.2.2:8080/&quot;) // Android Emulator localhost&#13;&#10;            .client(okHttpClient)&#13;&#10;            .addConverterFactory(GsonConverterFactory.create())&#13;&#10;            .build()&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideAuthApi(retrofit: Retrofit): AuthApi {&#13;&#10;        return retrofit.create(AuthApi::class.java)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideJwtAuthApi(retrofit: Retrofit): JwtAuthApi {&#13;&#10;        return retrofit.create(JwtAuthApi::class.java)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideGameApi(retrofit: Retrofit): GameApi {&#13;&#10;        return retrofit.create(GameApi::class.java)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideLobbyApiService(retrofit: Retrofit): LobbyApiService {&#13;&#10;        return retrofit.create(LobbyApiService::class.java)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideGson(): Gson {&#13;&#10;        return Gson()&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideLobbyService(&#13;&#10;        lobbyApiService: LobbyApiService,&#13;&#10;        webSocketService: StompWebSocketService,&#13;&#10;        gson: Gson&#13;&#10;    ): LobbyService {&#13;&#10;        return LobbyService(lobbyApiService, webSocketService, gson)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideAuthRepository(&#13;&#10;        authApi: AuthApi,&#13;&#10;        jwtAuthApi: JwtAuthApi,&#13;&#10;        tokenStorage: TokenStorage,&#13;&#10;        @ApplicationContext context: Context,&#13;&#10;        webSocketService: StompWebSocketService&#13;&#10;    ): AuthRepository {&#13;&#10;        return AuthRepository(authApi, jwtAuthApi, tokenStorage, context, webSocketService)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideStompWebSocketService(&#13;&#10;        tokenStorage: TokenStorage&#13;&#10;    ): StompWebSocketService {&#13;&#10;        return StompWebSocketService(tokenStorage)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideStatsApi(retrofit: Retrofit): StatsApi {&#13;&#10;        return retrofit.create(StatsApi::class.java)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideStatsRepository(statsApi: StatsApi): app.chesspresso.data.repository.StatsRepository {&#13;&#10;        return app.chesspresso.data.repository.StatsRepository(statsApi)&#13;&#10;    }&#13;&#10;&#13;&#10;    @Provides&#13;&#10;    @Singleton&#13;&#10;    fun provideUserApi(retrofit: Retrofit): UserApi {&#13;&#10;        return retrofit.create(UserApi::class.java)&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/LobbyWaitingScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.RadioButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    isCreator: Boolean,&#10;    lobbyCode: String,&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val navigationEvent by viewModel.navigationEvent.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameTime by remember { mutableStateOf(GameTime.MIDDLE) }&#10;    var selectedWhitePlayer by remember { mutableStateOf(&quot;&quot;) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;&#10;    // Navigation nach Home wenn Lobby verlassen wurde&#10;    LaunchedEffect(navigationEvent) {&#10;        if (navigationEvent == &quot;home&quot;) {&#10;            onBackClick()&#10;            viewModel.onNavigated()&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    // Spieler-Namen aktualisieren wenn Lobby geladen wird&#10;    LaunchedEffect(currentLobby) {&#10;        currentLobby?.let { lobby -&gt;&#10;            if (lobby.players.isNotEmpty()) {&#10;                selectedWhitePlayer = lobby.players.first()&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        // nur wenn nur ein Spieler in der Lobby ist&#10;        if (currentLobby?.players?.size != 2) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Teile diesen Code mit deinem Freund&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code für Lobby-Ersteller anzeigen (nur wenn noch Platz frei ist)&#10;        if (isCreator &amp;&amp; currentLobby?.players?.size != 2) {&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Spieler-Status&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2):&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                currentLobby?.let { lobby -&gt;&#10;                    lobby.players.forEachIndexed { index, player -&gt;&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Person,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (currentLobby?.players?.size != 2) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(24.dp),&#10;                                strokeWidth = 2.dp&#10;                            )&#10;                            Text(&#10;                                text = &quot;Warte auf zweiten Spieler...&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Spieleinstellungen Card (nur für Ersteller)&#10;        currentLobby?.let { lobby -&gt;&#10;            if (isCreator) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Spiel-Einstellungen&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;&#10;                        // Spielzeit-Auswahl&#10;                        Text(&#10;                            text = &quot;Spielzeit:&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;&#10;                        GameTime.entries.forEach { gameTime -&gt;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = selectedGameTime == gameTime,&#10;                                        onClick = { selectedGameTime = gameTime }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = selectedGameTime == gameTime,&#10;                                    onClick = { selectedGameTime = gameTime }&#10;                                )&#10;                                Text(&#10;                                    text = gameTime.displayName,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Farbauswahl Card (nur wenn beide Spieler da sind)&#10;                if (lobby.players.size == 2) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Farbauswahl&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = randomColors,&#10;                                        onClick = { randomColors = true }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = randomColors,&#10;                                    onClick = { randomColors = true }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Zufällig&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = !randomColors,&#10;                                        onClick = { randomColors = false }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = !randomColors,&#10;                                    onClick = { randomColors = false }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Manuell auswählen&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            if (!randomColors) {&#10;                                Text(&#10;                                    text = &quot;Weiß spielt:&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                lobby.players.forEachIndexed { index, player -&gt;&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .selectable(&#10;                                                selected = selectedWhitePlayer == player,&#10;                                                onClick = { selectedWhitePlayer = player }&#10;                                            )&#10;                                            .padding(vertical = 2.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        RadioButton(&#10;                                            selected = selectedWhitePlayer == player,&#10;                                            onClick = { selectedWhitePlayer = player }&#10;                                        )&#10;                                        Text(&#10;                                            text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                            modifier = Modifier.padding(start = 8.dp),&#10;                                            style = MaterialTheme.typography.bodySmall&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Spiel starten Button&#10;                    Button(&#10;                        onClick = {&#10;                            val whitePlayerFinal = if (randomColors) null else selectedWhitePlayer&#10;                            val blackPlayerFinal =&#10;                                if (randomColors) null else lobby.players.find { it != selectedWhitePlayer }&#10;&#10;                            viewModel.configureAndStartGame(&#10;                                lobbyCode = lobbyCode,&#10;                                gameTime = selectedGameTime,&#10;                                whitePlayer = whitePlayerFinal,&#10;                                blackPlayer = blackPlayerFinal,&#10;                                randomColors = randomColors&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        enabled = !uiState.isLoading&#10;                    ) {&#10;                        if (uiState.isLoading) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(20.dp),&#10;                                color = MaterialTheme.colorScheme.onPrimary&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;                        Text(&quot;Spiel starten&quot;)&#10;                    }&#10;                }&#10;            } else if (lobby.players.size == 2) {&#10;                // Warte-Status für den zweiten Spieler&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(24.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = &quot;Warte auf Spiel-Start...&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Text(&#10;                            text = &quot;Der Lobby-Ersteller richtet das Spiel ein.&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Lobby verlassen Button&#10;        OutlinedButton(&#10;            onClick = {&#10;                viewModel.leaveLobby()&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = ButtonDefaults.outlinedButtonColors(&#10;                contentColor = MaterialTheme.colorScheme.error&#10;            )&#10;        ) {&#10;            Text(&quot;Lobby verlassen&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.selection.selectable&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.ButtonDefaults&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedButton&#10;import androidx.compose.material3.RadioButton&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.setValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.model.lobby.GameTime&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;&#10;@Composable&#10;fun LobbyWaitingScreen(&#10;    isCreator: Boolean,&#10;    lobbyCode: String,&#10;    onBackClick: () -&gt; Unit,&#10;    onGameStart: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val currentLobby by viewModel.currentLobby.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val navigationEvent by viewModel.navigationEvent.collectAsStateWithLifecycle()&#10;&#10;    var selectedGameTime by remember { mutableStateOf(GameTime.MIDDLE) }&#10;    var selectedWhitePlayer by remember { mutableStateOf(&quot;&quot;) }&#10;    var randomColors by remember { mutableStateOf(true) }&#10;&#10;&#10;    // Navigation nach Home wenn Lobby verlassen wurde&#10;    LaunchedEffect(navigationEvent) {&#10;        if (navigationEvent == &quot;home&quot;) {&#10;            onBackClick()&#10;            viewModel.onNavigated()&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            onGameStart(gameStart.lobbyId)&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    // Lobby-Info beim Laden des Screens abrufen&#10;    LaunchedEffect(lobbyCode) {&#10;        viewModel.refreshLobbyInfo(lobbyCode)&#10;    }&#10;&#10;    // Regelmäßige Aktualisierung der Lobby-Info alle 3 Sekunden&#10;    LaunchedEffect(lobbyCode) {&#10;        while (true) {&#10;            kotlinx.coroutines.delay(3000) // 3 Sekunden warten&#10;            viewModel.refreshLobbyInfo(lobbyCode)&#10;        }&#10;    }&#10;&#10;    // Spieler-Namen aktualisieren wenn Lobby geladen wird&#10;    LaunchedEffect(currentLobby) {&#10;        currentLobby?.let { lobby -&gt;&#10;            if (lobby.players.isNotEmpty()) {&#10;                selectedWhitePlayer = lobby.players.first()&#10;            }&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;            .padding(24.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Header&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;Deine Lobby: $lobbyCode&quot;,&#10;                style = MaterialTheme.typography.headlineMedium,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;        }&#10;&#10;        // nur wenn nur ein Spieler in der Lobby ist&#10;        if (currentLobby?.players?.size != 2) {&#10;            Card(&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.padding(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Teile diesen Code mit deinem Freund&quot;,&#10;                        style = MaterialTheme.typography.bodySmall,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code für Lobby-Ersteller anzeigen (nur wenn noch Platz frei ist)&#10;        if (isCreator &amp;&amp; currentLobby?.players?.size != 2) {&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Spieler-Status&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Spieler (${currentLobby?.players?.size ?: 1}/2):&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                currentLobby?.let { lobby -&gt;&#10;                    lobby.players.forEachIndexed { index, player -&gt;&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.Person,&#10;                                contentDescription = null,&#10;                                tint = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            Text(&#10;                                text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    if (currentLobby?.players?.size != 2) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(24.dp),&#10;                                strokeWidth = 2.dp&#10;                            )&#10;                            Text(&#10;                                text = &quot;Warte auf zweiten Spieler...&quot;,&#10;                                modifier = Modifier.padding(start = 8.dp),&#10;                                style = MaterialTheme.typography.bodyLarge,&#10;                                color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Spieleinstellungen Card (nur für Ersteller)&#10;        currentLobby?.let { lobby -&gt;&#10;            if (isCreator) {&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Spiel-Einstellungen&quot;,&#10;                            style = MaterialTheme.typography.titleMedium,&#10;                            fontWeight = FontWeight.Bold&#10;                        )&#10;&#10;                        // Spielzeit-Auswahl&#10;                        Text(&#10;                            text = &quot;Spielzeit:&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            fontWeight = FontWeight.Medium&#10;                        )&#10;&#10;                        GameTime.entries.forEach { gameTime -&gt;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = selectedGameTime == gameTime,&#10;                                        onClick = { selectedGameTime = gameTime }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = selectedGameTime == gameTime,&#10;                                    onClick = { selectedGameTime = gameTime }&#10;                                )&#10;                                Text(&#10;                                    text = gameTime.displayName,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Farbauswahl Card (nur wenn beide Spieler da sind)&#10;                if (lobby.players.size == 2) {&#10;                    Card(&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        Column(&#10;                            modifier = Modifier.padding(16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Farbauswahl&quot;,&#10;                                style = MaterialTheme.typography.titleMedium,&#10;                                fontWeight = FontWeight.Bold&#10;                            )&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = randomColors,&#10;                                        onClick = { randomColors = true }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = randomColors,&#10;                                    onClick = { randomColors = true }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Zufällig&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .selectable(&#10;                                        selected = !randomColors,&#10;                                        onClick = { randomColors = false }&#10;                                    )&#10;                                    .padding(vertical = 4.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                RadioButton(&#10;                                    selected = !randomColors,&#10;                                    onClick = { randomColors = false }&#10;                                )&#10;                                Text(&#10;                                    text = &quot;Manuell auswählen&quot;,&#10;                                    modifier = Modifier.padding(start = 8.dp),&#10;                                    style = MaterialTheme.typography.bodyMedium&#10;                                )&#10;                            }&#10;&#10;                            if (!randomColors) {&#10;                                Text(&#10;                                    text = &quot;Weiß spielt:&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                                )&#10;                                lobby.players.forEachIndexed { index, player -&gt;&#10;                                    Row(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .selectable(&#10;                                                selected = selectedWhitePlayer == player,&#10;                                                onClick = { selectedWhitePlayer = player }&#10;                                            )&#10;                                            .padding(vertical = 2.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        RadioButton(&#10;                                            selected = selectedWhitePlayer == player,&#10;                                            onClick = { selectedWhitePlayer = player }&#10;                                        )&#10;                                        Text(&#10;                                            text = &quot;Spieler ${index + 1}${if (player == lobby.creator) &quot; (Ersteller)&quot; else &quot;&quot;}&quot;,&#10;                                            modifier = Modifier.padding(start = 8.dp),&#10;                                            style = MaterialTheme.typography.bodySmall&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Spiel starten Button&#10;                    Button(&#10;                        onClick = {&#10;                            val whitePlayerFinal = if (randomColors) null else selectedWhitePlayer&#10;                            val blackPlayerFinal =&#10;                                if (randomColors) null else lobby.players.find { it != selectedWhitePlayer }&#10;&#10;                            viewModel.configureAndStartGame(&#10;                                lobbyCode = lobbyCode,&#10;                                gameTime = selectedGameTime,&#10;                                whitePlayer = whitePlayerFinal,&#10;                                blackPlayer = blackPlayerFinal,&#10;                                randomColors = randomColors&#10;                            )&#10;                        },&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        enabled = !uiState.isLoading&#10;                    ) {&#10;                        if (uiState.isLoading) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(20.dp),&#10;                                color = MaterialTheme.colorScheme.onPrimary&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                        }&#10;                        Text(&quot;Spiel starten&quot;)&#10;                    }&#10;                }&#10;            } else if (lobby.players.size == 2) {&#10;                // Warte-Status für den zweiten Spieler&#10;                Card(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .padding(24.dp)&#10;                            .fillMaxWidth(),&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                        Text(&#10;                            text = &quot;Warte auf Spiel-Start...&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Text(&#10;                            text = &quot;Der Lobby-Ersteller richtet das Spiel ein.&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                            textAlign = TextAlign.Center&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Lobby verlassen Button&#10;        OutlinedButton(&#10;            onClick = {&#10;                viewModel.leaveLobby()&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            colors = ButtonDefaults.outlinedButtonColors(&#10;                contentColor = MaterialTheme.colorScheme.error&#10;            )&#10;        ) {&#10;            Text(&quot;Lobby verlassen&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/PrivateLobbyScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/lobby/PrivateLobbyScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.HorizontalDivider&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardCapitalization&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PrivateLobbyScreen(&#10;    onLobbyCreated: (String) -&gt; Unit,&#10;    onLobbyJoined: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;&#10;    // Navigation bei erfolgreichem Lobby-Erstellen/Beitreten&#10;    LaunchedEffect(uiState.isLobbyCreated, uiState.createdLobbyCode) {&#10;        if (uiState.isLobbyCreated &amp;&amp; uiState.createdLobbyCode != null) {&#10;            onLobbyCreated(uiState.createdLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.isLobbyJoined, uiState.joinedLobbyCode) {&#10;        if (uiState.isLobbyJoined &amp;&amp; uiState.joinedLobbyCode != null) {&#10;            onLobbyJoined(uiState.joinedLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            // Navigation zum Spiel&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;&#10;        // Lobby erstellen&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Neue Lobby erstellen&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Erstelle eine private Lobby und teile den Code mit deinem Freund.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                Button(&#10;                    onClick = { viewModel.createPrivateLobby() },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isLoading&#10;                ) {&#10;                    if (uiState.isLoading) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby erstellen&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code für erstellte Lobby anzeigen&#10;        uiState.createdLobbyCode?.let { lobbyCode -&gt;&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Trennlinie&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Center&#10;        ) {&#10;            HorizontalDivider(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .align(Alignment.CenterVertically)&#10;            )&#10;            Text(&#10;                text = &quot;ODER&quot;,&#10;                style = MaterialTheme.typography.labelMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                modifier = Modifier.padding(horizontal = 8.dp)&#10;            )&#10;            HorizontalDivider(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .align(Alignment.CenterVertically)&#10;            )&#10;        }&#10;&#10;        // Lobby beitreten&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby beitreten&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Gib den 6-stelligen Lobby-Code ein, den du von deinem Freund erhalten hast.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = uiState.joinCode,&#10;                    onValueChange = viewModel::updateJoinCode,&#10;                    label = { Text(&quot;Lobby-Code&quot;) },&#10;                    placeholder = { Text(&quot;ABC123&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isLoading,&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(&#10;                        capitalization = KeyboardCapitalization.Characters,&#10;                        imeAction = ImeAction.Go&#10;                    ),&#10;                    keyboardActions = KeyboardActions(&#10;                        onGo = {&#10;                            if (uiState.joinCode.length == 6) {&#10;                                keyboardController?.hide()&#10;                                viewModel.joinPrivateLobby(uiState.joinCode)&#10;                            }&#10;                        }&#10;                    ),&#10;                    supportingText = {&#10;                        Text(&quot;${uiState.joinCode.length}/6 Zeichen&quot;)&#10;                    }&#10;                )&#10;&#10;                Button(&#10;                    onClick = {&#10;                        keyboardController?.hide()&#10;                        viewModel.joinPrivateLobby(uiState.joinCode)&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isLoading &amp;&amp; uiState.joinCode.length == 6&#10;                ) {&#10;                    if (uiState.isLoading) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby beitreten&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code Scanner für Lobby beitreten&#10;        QRScannerButton(&#10;            onLobbyScanned = { lobbyId -&gt;&#10;                // Setze den gescannten Lobby-Code und trete der Lobby bei&#10;                viewModel.updateJoinCode(lobbyId)&#10;                viewModel.joinPrivateLobby(lobbyId)&#10;            },&#10;            enabled = !uiState.isLoading&#10;        )&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        uiState.error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.lobby&#10;&#10;import androidx.compose.foundation.layout.Arrangement&#10;import androidx.compose.foundation.layout.Column&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.Spacer&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.foundation.layout.width&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.Card&#10;import androidx.compose.material3.CardDefaults&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.HorizontalDivider&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.KeyboardCapitalization&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import app.chesspresso.viewmodel.PrivateLobbyViewModel&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun PrivateLobbyScreen(&#10;    onLobbyCreated: (String) -&gt; Unit,&#10;    onLobbyJoined: (String) -&gt; Unit,&#10;    viewModel: PrivateLobbyViewModel = hiltViewModel()&#10;) {&#10;    val uiState by viewModel.uiState.collectAsStateWithLifecycle()&#10;    val error by viewModel.lobbyError.collectAsStateWithLifecycle()&#10;    val gameStarted by viewModel.gameStarted.collectAsStateWithLifecycle()&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;&#10;    // Navigation bei erfolgreichem Lobby-Erstellen/Beitreten&#10;    LaunchedEffect(uiState.isLobbyCreated, uiState.createdLobbyCode) {&#10;        if (uiState.isLobbyCreated &amp;&amp; uiState.createdLobbyCode != null) {&#10;            onLobbyCreated(uiState.createdLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(uiState.isLobbyJoined, uiState.joinedLobbyCode) {&#10;        if (uiState.isLobbyJoined &amp;&amp; uiState.joinedLobbyCode != null) {&#10;            onLobbyJoined(uiState.joinedLobbyCode!!)&#10;        }&#10;    }&#10;&#10;    // Automatische Navigation bei Spielstart&#10;    LaunchedEffect(gameStarted) {&#10;        gameStarted?.let { gameStart -&gt;&#10;            // Navigation zum Spiel&#10;            viewModel.clearGameStart()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .padding(24.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;&#10;        // Lobby erstellen&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Neue Lobby erstellen&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Erstelle eine private Lobby und teile den Code mit deinem Freund.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                Button(&#10;                    onClick = { viewModel.createPrivateLobby() },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isLoading&#10;                ) {&#10;                    if (uiState.isLoading) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby erstellen&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code für erstellte Lobby anzeigen&#10;        uiState.createdLobbyCode?.let { lobbyCode -&gt;&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyCode&#10;            )&#10;        }&#10;&#10;        // Trennlinie&#10;        Row(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.Center&#10;        ) {&#10;            HorizontalDivider(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .align(Alignment.CenterVertically)&#10;            )&#10;            Text(&#10;                text = &quot;ODER&quot;,&#10;                style = MaterialTheme.typography.labelMedium,&#10;                color = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                modifier = Modifier.padding(horizontal = 8.dp)&#10;            )&#10;            HorizontalDivider(&#10;                modifier = Modifier&#10;                    .weight(1f)&#10;                    .align(Alignment.CenterVertically)&#10;            )&#10;        }&#10;&#10;        // Lobby beitreten&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth()&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp),&#10;                verticalArrangement = Arrangement.spacedBy(12.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby beitreten&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;                Text(&#10;                    text = &quot;Gib den 6-stelligen Lobby-Code ein, den du von deinem Freund erhalten hast.&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = uiState.joinCode,&#10;                    onValueChange = viewModel::updateJoinCode,&#10;                    label = { Text(&quot;Lobby-Code&quot;) },&#10;                    placeholder = { Text(&quot;ABC123&quot;) },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isLoading,&#10;                    singleLine = true,&#10;                    keyboardOptions = KeyboardOptions(&#10;                        capitalization = KeyboardCapitalization.Characters,&#10;                        imeAction = ImeAction.Go&#10;                    ),&#10;                    keyboardActions = KeyboardActions(&#10;                        onGo = {&#10;                            if (uiState.joinCode.length == 6) {&#10;                                keyboardController?.hide()&#10;                                viewModel.joinPrivateLobby(uiState.joinCode)&#10;                            }&#10;                        }&#10;                    ),&#10;                    supportingText = {&#10;                        Text(&quot;${uiState.joinCode.length}/6 Zeichen&quot;)&#10;                    }&#10;                )&#10;&#10;                Button(&#10;                    onClick = {&#10;                        keyboardController?.hide()&#10;                        viewModel.joinPrivateLobby(uiState.joinCode)&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    enabled = !uiState.isLoading &amp;&amp; uiState.joinCode.length == 6&#10;                ) {&#10;                    if (uiState.isLoading) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            color = MaterialTheme.colorScheme.onPrimary&#10;                        )&#10;                        Spacer(modifier = Modifier.width(8.dp))&#10;                    }&#10;                    Text(&quot;Lobby beitreten&quot;)&#10;                }&#10;            }&#10;        }&#10;&#10;        // QR-Code Scanner für Lobby beitreten&#10;        QRScannerButton(&#10;            onLobbyScanned = { lobbyId -&gt;&#10;                // Setze den gescannten Lobby-Code und trete der Lobby bei&#10;                viewModel.updateJoinCode(lobbyId)&#10;                viewModel.joinPrivateLobby(lobbyId)&#10;            },&#10;            enabled = !uiState.isLoading&#10;        )&#10;&#10;        // Fehleranzeige&#10;        error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;&#10;        uiState.error?.let { errorMessage -&gt;&#10;            Card(&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = MaterialTheme.colorScheme.errorContainer&#10;                )&#10;            ) {&#10;                Text(&#10;                    text = errorMessage,&#10;                    modifier = Modifier.padding(16.dp),&#10;                    color = MaterialTheme.colorScheme.onErrorContainer,&#10;                    style = MaterialTheme.typography.bodyMedium&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/MainScaffoldScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/MainScaffoldScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import app.chesspresso.R&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.screens.lobby.LobbyWaitingScreen&#10;import app.chesspresso.screens.lobby.PrivateLobbyScreen&#10;import app.chesspresso.screens.lobby.QuickMatchScreen&#10;import app.chesspresso.websocket.WebSocketViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScaffoldScreen(&#10;    authViewModel: AuthViewModel,&#10;    webSocketViewModel: WebSocketViewModel,&#10;    outerNavController: NavHostController&#10;) {&#10;    val innerNavController = rememberNavController()&#10;    val currentRoute by innerNavController.currentBackStackEntryAsState()&#10;    val selectedRoute = currentRoute?.destination?.route ?: &quot;home&quot;&#10;&#10;    // Prüfe, ob wir uns in einem Lobby-Screen befinden&#10;    val isLobbyScreen =&#10;        selectedRoute == NavRoutes.QUICK_MATCH || selectedRoute == NavRoutes.PRIVATE_LOBBY&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    if (isLobbyScreen) {&#10;                        IconButton(onClick = { innerNavController.navigateUp() }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.ArrowBack,&#10;                                contentDescription = &quot;Zurück&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.watermark_chess),&#10;                            contentDescription = &quot;App-Logo&quot;,&#10;                            modifier = Modifier&#10;                                .size(32.dp)&#10;                                .padding(end = 8.dp),&#10;                            contentScale = ContentScale.Fit&#10;                        )&#10;                        Text(&quot;ChessPresso&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        bottomBar = {&#10;            NavigationBar {&#10;                NavigationItem.entries.forEach { item -&gt;&#10;                    NavigationBarItem(&#10;                        icon = { Icon(item.icon, contentDescription = item.label) },&#10;                        label = { Text(item.label) },&#10;                        selected = item.route == selectedRoute,&#10;                        onClick = {&#10;                            if (selectedRoute != item.route) {&#10;                                innerNavController.navigate(item.route) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = false }&#10;                                    launchSingleTop = true&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        NavHost(&#10;            navController = innerNavController,&#10;            startDestination = NavRoutes.HOME,&#10;            modifier = Modifier.padding(padding)&#10;        ) {&#10;            composable(NavRoutes.HOME) {&#10;                HomeScreen(&#10;                    onPrivateGameClick = { innerNavController.navigate(NavRoutes.PRIVATE_LOBBY) },&#10;                    onPublicGameClick = { innerNavController.navigate(NavRoutes.QUICK_MATCH) }&#10;                )&#10;            }&#10;&#10;            // Neue Lobby-Screens&#10;            composable(NavRoutes.QUICK_MATCH) {&#10;                QuickMatchScreen(&#10;                    onGameStart = { lobbyId -&gt;&#10;                        // TODO: Navigation zum Spiel-Screen&#10;                        innerNavController.navigate(&quot;game/$lobbyId&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(NavRoutes.PRIVATE_LOBBY) {&#10;                PrivateLobbyScreen(&#10;                    onLobbyCreated = { lobbyCode -&gt;&#10;                        innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/true&quot;)&#10;                    },&#10;                    onLobbyJoined = { lobbyCode -&gt;&#10;                        innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/false&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;lobby_waiting/{lobbyCode}/{isCreator}&quot;) { backStackEntry -&gt;&#10;                val lobbyCode = backStackEntry.arguments?.getString(&quot;lobbyCode&quot;) ?: &quot;&quot;&#10;                val isCreator = backStackEntry.arguments?.getString(&quot;isCreator&quot;)&#10;                    ?.toBoolean() ?: false&#10;                LobbyWaitingScreen(&#10;                    isCreator = isCreator,&#10;                    lobbyCode = lobbyCode,&#10;                    onBackClick = {&#10;                        // Explizit zum Home-Screen navigieren und alles andere löschen&#10;                        innerNavController.navigate(NavRoutes.HOME) {&#10;                            popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                            launchSingleTop = true&#10;                        }&#10;                    },&#10;                    onGameStart = { lobbyId -&gt;&#10;                        // TODO: Navigation zum Spiel-Screen&#10;                        innerNavController.navigate(&quot;game/$lobbyId&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Placeholder für Spiel-Screen&#10;            composable(&quot;game/{lobbyId}&quot;) { backStackEntry -&gt;&#10;                val lobbyId = backStackEntry.arguments?.getString(&quot;lobbyId&quot;) ?: &quot;&quot;&#10;                // TODO: GameScreen implementieren&#10;                Text(&quot;Spiel startet mit Lobby: $lobbyId&quot;)&#10;            }&#10;&#10;            // Bestehende Screens&#10;            composable(NavRoutes.STATS) {&#10;                StatsScreen()&#10;            }&#10;            composable(NavRoutes.PROFILE) {&#10;                ProfileScreen(&#10;                    authViewModel = authViewModel,&#10;                    outerNavController = outerNavController&#10;                )&#10;            }&#10;            composable(NavRoutes.SETTINGS) {&#10;                SettingsScreen()&#10;            }&#10;            composable(NavRoutes.INFO) {&#10;                InfoScreen(&#10;                    authViewModel = authViewModel,&#10;                    onLogout = {&#10;                        authViewModel.logout()&#10;                        outerNavController.navigate(&quot;welcome&quot;) {&#10;                            popUpTo(0) // Löscht den Backstack&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;enum class NavigationItem(val label: String, val icon: ImageVector, val route: String) {&#10;    Profile(&quot;Profil&quot;, Icons.Default.Person, NavRoutes.PROFILE),&#10;    Stats(&quot;Statistik&quot;, Icons.Default.Search, NavRoutes.STATS), //durch Statistik Icon ersetzen&#10;    Gameplay(&quot;Spielen&quot;, Icons.Default.Home, NavRoutes.HOME), //durch Schach-Icon ersetzen&#10;    Settings(&quot;Optionen&quot;, Icons.Default.Settings, NavRoutes.SETTINGS),&#10;    Info(&quot;Status&quot;, Icons.Default.Info, NavRoutes.INFO)&#10;}&#10;&#10;&#10;object NavRoutes {&#10;    const val HOME = &quot;home&quot;&#10;    const val PROFILE = &quot;profile&quot;&#10;    const val STATS = &quot;stats&quot;&#10;    const val SETTINGS = &quot;settings&quot;&#10;    const val INFO = &quot;info&quot;&#10;    const val QUICK_MATCH = &quot;quick_match&quot;&#10;    const val PRIVATE_LOBBY = &quot;private_lobby&quot;&#10;}" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.layout.Row&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.size&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Home&#10;import androidx.compose.material.icons.filled.Info&#10;import androidx.compose.material.icons.filled.Person&#10;import androidx.compose.material.icons.filled.Search&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material3.ExperimentalMaterial3Api&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.NavigationBar&#10;import androidx.compose.material3.NavigationBarItem&#10;import androidx.compose.material3.Scaffold&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.TopAppBar&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.vector.ImageVector&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.NavHost&#10;import androidx.navigation.compose.composable&#10;import androidx.navigation.compose.currentBackStackEntryAsState&#10;import androidx.navigation.compose.rememberNavController&#10;import app.chesspresso.R&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import app.chesspresso.screens.lobby.LobbyWaitingScreen&#10;import app.chesspresso.screens.lobby.PrivateLobbyScreen&#10;import app.chesspresso.screens.lobby.QuickMatchScreen&#10;import app.chesspresso.websocket.WebSocketViewModel&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun MainScaffoldScreen(&#10;    authViewModel: AuthViewModel,&#10;    webSocketViewModel: WebSocketViewModel,&#10;    outerNavController: NavHostController&#10;) {&#10;    val innerNavController = rememberNavController()&#10;    val currentRoute by innerNavController.currentBackStackEntryAsState()&#10;    val selectedRoute = currentRoute?.destination?.route ?: &quot;home&quot;&#10;&#10;    // Prüfe, ob wir uns in einem Lobby-Screen befinden&#10;    val isLobbyScreen =&#10;        selectedRoute == NavRoutes.QUICK_MATCH || selectedRoute == NavRoutes.PRIVATE_LOBBY&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    if (isLobbyScreen) {&#10;                        IconButton(onClick = { innerNavController.navigateUp() }) {&#10;                            Icon(&#10;                                imageVector = Icons.Default.ArrowBack,&#10;                                contentDescription = &quot;Zurück&quot;&#10;                            )&#10;                        }&#10;                    }&#10;                },&#10;                title = {&#10;                    Row(verticalAlignment = Alignment.CenterVertically) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.watermark_chess),&#10;                            contentDescription = &quot;App-Logo&quot;,&#10;                            modifier = Modifier&#10;                                .size(32.dp)&#10;                                .padding(end = 8.dp),&#10;                            contentScale = ContentScale.Fit&#10;                        )&#10;                        Text(&quot;ChessPresso&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        bottomBar = {&#10;            NavigationBar {&#10;                NavigationItem.entries.forEach { item -&gt;&#10;                    NavigationBarItem(&#10;                        icon = { Icon(item.icon, contentDescription = item.label) },&#10;                        label = { Text(item.label) },&#10;                        selected = item.route == selectedRoute,&#10;                        onClick = {&#10;                            if (selectedRoute != item.route) {&#10;                                innerNavController.navigate(item.route) {&#10;                                    popUpTo(&quot;home&quot;) { inclusive = false }&#10;                                    launchSingleTop = true&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    ) { padding -&gt;&#10;        NavHost(&#10;            navController = innerNavController,&#10;            startDestination = NavRoutes.HOME,&#10;            modifier = Modifier.padding(padding)&#10;        ) {&#10;            composable(NavRoutes.HOME) {&#10;                HomeScreen(&#10;                    onPrivateGameClick = { innerNavController.navigate(NavRoutes.PRIVATE_LOBBY) },&#10;                    onPublicGameClick = { innerNavController.navigate(NavRoutes.QUICK_MATCH) }&#10;                )&#10;            }&#10;&#10;            // Neue Lobby-Screens&#10;            composable(NavRoutes.QUICK_MATCH) {&#10;                QuickMatchScreen(&#10;                    onGameStart = { lobbyId -&gt;&#10;                        // TODO: Navigation zum Spiel-Screen&#10;                        innerNavController.navigate(&quot;game/$lobbyId&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(NavRoutes.PRIVATE_LOBBY) {&#10;                PrivateLobbyScreen(&#10;                    onLobbyCreated = { lobbyCode -&gt;&#10;                        innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/true&quot;)&#10;                    },&#10;                    onLobbyJoined = { lobbyCode -&gt;&#10;                        innerNavController.navigate(&quot;lobby_waiting/$lobbyCode/false&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            composable(&quot;lobby_waiting/{lobbyCode}/{isCreator}&quot;) { backStackEntry -&gt;&#10;                val lobbyCode = backStackEntry.arguments?.getString(&quot;lobbyCode&quot;) ?: &quot;&quot;&#10;                val isCreator = backStackEntry.arguments?.getString(&quot;isCreator&quot;)&#10;                    ?.toBoolean() ?: false&#10;                LobbyWaitingScreen(&#10;                    isCreator = isCreator,&#10;                    lobbyCode = lobbyCode,&#10;                    onBackClick = {&#10;                        // Explizit zum Home-Screen navigieren und alles andere löschen&#10;                        innerNavController.navigate(NavRoutes.HOME) {&#10;                            popUpTo(NavRoutes.HOME) { inclusive = false }&#10;                            launchSingleTop = true&#10;                        }&#10;                    },&#10;                    onGameStart = { lobbyId -&gt;&#10;                        // TODO: Navigation zum Spiel-Screen&#10;                        innerNavController.navigate(&quot;game/$lobbyId&quot;)&#10;                    }&#10;                )&#10;            }&#10;&#10;            // Placeholder für Spiel-Screen&#10;            composable(&quot;game/{lobbyId}&quot;) { backStackEntry -&gt;&#10;                val lobbyId = backStackEntry.arguments?.getString(&quot;lobbyId&quot;) ?: &quot;&quot;&#10;                // TODO: GameScreen implementieren&#10;                Text(&quot;Spiel startet mit Lobby: $lobbyId&quot;)&#10;            }&#10;&#10;            // Bestehende Screens&#10;            composable(NavRoutes.STATS) {&#10;                StatsScreen()&#10;            }&#10;            composable(NavRoutes.PROFILE) {&#10;                ProfileScreen(&#10;                    authViewModel = authViewModel,&#10;                    outerNavController = outerNavController&#10;                )&#10;            }&#10;            composable(NavRoutes.SETTINGS) {&#10;                SettingsScreen()&#10;            }&#10;            composable(NavRoutes.INFO) {&#10;                InfoScreen(&#10;                    authViewModel = authViewModel,&#10;                    onLogout = {&#10;                        authViewModel.logout()&#10;                        outerNavController.navigate(&quot;welcome&quot;) {&#10;                            popUpTo(0) // Löscht den Backstack&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;enum class NavigationItem(val label: String, val icon: ImageVector, val route: String) {&#10;    Profile(&quot;Profil&quot;, Icons.Default.Person, NavRoutes.PROFILE),&#10;    Stats(&quot;Statistik&quot;, Icons.Default.Search, NavRoutes.STATS), //durch Statistik Icon ersetzen&#10;    Gameplay(&quot;Spielen&quot;, Icons.Default.Home, NavRoutes.HOME), //durch Schach-Icon ersetzen&#10;    Settings(&quot;Optionen&quot;, Icons.Default.Settings, NavRoutes.SETTINGS),&#10;    Info(&quot;Status&quot;, Icons.Default.Info, NavRoutes.INFO)&#10;}&#10;&#10;&#10;object NavRoutes {&#10;    const val HOME = &quot;home&quot;&#10;    const val PROFILE = &quot;profile&quot;&#10;    const val STATS = &quot;stats&quot;&#10;    const val SETTINGS = &quot;settings&quot;&#10;    const val INFO = &quot;info&quot;&#10;    const val QUICK_MATCH = &quot;quick_match&quot;&#10;    const val PRIVATE_LOBBY = &quot;private_lobby&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileScreen.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import androidx.navigation.NavHostController&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel = hiltViewModel(),&#10;    authViewModel: AuthViewModel,&#10;    outerNavController: NavHostController&#10;) {&#10;    val uiState by viewModel.statsState.collectAsState()&#10;    val usernameChangeState by viewModel.usernameChangeState.collectAsState()&#10;    val passwordChangeState by viewModel.passwordChangeState.collectAsState()&#10;    val (newUsername, setNewUsername) = remember { mutableStateOf(&quot;&quot;) }&#10;    val (oldPassword, setOldPassword) = remember { mutableStateOf(&quot;&quot;) }&#10;    val (newPassword, setNewPassword) = remember { mutableStateOf(&quot;&quot;) }&#10;    val showDialog = remember { mutableStateOf(false) }&#10;    val showPasswordDialog = remember { mutableStateOf(false) }&#10;&#10;    // Stats beim ersten Anzeigen laden&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadStats()&#10;    }&#10;&#10;    // Nach erfolgreicher Änderung Eingabefeld leeren und Status zurücksetzen&#10;    LaunchedEffect(usernameChangeState) {&#10;        if (usernameChangeState is UsernameChangeState.Success) {&#10;            setNewUsername(&quot;&quot;)&#10;            // Optional: Stats neu laden, falls Username angezeigt wird&#10;            // viewModel.loadStats()&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.events.collect { event -&gt;&#10;            when (event) {&#10;                is ProfileEvent.LogoutAndNavigateToLogin -&gt; {&#10;                    viewModel.resetStatsState()&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;login&quot;) {&#10;                        popUpTo(&quot;login&quot;) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            when (uiState) {&#10;                is StatsUiState.Loading -&gt; Text(&quot;Lade Statistiken...&quot;)&#10;                is StatsUiState.Error -&gt; Text(&quot;Fehler: &quot; + (uiState as StatsUiState.Error).message)&#10;                is StatsUiState.Success -&gt; {&#10;                    val stats = (uiState as StatsUiState.Success).stats&#10;                    Text(&quot;Siege: ${stats.wins}\nNiederlagen: ${stats.losses}\nRemis: ${stats.draws}\nGesamt: ${stats.wins + stats.losses + stats.draws}&quot;)&#10;                }&#10;                is StatsUiState.Idle -&gt; { /* nichts anzeigen */ }&#10;            }&#10;            // --- Username ändern UI ---&#10;            OutlinedTextField(&#10;                value = newUsername,&#10;                onValueChange = setNewUsername,&#10;                label = { Text(&quot;Neuer Benutzername&quot;) },&#10;                modifier = Modifier.padding(top = 32.dp)&#10;            )&#10;            Button(&#10;                onClick = {&#10;                    showDialog.value = true&#10;                },&#10;                enabled = usernameChangeState !is UsernameChangeState.Loading &amp;&amp; newUsername.length in 3..32,&#10;                modifier = Modifier.padding(top = 8.dp)&#10;            ) {&#10;                Text(&quot;Benutzernamen ändern&quot;)&#10;            }&#10;            when (usernameChangeState) {&#10;                is UsernameChangeState.Loading -&gt; Text(&quot;Ändere Benutzernamen...&quot;)&#10;                is UsernameChangeState.Success -&gt; Text(&quot;Benutzername erfolgreich geändert!&quot;, color = Color.Green)&#10;                is UsernameChangeState.Error -&gt; Text((usernameChangeState as UsernameChangeState.Error).message, color = Color.Red)&#10;                else -&gt; {}&#10;            }&#10;            // --- Passwort ändern UI ---&#10;            OutlinedTextField(&#10;                value = oldPassword,&#10;                onValueChange = setOldPassword,&#10;                label = { Text(&quot;Altes Passwort&quot;) },&#10;                modifier = Modifier.padding(top = 32.dp),&#10;                singleLine = true&#10;            )&#10;            OutlinedTextField(&#10;                value = newPassword,&#10;                onValueChange = setNewPassword,&#10;                label = { Text(&quot;Neues Passwort&quot;) },&#10;                modifier = Modifier.padding(top = 8.dp),&#10;                singleLine = true&#10;            )&#10;            Button(&#10;                onClick = {&#10;                    showPasswordDialog.value = true&#10;                },&#10;                enabled = passwordChangeState !is PasswordChangeState.Loading &amp;&amp; oldPassword.length &gt;= 4 &amp;&amp; newPassword.length in 4..64,&#10;                modifier = Modifier.padding(top = 8.dp)&#10;            ) {&#10;                Text(&quot;Passwort ändern&quot;)&#10;            }&#10;            when (passwordChangeState) {&#10;                is PasswordChangeState.Loading -&gt; Text(&quot;Ändere Passwort...&quot;)&#10;                is PasswordChangeState.Success -&gt; Text(&quot;Passwort erfolgreich geändert!&quot;, color = Color.Green)&#10;                is PasswordChangeState.Error -&gt; Text((passwordChangeState as PasswordChangeState.Error).message, color = Color.Red)&#10;                else -&gt; {}&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showDialog.value) {&#10;        AlertDialog(&#10;            onDismissRequest = { showDialog.value = false },&#10;            title = { Text(&quot;Achtung&quot;) },&#10;            text = { Text(&quot;Um den Benutzernamen zu ändern, musst du dich neu anmelden. Fortfahren?&quot;) },&#10;            confirmButton = {&#10;                Button(onClick = {&#10;                    showDialog.value = false&#10;                    viewModel.changeUsername(newUsername)&#10;                }) { Text(&quot;Ja&quot;) }&#10;            },&#10;            dismissButton = {&#10;                Button(onClick = { showDialog.value = false }) { Text(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showPasswordDialog.value) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPasswordDialog.value = false },&#10;            title = { Text(&quot;Achtung&quot;) },&#10;            text = { Text(&quot;Um das Passwort zu ändern, musst du dich neu anmelden. Fortfahren?&quot;) },&#10;            confirmButton = {&#10;                Button(onClick = {&#10;                    showPasswordDialog.value = false&#10;                    viewModel.changePassword(oldPassword, newPassword)&#10;                }) { Text(&quot;Ja&quot;) }&#10;            },&#10;            dismissButton = {&#10;                Button(onClick = { showPasswordDialog.value = false }) { Text(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.AlertDialog&#10;import androidx.compose.material3.Button&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.LaunchedEffect&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.hilt.navigation.compose.hiltViewModel&#10;import app.chesspresso.auth.presentation.AuthViewModel&#10;import androidx.navigation.NavHostController&#10;&#10;@Composable&#10;fun ProfileScreen(&#10;    viewModel: ProfileViewModel = hiltViewModel(),&#10;    authViewModel: AuthViewModel,&#10;    outerNavController: NavHostController&#10;) {&#10;    val uiState by viewModel.statsState.collectAsState()&#10;    val usernameChangeState by viewModel.usernameChangeState.collectAsState()&#10;    val passwordChangeState by viewModel.passwordChangeState.collectAsState()&#10;    val (newUsername, setNewUsername) = remember { mutableStateOf(&quot;&quot;) }&#10;    val (oldPassword, setOldPassword) = remember { mutableStateOf(&quot;&quot;) }&#10;    val (newPassword, setNewPassword) = remember { mutableStateOf(&quot;&quot;) }&#10;    val showDialog = remember { mutableStateOf(false) }&#10;    val showPasswordDialog = remember { mutableStateOf(false) }&#10;&#10;    // Stats beim ersten Anzeigen laden&#10;    LaunchedEffect(Unit) {&#10;        viewModel.loadStats()&#10;    }&#10;&#10;    // Nach erfolgreicher Änderung Eingabefeld leeren und Status zurücksetzen&#10;    LaunchedEffect(usernameChangeState) {&#10;        if (usernameChangeState is UsernameChangeState.Success) {&#10;            setNewUsername(&quot;&quot;)&#10;            // Optional: Stats neu laden, falls Username angezeigt wird&#10;            // viewModel.loadStats()&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        viewModel.events.collect { event -&gt;&#10;            when (event) {&#10;                is ProfileEvent.LogoutAndNavigateToLogin -&gt; {&#10;                    viewModel.resetStatsState()&#10;                    authViewModel.logout()&#10;                    outerNavController.navigate(&quot;login&quot;) {&#10;                        popUpTo(&quot;login&quot;) { inclusive = true }&#10;                        launchSingleTop = true&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = Modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;            when (uiState) {&#10;                is StatsUiState.Loading -&gt; Text(&quot;Lade Statistiken...&quot;)&#10;                is StatsUiState.Error -&gt; Text(&quot;Fehler: &quot; + (uiState as StatsUiState.Error).message)&#10;                is StatsUiState.Success -&gt; {&#10;                    val stats = (uiState as StatsUiState.Success).stats&#10;                    Text(&quot;Siege: ${stats.wins}\nNiederlagen: ${stats.losses}\nRemis: ${stats.draws}\nGesamt: ${stats.wins + stats.losses + stats.draws}&quot;)&#10;                }&#10;                is StatsUiState.Idle -&gt; { /* nichts anzeigen */ }&#10;            }&#10;            // --- Username ändern UI ---&#10;            OutlinedTextField(&#10;                value = newUsername,&#10;                onValueChange = setNewUsername,&#10;                label = { Text(&quot;Neuer Benutzername&quot;) },&#10;                modifier = Modifier.padding(top = 32.dp)&#10;            )&#10;            Button(&#10;                onClick = {&#10;                    showDialog.value = true&#10;                },&#10;                enabled = usernameChangeState !is UsernameChangeState.Loading &amp;&amp; newUsername.length in 3..32,&#10;                modifier = Modifier.padding(top = 8.dp)&#10;            ) {&#10;                Text(&quot;Benutzernamen ändern&quot;)&#10;            }&#10;            when (usernameChangeState) {&#10;                is UsernameChangeState.Loading -&gt; Text(&quot;Ändere Benutzernamen...&quot;)&#10;                is UsernameChangeState.Success -&gt; Text(&quot;Benutzername erfolgreich geändert!&quot;, color = Color.Green)&#10;                is UsernameChangeState.Error -&gt; Text((usernameChangeState as UsernameChangeState.Error).message, color = Color.Red)&#10;                else -&gt; {}&#10;            }&#10;            // --- Passwort ändern UI ---&#10;            OutlinedTextField(&#10;                value = oldPassword,&#10;                onValueChange = setOldPassword,&#10;                label = { Text(&quot;Altes Passwort&quot;) },&#10;                modifier = Modifier.padding(top = 32.dp),&#10;                singleLine = true&#10;            )&#10;            OutlinedTextField(&#10;                value = newPassword,&#10;                onValueChange = setNewPassword,&#10;                label = { Text(&quot;Neues Passwort&quot;) },&#10;                modifier = Modifier.padding(top = 8.dp),&#10;                singleLine = true&#10;            )&#10;            Button(&#10;                onClick = {&#10;                    showPasswordDialog.value = true&#10;                },&#10;                enabled = passwordChangeState !is PasswordChangeState.Loading &amp;&amp; oldPassword.length &gt;= 4 &amp;&amp; newPassword.length in 4..64,&#10;                modifier = Modifier.padding(top = 8.dp)&#10;            ) {&#10;                Text(&quot;Passwort ändern&quot;)&#10;            }&#10;            when (passwordChangeState) {&#10;                is PasswordChangeState.Loading -&gt; Text(&quot;Ändere Passwort...&quot;)&#10;                is PasswordChangeState.Success -&gt; Text(&quot;Passwort erfolgreich geändert!&quot;, color = Color.Green)&#10;                is PasswordChangeState.Error -&gt; Text((passwordChangeState as PasswordChangeState.Error).message, color = Color.Red)&#10;                else -&gt; {}&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showDialog.value) {&#10;        AlertDialog(&#10;            onDismissRequest = { showDialog.value = false },&#10;            title = { Text(&quot;Achtung&quot;) },&#10;            text = { Text(&quot;Um den Benutzernamen zu ändern, musst du dich neu anmelden. Fortfahren?&quot;) },&#10;            confirmButton = {&#10;                Button(onClick = {&#10;                    showDialog.value = false&#10;                    viewModel.changeUsername(newUsername)&#10;                }) { Text(&quot;Ja&quot;) }&#10;            },&#10;            dismissButton = {&#10;                Button(onClick = { showDialog.value = false }) { Text(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;&#10;    if (showPasswordDialog.value) {&#10;        AlertDialog(&#10;            onDismissRequest = { showPasswordDialog.value = false },&#10;            title = { Text(&quot;Achtung&quot;) },&#10;            text = { Text(&quot;Um das Passwort zu ändern, musst du dich neu anmelden. Fortfahren?&quot;) },&#10;            confirmButton = {&#10;                Button(onClick = {&#10;                    showPasswordDialog.value = false&#10;                    viewModel.changePassword(oldPassword, newPassword)&#10;                }) { Text(&quot;Ja&quot;) }&#10;            },&#10;            dismissButton = {&#10;                Button(onClick = { showPasswordDialog.value = false }) { Text(&quot;Abbrechen&quot;) }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/screens/main/ProfileViewModel.kt" />
              <option name="originalContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.data.api.StatsResponse&#10;import app.chesspresso.data.api.UserApi&#10;import app.chesspresso.data.api.ChangeUsernameRequest&#10;import app.chesspresso.data.repository.StatsRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;sealed class StatsUiState {&#10;    object Idle : StatsUiState()&#10;    object Loading : StatsUiState()&#10;    data class Success(val stats: StatsResponse) : StatsUiState()&#10;    data class Error(val message: String) : StatsUiState()&#10;}&#10;&#10;sealed class UsernameChangeState {&#10;    object Idle : UsernameChangeState()&#10;    object Loading : UsernameChangeState()&#10;    object Success : UsernameChangeState()&#10;    data class Error(val message: String) : UsernameChangeState()&#10;}&#10;&#10;sealed class PasswordChangeState {&#10;    object Idle : PasswordChangeState()&#10;    object Loading : PasswordChangeState()&#10;    object Success : PasswordChangeState()&#10;    data class Error(val message: String) : PasswordChangeState()&#10;}&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val statsRepository: StatsRepository,&#10;    private val userApi: UserApi&#10;) : ViewModel() {&#10;    private val _statsState = MutableStateFlow&lt;StatsUiState&gt;(StatsUiState.Idle)&#10;    val statsState: StateFlow&lt;StatsUiState&gt; = _statsState&#10;&#10;    private val _usernameChangeState = MutableStateFlow&lt;UsernameChangeState&gt;(UsernameChangeState.Idle)&#10;    val usernameChangeState: StateFlow&lt;UsernameChangeState&gt; = _usernameChangeState.asStateFlow()&#10;&#10;    private val _passwordChangeState = MutableStateFlow&lt;PasswordChangeState&gt;(PasswordChangeState.Idle)&#10;    val passwordChangeState: StateFlow&lt;PasswordChangeState&gt; = _passwordChangeState.asStateFlow()&#10;&#10;    private val _eventChannel = Channel&lt;ProfileEvent&gt;(Channel.BUFFERED)&#10;    val events = _eventChannel.receiveAsFlow()&#10;&#10;    fun loadStats() {&#10;        _statsState.value = StatsUiState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val stats = statsRepository.getMyStats()&#10;                _statsState.value = StatsUiState.Success(stats)&#10;            } catch (e: Exception) {&#10;                _statsState.value = StatsUiState.Error(e.localizedMessage ?: &quot;Unbekannter Fehler&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changeUsername(newUsername: String) {&#10;        _usernameChangeState.value = UsernameChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changeUsername(ChangeUsernameRequest(newUsername))&#10;                if (response.isSuccessful) {&#10;                    _usernameChangeState.value = UsernameChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: &quot;Unbekannter Fehler&quot;&#10;                    _usernameChangeState.value = UsernameChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _usernameChangeState.value = UsernameChangeState.Error(e.localizedMessage ?: &quot;Unbekannter Fehler&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changePassword(oldPassword: String, newPassword: String) {&#10;        _passwordChangeState.value = PasswordChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changePassword(&#10;                    app.chesspresso.data.api.ChangePasswordRequest(oldPassword, newPassword)&#10;                )&#10;                if (response.isSuccessful) {&#10;                    _passwordChangeState.value = PasswordChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: &quot;Unbekannter Fehler&quot;&#10;                    _passwordChangeState.value = PasswordChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _passwordChangeState.value = PasswordChangeState.Error(e.localizedMessage ?: &quot;Unbekannter Fehler&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun resetUsernameChangeState() {&#10;        _usernameChangeState.value = UsernameChangeState.Idle&#10;    }&#10;&#10;    fun resetPasswordChangeState() {&#10;        _passwordChangeState.value = PasswordChangeState.Idle&#10;    }&#10;&#10;    fun resetStatsState() {&#10;        _statsState.value = StatsUiState.Idle&#10;    }&#10;}&#10;&#10;sealed class ProfileEvent {&#10;    object LogoutAndNavigateToLogin : ProfileEvent()&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.screens.main&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import app.chesspresso.data.api.StatsResponse&#10;import app.chesspresso.data.api.UserApi&#10;import app.chesspresso.data.api.ChangeUsernameRequest&#10;import app.chesspresso.data.repository.StatsRepository&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.channels.Channel&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.receiveAsFlow&#10;import kotlinx.coroutines.launch&#10;import javax.inject.Inject&#10;&#10;sealed class StatsUiState {&#10;    object Idle : StatsUiState()&#10;    object Loading : StatsUiState()&#10;    data class Success(val stats: StatsResponse) : StatsUiState()&#10;    data class Error(val message: String) : StatsUiState()&#10;}&#10;&#10;sealed class UsernameChangeState {&#10;    object Idle : UsernameChangeState()&#10;    object Loading : UsernameChangeState()&#10;    object Success : UsernameChangeState()&#10;    data class Error(val message: String) : UsernameChangeState()&#10;}&#10;&#10;sealed class PasswordChangeState {&#10;    object Idle : PasswordChangeState()&#10;    object Loading : PasswordChangeState()&#10;    object Success : PasswordChangeState()&#10;    data class Error(val message: String) : PasswordChangeState()&#10;}&#10;&#10;@HiltViewModel&#10;class ProfileViewModel @Inject constructor(&#10;    private val statsRepository: StatsRepository,&#10;    private val userApi: UserApi&#10;) : ViewModel() {&#10;    private val _statsState = MutableStateFlow&lt;StatsUiState&gt;(StatsUiState.Idle)&#10;    val statsState: StateFlow&lt;StatsUiState&gt; = _statsState&#10;&#10;    private val _usernameChangeState = MutableStateFlow&lt;UsernameChangeState&gt;(UsernameChangeState.Idle)&#10;    val usernameChangeState: StateFlow&lt;UsernameChangeState&gt; = _usernameChangeState.asStateFlow()&#10;&#10;    private val _passwordChangeState = MutableStateFlow&lt;PasswordChangeState&gt;(PasswordChangeState.Idle)&#10;    val passwordChangeState: StateFlow&lt;PasswordChangeState&gt; = _passwordChangeState.asStateFlow()&#10;&#10;    private val _eventChannel = Channel&lt;ProfileEvent&gt;(Channel.BUFFERED)&#10;    val events = _eventChannel.receiveAsFlow()&#10;&#10;    fun loadStats() {&#10;        _statsState.value = StatsUiState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val stats = statsRepository.getMyStats()&#10;                _statsState.value = StatsUiState.Success(stats)&#10;            } catch (e: Exception) {&#10;                _statsState.value = StatsUiState.Error(e.localizedMessage ?: &quot;Unbekannter Fehler&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changeUsername(newUsername: String) {&#10;        _usernameChangeState.value = UsernameChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changeUsername(ChangeUsernameRequest(newUsername))&#10;                if (response.isSuccessful) {&#10;                    _usernameChangeState.value = UsernameChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: &quot;Unbekannter Fehler&quot;&#10;                    _usernameChangeState.value = UsernameChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _usernameChangeState.value = UsernameChangeState.Error(e.localizedMessage ?: &quot;Unbekannter Fehler&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun changePassword(oldPassword: String, newPassword: String) {&#10;        _passwordChangeState.value = PasswordChangeState.Loading&#10;        viewModelScope.launch {&#10;            try {&#10;                val response = userApi.changePassword(&#10;                    app.chesspresso.data.api.ChangePasswordRequest(oldPassword, newPassword)&#10;                )&#10;                if (response.isSuccessful) {&#10;                    _passwordChangeState.value = PasswordChangeState.Success&#10;                    _eventChannel.send(ProfileEvent.LogoutAndNavigateToLogin)&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: &quot;Unbekannter Fehler&quot;&#10;                    _passwordChangeState.value = PasswordChangeState.Error(errorMsg)&#10;                }&#10;            } catch (e: Exception) {&#10;                _passwordChangeState.value = PasswordChangeState.Error(e.localizedMessage ?: &quot;Unbekannter Fehler&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun resetUsernameChangeState() {&#10;        _usernameChangeState.value = UsernameChangeState.Idle&#10;    }&#10;&#10;    fun resetPasswordChangeState() {&#10;        _passwordChangeState.value = PasswordChangeState.Idle&#10;    }&#10;&#10;    fun resetStatsState() {&#10;        _statsState.value = StatsUiState.Idle&#10;    }&#10;}&#10;&#10;sealed class ProfileEvent {&#10;    object LogoutAndNavigateToLogin : ProfileEvent()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/components/LobbyCreatorControls.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/components/LobbyCreatorControls.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@Composable&#10;fun LobbyCreatorControls(&#10;    lobbyId: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showQRCode by remember { mutableStateOf(false) }&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Lobby teilen&quot;,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Button(&#10;                onClick = { showQRCode = !showQRCode },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (showQRCode) Icons.Default.Close else Icons.Default.Settings,&#10;                    contentDescription = if (showQRCode) &quot;QR-Code ausblenden&quot; else &quot;QR-Code anzeigen&quot;&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(if (showQRCode) &quot;QR ausblenden&quot; else &quot;QR anzeigen&quot;)&#10;            }&#10;&#10;            if (showQRCode) {&#10;                Spacer(modifier = Modifier.height(20.dp))&#10;                QRCodeDisplay(lobbyId = lobbyId)&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.components&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Close&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;&#10;@Composable&#10;fun LobbyCreatorControls(&#10;    lobbyId: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    var showQRCode by remember { mutableStateOf(false) }&#10;&#10;    Card(&#10;        modifier = modifier.fillMaxWidth(),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 6.dp),&#10;        shape = RoundedCornerShape(16.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(20.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;Lobby teilen&quot;,&#10;                fontSize = 20.sp,&#10;                fontWeight = FontWeight.Bold&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            Button(&#10;                onClick = { showQRCode = !showQRCode },&#10;                modifier = Modifier.fillMaxWidth(),&#10;                shape = RoundedCornerShape(8.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = if (showQRCode) Icons.Default.Close else Icons.Default.Settings,&#10;                    contentDescription = if (showQRCode) &quot;QR-Code ausblenden&quot; else &quot;QR-Code anzeigen&quot;&#10;                )&#10;                Spacer(modifier = Modifier.width(8.dp))&#10;                Text(if (showQRCode) &quot;QR ausblenden&quot; else &quot;QR anzeigen&quot;)&#10;            }&#10;&#10;            if (showQRCode) {&#10;                Spacer(modifier = Modifier.height(20.dp))&#10;                QRCodeDisplay(lobbyId = lobbyId)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/ui/examples/LobbyScreenExample.kt" />
              <option name="originalContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.ui.examples&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import app.chesspresso.ui.components.LobbyCreatorControls&#10;import app.chesspresso.ui.components.QRScannerButton&#10;&#10;@Composable&#10;fun LobbyScreenExample(&#10;    isLobbyCreator: Boolean,&#10;    lobbyId: String?,&#10;    onJoinLobby: (String) -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val context = LocalContext.current&#10;&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState()),&#10;        verticalArrangement = Arrangement.spacedBy(20.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;Private Lobby&quot;,&#10;            fontSize = 24.sp,&#10;            fontWeight = FontWeight.Bold&#10;        )&#10;&#10;        if (isLobbyCreator &amp;&amp; lobbyId != null) {&#10;            // Für Lobby-Ersteller: QR-Code anzeigen&#10;            LobbyCreatorControls(&#10;                lobbyId = lobbyId&#10;            )&#10;        } else {&#10;            // Für andere Spieler: QR-Code scannen&#10;            QRScannerButton(&#10;                onLobbyScanned = { scannedLobbyId -&gt;&#10;                    onJoinLobby(scannedLobbyId)&#10;                }&#10;            )&#10;        }&#10;&#10;        // Weitere Lobby-Informationen...&#10;        Card(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;Lobby-Informationen&quot;,&#10;                    fontSize = 18.sp,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                if (lobbyId != null) {&#10;                    Text(&quot;Lobby-ID: $lobbyId&quot;)&#10;                    Text(&quot;Status: ${if (isLobbyCreator) &quot;Ersteller&quot; else &quot;Teilnehmer&quot;}&quot;)&#10;                } else {&#10;                    Text(&quot;Noch keiner Lobby beigetreten&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/StompWebSocketService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/chesspresso/websocket/StompWebSocketService.kt" />
              <option name="originalContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyListener&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StompWebSocketService @Inject constructor(&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;StompWebSocket&quot;&#10;        private const val WS_URL = &quot;ws://10.0.2.2:8080/ws&quot;&#10;        private const val HEARTBEAT_INTERVAL = 30000L // 30 Sekunden&#10;        private const val RECONNECT_DELAY = 3000L // 3 Sekunden&#10;    }&#10;&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;    private var reconnectJob: Job? = null&#10;    private var playerId: String? = null&#10;    private var currentLobbyId: String? = null&#10;&#10;    private var lobbyListener: LobbyListener? = null&#10;&#10;    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;ConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    private val _connectionMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val connectionMessages: StateFlow&lt;List&lt;String&gt;&gt; = _connectionMessages.asStateFlow()&#10;&#10;    // Lobby-spezifische Flows&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;String&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    // Callback für Lobby-Message-Handling&#10;    private var lobbyMessageHandler: ((String) -&gt; Unit)? = null&#10;    val MESSAGE_END = &quot;\u0000&quot;&#10;&#10;    enum class ConnectionState {&#10;        DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING&#10;    }&#10;&#10;    enum class ServerStatus {&#10;        OFFLINE, ONLINE, BUSY, MAINTENANCE, UNKNOWN&#10;    }&#10;&#10;    fun setLobbyListener(listener: LobbyListener) {&#10;        this.lobbyListener = listener&#10;    }&#10;&#10;    private val _serverStatus = MutableStateFlow(ServerStatus.UNKNOWN)&#10;    val serverStatus: StateFlow&lt;ServerStatus&gt; = _serverStatus.asStateFlow()&#10;&#10;    private val _lastMessageTimestamp = MutableStateFlow(0L)&#10;    private var serverStatusCheckJob: Job? = null&#10;&#10;    // Timeout für Server-Status-Überprüfung (10 Sekunden)&#10;    private val SERVER_STATUS_TIMEOUT = 10_000L&#10;&#10;    private val webSocketListener = object : WebSocketListener() {&#10;        override fun onOpen(webSocket: WebSocket, response: Response) {&#10;            Log.d(TAG, &quot;WebSocket connection opened&quot;)&#10;            _connectionState.value = ConnectionState.CONNECTED&#10;&#10;            // Sende STOMP CONNECT Frame&#10;            sendStompConnect()&#10;&#10;            // Starte Heartbeat&#10;            startHeartbeat()&#10;&#10;            // Starte Server-Status-Überprüfung&#10;            startServerStatusCheck()&#10;&#10;            // Subscription zu Topics erfolgt erst nach CONNECTED-Antwort vom Server&#10;        }&#10;&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            Log.d(TAG, &quot;Received message: $text&quot;)&#10;            handleStompMessage(text)&#10;        }&#10;&#10;        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;            Log.e(TAG, &quot;WebSocket connection failed: ${t.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;            scheduleReconnect()&#10;        }&#10;&#10;        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;            Log.i(TAG, &quot;WebSocket connection closed: $reason&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;        }&#10;    }&#10;&#10;    suspend fun connect(username: String) {&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected&quot;)&#10;            return&#10;        }&#10;&#10;        playerId = username&#10;        _connectionState.value = ConnectionState.CONNECTING&#10;&#10;        try {&#10;            // Token synchron abrufen&#10;            val token = tokenStorage.getToken().first()&#10;            Log.d(TAG, &quot;Retrieved token for WebSocket connection: ${token?.take(20)}...&quot;)&#10;&#10;            val client = OkHttpClient.Builder()&#10;                .pingInterval(30, TimeUnit.SECONDS)&#10;                .build()&#10;&#10;            val requestBuilder = Request.Builder().url(WS_URL)&#10;&#10;            // Nur Authorization Header hinzufügen wenn Token verfügbar ist&#10;            token?.let {&#10;                requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $it&quot;)&#10;                Log.d(TAG, &quot;Added Authorization header to WebSocket request&quot;)&#10;            } ?: Log.w(TAG, &quot;No token available for WebSocket connection&quot;)&#10;&#10;            val request = requestBuilder.build()&#10;            webSocket = client.newWebSocket(request, webSocketListener)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to connect: ${e.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;        }&#10;    }&#10;&#10;    private fun sendStompConnect() {&#10;        val connectFrame = buildString {&#10;            append(&quot;CONNECT\n&quot;)&#10;            append(&quot;accept-version:1.0,1.1,2.0\n&quot;)&#10;            append(&quot;heart-beat:5000,5000\n&quot;)&#10;            playerId?.let { append(&quot;login:$it\n&quot;) }&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(connectFrame)&#10;        Log.d(TAG, &quot;Sent STOMP CONNECT frame&quot;)&#10;    }&#10;&#10;    private fun subscribeToTopics() {&#10;        Log.d(TAG, &quot;Subscribing to topics&quot;)&#10;        playerId?.let { id -&gt;&#10;            // Subscribe zu persönlichen Nachrichten&#10;            // 200 ms warten&#10;            val subscribeFrame2 = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-2\n&quot;)&#10;                append(&quot;destination:/topic/players\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrame2)&#10;            Log.d(TAG, &quot;Subscribed to topics&quot;)&#10;&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                delay(200)&#10;                val subscribeFrame1 = buildString {&#10;                    append(&quot;SUBSCRIBE\n&quot;)&#10;                    append(&quot;id:sub-1\n&quot;)&#10;                    append(&quot;destination:/user/queue/status\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;                webSocket?.send(subscribeFrame1)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                sendHeartbeat()&#10;                delay(HEARTBEAT_INTERVAL)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Heartbeat started&quot;)&#10;    }&#10;&#10;    private fun sendHeartbeat() {&#10;        playerId?.let { id -&gt;&#10;            val heartbeatFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/heartbeat\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;heartbeat&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(heartbeatFrame)&#10;            Log.d(TAG, &quot;Sent heartbeat for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleStompMessage(message: String) {&#10;        try {&#10;            // Auf CONNECTED Frame vom Server prüfen&#10;            if (message.startsWith(&quot;CONNECTED&quot;)) {&#10;                Log.d(TAG, &quot;Received STOMP CONNECTED frame from server&quot;)&#10;                // Jetzt erst die Subscriptions starten, wenn der Server die Verbindung bestätigt hat&#10;                subscribeToTopics()&#10;                return&#10;            }&#10;&#10;            if (message.startsWith(&quot;MESSAGE&quot;)) {&#10;                val lines = message.split(&quot;\n&quot;)&#10;                var body = &quot;&quot;&#10;                var isBody = false&#10;&#10;                for (line in lines) {&#10;                    if (isBody) {&#10;                        body += line&#10;                    } else if (line.isEmpty()) {&#10;                        isBody = true&#10;                    }&#10;                }&#10;&#10;                // Entferne Null-Terminator&#10;                body = body.replace(MESSAGE_END, &quot;&quot;)&#10;&#10;                if (body.isNotEmpty()) {&#10;                    handleMessageBody(body)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error handling STOMP message: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleMessageBody(body: String) {&#10;        try {&#10;            val json = JSONObject(body)&#10;            val type = json.optString(&quot;type&quot;)&#10;&#10;            when (type) {&#10;                &quot;status-update&quot; -&gt; {&#10;                    val status = json.optString(&quot;status&quot;)&#10;                    Log.d(TAG, &quot;Status update received: $status&quot;)&#10;&#10;                    // Server-Status verarbeiten&#10;                    updateServerStatus(status)&#10;                }&#10;&#10;                &quot;lobby-message&quot; -&gt; {&#10;                    // Lobby-spezifische Nachrichten verarbeiten&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val messageContent = json.optString(&quot;message&quot;)&#10;&#10;                    if (lobbyId == currentLobbyId) {&#10;                        // Nur Nachrichten für den aktuellen Lobby-Kontext weiterleiten&#10;                        _lobbyMessages.value = _lobbyMessages.value + messageContent&#10;                        Log.d(TAG, &quot;Lobby message received: $messageContent&quot;)&#10;                        // Optional: Direktes Handling der Nachricht über den Handler&#10;                        lobbyMessageHandler?.invoke(messageContent)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Füge Nachricht zur Liste hinzu&#10;            val currentMessages = _connectionMessages.value.toMutableList()&#10;            currentMessages.add(body)&#10;            if (currentMessages.size &gt; 50) { // Begrenze auf 50 Nachrichten&#10;                currentMessages.removeAt(0)&#10;            }&#10;            _connectionMessages.value = currentMessages&#10;&#10;            // Aktualisiere den Zeitstempel der letzten Nachricht&#10;            _lastMessageTimestamp.value = System.currentTimeMillis()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error parsing message body: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Aktualisiert den Server-Status basierend auf dem erhaltenen Status-String&#10;     */&#10;    private fun updateServerStatus(status: String) {&#10;        val newStatus = when (status.lowercase()) {&#10;            &quot;online&quot; -&gt; ServerStatus.ONLINE&#10;            &quot;offline&quot; -&gt; ServerStatus.OFFLINE&#10;            &quot;busy&quot; -&gt; ServerStatus.BUSY&#10;            &quot;maintenance&quot; -&gt; ServerStatus.MAINTENANCE&#10;            else -&gt; ServerStatus.UNKNOWN&#10;        }&#10;&#10;        _serverStatus.value = newStatus&#10;        Log.d(TAG, &quot;Server status updated to: $newStatus&quot;)&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;        heartbeatJob = null&#10;        Log.d(TAG, &quot;Heartbeat stopped&quot;)&#10;    }&#10;&#10;    private fun scheduleReconnect() {&#10;        if (reconnectJob?.isActive == true) return&#10;&#10;        reconnectJob = CoroutineScope(Dispatchers.IO).launch {&#10;            delay(RECONNECT_DELAY)&#10;            playerId?.let { id -&gt;&#10;                if (_connectionState.value == ConnectionState.DISCONNECTED) {&#10;                    Log.d(TAG, &quot;Attempting to reconnect...&quot;)&#10;                    _connectionState.value = ConnectionState.RECONNECTING&#10;                    connect(id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        Log.d(TAG, &quot;Disconnecting WebSocket&quot;)&#10;        stopHeartbeat()&#10;        reconnectJob?.cancel()&#10;&#10;        // Sende App-Closing-Nachricht an Server bevor Verbindung getrennt wird&#10;        sendAppClosingMessage()&#10;&#10;        // Kurz warten damit Nachricht gesendet werden kann&#10;        Thread.sleep(100)&#10;&#10;        // Sende DISCONNECT Frame&#10;        val disconnectFrame = buildString {&#10;            append(&quot;DISCONNECT\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(disconnectFrame)&#10;        webSocket?.close(1000, &quot;Client disconnecting&quot;)&#10;        webSocket = null&#10;&#10;        _connectionState.value = ConnectionState.DISCONNECTED&#10;    }&#10;&#10;    private fun sendAppClosingMessage() {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;app-shutdown&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageSync() {&#10;        // Synchrone Version für App-Shutdown&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            sendAppClosingMessage()&#10;            Thread.sleep(200) // Etwas länger warten für synchronen Aufruf&#10;        }&#10;    }&#10;&#10;    fun leaveLobbyOnAppClosing() {&#10;        if (lobbyListener == null) {&#10;            Log.w(TAG, &quot;LobbyListener is not set. Cannot leave lobby on app closing.&quot;)&#10;        } else {&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val currentLobby = lobbyListener!!.currentLobby.value&#10;                Log.d(&quot;StompWebSocket&quot;, &quot;checking if in a lobby: current Lobby: $currentLobby&quot;)&#10;                currentLobby?.let {&#10;                    lobbyListener!!.leaveLobby(it.lobbyId)&#10;                        .onSuccess {&#10;                            Log.d(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Successfully left lobby ${currentLobby.lobbyId} during app closing&quot;&#10;                            )&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            Log.e(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Failed to leave lobby during app closing&quot;,&#10;                                exception&#10;                            )&#10;                        }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageWithReason(reason: String) {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;$reason&quot;,&quot;timestamp&quot;:&quot;${System.currentTimeMillis()}&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id with reason: $reason&quot;)&#10;&#10;            // Kurz warten damit Nachricht gesendet werden kann&#10;            Thread.sleep(150)&#10;        }&#10;    }&#10;&#10;    fun requestOnlinePlayers() {&#10;        playerId?.let { id -&gt;&#10;            val requestFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/players\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;request&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(requestFrame)&#10;            Log.d(TAG, &quot;Requested online players list&quot;)&#10;        }&#10;    }&#10;&#10;    fun setLobbyMessageHandler(handler: (String) -&gt; Unit) {&#10;        lobbyMessageHandler = handler&#10;    }&#10;&#10;    fun isConnected(): Boolean = _connectionState.value == ConnectionState.CONNECTED&#10;&#10;    // Lobby-spezifische Funktionen&#10;&#10;    fun subscribeToLobby(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu lobby-spezifischen Topics&#10;        val subscribeLobbyFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/lobby/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(subscribeLobbyFrame)&#10;        Log.d(TAG, &quot;Subscribed to lobby updates: $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromLobby() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            Log.d(&#10;                TAG,&#10;                &quot;Sending STOMP unsubscribe frame: ${&#10;                    unsubscribeFrame.replace(&#10;                        MESSAGE_END,&#10;                        &quot;[NULL]&quot;&#10;                    )&#10;                }&quot;&#10;            )&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId = null&#10;    }&#10;&#10;    fun sendLobbyChat(message: String) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val chatFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/chat\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;chat&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;message&quot;:&quot;$message&quot;}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(chatFrame)&#10;                Log.d(TAG, &quot;Sent lobby chat message: $message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPlayerReady(ready: Boolean) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val readyFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/ready\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;player-ready&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;ready&quot;:$ready}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(readyFrame)&#10;                Log.d(TAG, &quot;Sent player ready status: $ready&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Legacy-Methoden für Kompatibilität (werden intern umgeleitet)&#10;    fun joinLobby(lobbyId: String) {&#10;        subscribeToLobby(lobbyId)&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        unsubscribeFromLobby()&#10;    }&#10;&#10;    fun sendLobbyMessage(message: String) {&#10;        sendLobbyChat(message)&#10;    }&#10;&#10;    private fun startServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                // Prüfen, ob der letzte Nachrichtenzeitpunkt zu lange her ist&#10;                val currentTime = System.currentTimeMillis()&#10;                val lastMessageTime = _lastMessageTimestamp.value&#10;&#10;                if (lastMessageTime &gt; 0 &amp;&amp; (currentTime - lastMessageTime) &gt; SERVER_STATUS_TIMEOUT) {&#10;                    // Wenn länger als 10 Sekunden keine Nachricht empfangen wurde, Status auf OFFLINE setzen&#10;                    _serverStatus.value = ServerStatus.OFFLINE&#10;                    Log.d(&#10;                        TAG,&#10;                        &quot;Server status set to OFFLINE due to timeout (no message in ${SERVER_STATUS_TIMEOUT / 1000} seconds)&quot;&#10;                    )&#10;                }&#10;&#10;                delay(1000) // Alle Sekunde prüfen&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Server status check started&quot;)&#10;    }&#10;&#10;    private fun stopServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = null&#10;        Log.d(TAG, &quot;Server status check stopped&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.chesspresso.websocket&#10;&#10;import android.util.Log&#10;import app.chesspresso.data.storage.TokenStorage&#10;import app.chesspresso.service.LobbyListener&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.flow.first&#10;import kotlinx.coroutines.isActive&#10;import kotlinx.coroutines.launch&#10;import okhttp3.OkHttpClient&#10;import okhttp3.Request&#10;import okhttp3.Response&#10;import okhttp3.WebSocket&#10;import okhttp3.WebSocketListener&#10;import org.json.JSONObject&#10;import java.util.concurrent.TimeUnit&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;@Singleton&#10;class StompWebSocketService @Inject constructor(&#10;    private val tokenStorage: TokenStorage&#10;) {&#10;    companion object {&#10;        private const val TAG = &quot;StompWebSocket&quot;&#10;        private const val WS_URL = &quot;ws://10.0.2.2:8080/ws&quot;&#10;        private const val HEARTBEAT_INTERVAL = 30000L // 30 Sekunden&#10;        private const val RECONNECT_DELAY = 3000L // 3 Sekunden&#10;    }&#10;&#10;    private var webSocket: WebSocket? = null&#10;    private var heartbeatJob: Job? = null&#10;    private var reconnectJob: Job? = null&#10;    private var playerId: String? = null&#10;    private var currentLobbyId: String? = null&#10;&#10;    private var lobbyListener: LobbyListener? = null&#10;&#10;    private val _connectionState = MutableStateFlow(ConnectionState.DISCONNECTED)&#10;    val connectionState: StateFlow&lt;ConnectionState&gt; = _connectionState.asStateFlow()&#10;&#10;    private val _connectionMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val connectionMessages: StateFlow&lt;List&lt;String&gt;&gt; = _connectionMessages.asStateFlow()&#10;&#10;    // Lobby-spezifische Flows&#10;    private val _lobbyMessages = MutableStateFlow&lt;List&lt;String&gt;&gt;(emptyList())&#10;    val lobbyMessages: StateFlow&lt;List&lt;String&gt;&gt; = _lobbyMessages.asStateFlow()&#10;&#10;    // Callback für Lobby-Message-Handling&#10;    private var lobbyMessageHandler: ((String) -&gt; Unit)? = null&#10;    val MESSAGE_END = &quot;\u0000&quot;&#10;&#10;    enum class ConnectionState {&#10;        DISCONNECTED, CONNECTING, CONNECTED, RECONNECTING&#10;    }&#10;&#10;    enum class ServerStatus {&#10;        OFFLINE, ONLINE, BUSY, MAINTENANCE, UNKNOWN&#10;    }&#10;&#10;    fun setLobbyListener(listener: LobbyListener) {&#10;        this.lobbyListener = listener&#10;    }&#10;&#10;    private val _serverStatus = MutableStateFlow(ServerStatus.UNKNOWN)&#10;    val serverStatus: StateFlow&lt;ServerStatus&gt; = _serverStatus.asStateFlow()&#10;&#10;    private val _lastMessageTimestamp = MutableStateFlow(0L)&#10;    private var serverStatusCheckJob: Job? = null&#10;&#10;    // Timeout für Server-Status-Überprüfung (10 Sekunden)&#10;    private val SERVER_STATUS_TIMEOUT = 10_000L&#10;&#10;    private val webSocketListener = object : WebSocketListener() {&#10;        override fun onOpen(webSocket: WebSocket, response: Response) {&#10;            Log.d(TAG, &quot;WebSocket connection opened&quot;)&#10;            _connectionState.value = ConnectionState.CONNECTED&#10;&#10;            // Sende STOMP CONNECT Frame&#10;            sendStompConnect()&#10;&#10;            // Starte Heartbeat&#10;            startHeartbeat()&#10;&#10;            // Starte Server-Status-Überprüfung&#10;            startServerStatusCheck()&#10;&#10;            // Subscription zu Topics erfolgt erst nach CONNECTED-Antwort vom Server&#10;        }&#10;&#10;        override fun onMessage(webSocket: WebSocket, text: String) {&#10;            Log.d(TAG, &quot;Received message: $text&quot;)&#10;            handleStompMessage(text)&#10;        }&#10;&#10;        override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {&#10;            Log.e(TAG, &quot;WebSocket connection failed: ${t.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;            scheduleReconnect()&#10;        }&#10;&#10;        override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {&#10;            Log.i(TAG, &quot;WebSocket connection closed: $reason&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;            stopHeartbeat()&#10;            stopServerStatusCheck()&#10;            _serverStatus.value = ServerStatus.OFFLINE&#10;        }&#10;    }&#10;&#10;    suspend fun connect(username: String) {&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            Log.d(TAG, &quot;Already connected&quot;)&#10;            return&#10;        }&#10;&#10;        playerId = username&#10;        _connectionState.value = ConnectionState.CONNECTING&#10;&#10;        try {&#10;            // Token synchron abrufen&#10;            val token = tokenStorage.getToken().first()&#10;            Log.d(TAG, &quot;Retrieved token for WebSocket connection: ${token?.take(20)}...&quot;)&#10;&#10;            val client = OkHttpClient.Builder()&#10;                .pingInterval(30, TimeUnit.SECONDS)&#10;                .build()&#10;&#10;            val requestBuilder = Request.Builder().url(WS_URL)&#10;&#10;            // Nur Authorization Header hinzufügen wenn Token verfügbar ist&#10;            token?.let {&#10;                requestBuilder.addHeader(&quot;Authorization&quot;, &quot;Bearer $it&quot;)&#10;                Log.d(TAG, &quot;Added Authorization header to WebSocket request&quot;)&#10;            } ?: Log.w(TAG, &quot;No token available for WebSocket connection&quot;)&#10;&#10;            val request = requestBuilder.build()&#10;            webSocket = client.newWebSocket(request, webSocketListener)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Failed to connect: ${e.message}&quot;)&#10;            _connectionState.value = ConnectionState.DISCONNECTED&#10;        }&#10;    }&#10;&#10;    private fun sendStompConnect() {&#10;        val connectFrame = buildString {&#10;            append(&quot;CONNECT\n&quot;)&#10;            append(&quot;accept-version:1.0,1.1,2.0\n&quot;)&#10;            append(&quot;heart-beat:5000,5000\n&quot;)&#10;            playerId?.let { append(&quot;login:$it\n&quot;) }&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(connectFrame)&#10;        Log.d(TAG, &quot;Sent STOMP CONNECT frame&quot;)&#10;    }&#10;&#10;    private fun subscribeToTopics() {&#10;        Log.d(TAG, &quot;Subscribing to topics&quot;)&#10;        playerId?.let { id -&gt;&#10;            // Subscribe zu persönlichen Nachrichten&#10;            // 200 ms warten&#10;            val subscribeFrame2 = buildString {&#10;                append(&quot;SUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-2\n&quot;)&#10;                append(&quot;destination:/topic/players\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;            webSocket?.send(subscribeFrame2)&#10;            Log.d(TAG, &quot;Subscribed to topics&quot;)&#10;&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                delay(200)&#10;                val subscribeFrame1 = buildString {&#10;                    append(&quot;SUBSCRIBE\n&quot;)&#10;                    append(&quot;id:sub-1\n&quot;)&#10;                    append(&quot;destination:/user/queue/status\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;                webSocket?.send(subscribeFrame1)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startHeartbeat() {&#10;        heartbeatJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                sendHeartbeat()&#10;                delay(HEARTBEAT_INTERVAL)&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Heartbeat started&quot;)&#10;    }&#10;&#10;    private fun sendHeartbeat() {&#10;        playerId?.let { id -&gt;&#10;            val heartbeatFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/heartbeat\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;heartbeat&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(heartbeatFrame)&#10;            Log.d(TAG, &quot;Sent heartbeat for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleStompMessage(message: String) {&#10;        try {&#10;            // Auf CONNECTED Frame vom Server prüfen&#10;            if (message.startsWith(&quot;CONNECTED&quot;)) {&#10;                Log.d(TAG, &quot;Received STOMP CONNECTED frame from server&quot;)&#10;                // Jetzt erst die Subscriptions starten, wenn der Server die Verbindung bestätigt hat&#10;                subscribeToTopics()&#10;                return&#10;            }&#10;&#10;            if (message.startsWith(&quot;MESSAGE&quot;)) {&#10;                val lines = message.split(&quot;\n&quot;)&#10;                var body = &quot;&quot;&#10;                var isBody = false&#10;&#10;                for (line in lines) {&#10;                    if (isBody) {&#10;                        body += line&#10;                    } else if (line.isEmpty()) {&#10;                        isBody = true&#10;                    }&#10;                }&#10;&#10;                // Entferne Null-Terminator&#10;                body = body.replace(MESSAGE_END, &quot;&quot;)&#10;&#10;                if (body.isNotEmpty()) {&#10;                    handleMessageBody(body)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error handling STOMP message: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun handleMessageBody(body: String) {&#10;        try {&#10;            val json = JSONObject(body)&#10;            val type = json.optString(&quot;type&quot;)&#10;&#10;            when (type) {&#10;                &quot;status-update&quot; -&gt; {&#10;                    val status = json.optString(&quot;status&quot;)&#10;                    Log.d(TAG, &quot;Status update received: $status&quot;)&#10;&#10;                    // Server-Status verarbeiten&#10;                    updateServerStatus(status)&#10;                }&#10;&#10;                &quot;lobby-message&quot; -&gt; {&#10;                    // Lobby-spezifische Nachrichten verarbeiten&#10;                    val lobbyId = json.optString(&quot;lobbyId&quot;)&#10;                    val messageContent = json.optString(&quot;message&quot;)&#10;&#10;                    if (lobbyId == currentLobbyId) {&#10;                        // Nur Nachrichten für den aktuellen Lobby-Kontext weiterleiten&#10;                        _lobbyMessages.value = _lobbyMessages.value + messageContent&#10;                        Log.d(TAG, &quot;Lobby message received: $messageContent&quot;)&#10;                        // Optional: Direktes Handling der Nachricht über den Handler&#10;                        lobbyMessageHandler?.invoke(messageContent)&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Füge Nachricht zur Liste hinzu&#10;            val currentMessages = _connectionMessages.value.toMutableList()&#10;            currentMessages.add(body)&#10;            if (currentMessages.size &gt; 50) { // Begrenze auf 50 Nachrichten&#10;                currentMessages.removeAt(0)&#10;            }&#10;            _connectionMessages.value = currentMessages&#10;&#10;            // Aktualisiere den Zeitstempel der letzten Nachricht&#10;            _lastMessageTimestamp.value = System.currentTimeMillis()&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error parsing message body: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Aktualisiert den Server-Status basierend auf dem erhaltenen Status-String&#10;     */&#10;    private fun updateServerStatus(status: String) {&#10;        val newStatus = when (status.lowercase()) {&#10;            &quot;online&quot; -&gt; ServerStatus.ONLINE&#10;            &quot;offline&quot; -&gt; ServerStatus.OFFLINE&#10;            &quot;busy&quot; -&gt; ServerStatus.BUSY&#10;            &quot;maintenance&quot; -&gt; ServerStatus.MAINTENANCE&#10;            else -&gt; ServerStatus.UNKNOWN&#10;        }&#10;&#10;        _serverStatus.value = newStatus&#10;        Log.d(TAG, &quot;Server status updated to: $newStatus&quot;)&#10;    }&#10;&#10;    private fun stopHeartbeat() {&#10;        heartbeatJob?.cancel()&#10;        heartbeatJob = null&#10;        Log.d(TAG, &quot;Heartbeat stopped&quot;)&#10;    }&#10;&#10;    private fun scheduleReconnect() {&#10;        if (reconnectJob?.isActive == true) return&#10;&#10;        reconnectJob = CoroutineScope(Dispatchers.IO).launch {&#10;            delay(RECONNECT_DELAY)&#10;            playerId?.let { id -&gt;&#10;                if (_connectionState.value == ConnectionState.DISCONNECTED) {&#10;                    Log.d(TAG, &quot;Attempting to reconnect...&quot;)&#10;                    _connectionState.value = ConnectionState.RECONNECTING&#10;                    connect(id)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun disconnect() {&#10;        Log.d(TAG, &quot;Disconnecting WebSocket&quot;)&#10;        stopHeartbeat()&#10;        reconnectJob?.cancel()&#10;&#10;        // Sende App-Closing-Nachricht an Server bevor Verbindung getrennt wird&#10;        sendAppClosingMessage()&#10;&#10;        // Kurz warten damit Nachricht gesendet werden kann&#10;        Thread.sleep(100)&#10;&#10;        // Sende DISCONNECT Frame&#10;        val disconnectFrame = buildString {&#10;            append(&quot;DISCONNECT\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(disconnectFrame)&#10;        webSocket?.close(1000, &quot;Client disconnecting&quot;)&#10;        webSocket = null&#10;&#10;        _connectionState.value = ConnectionState.DISCONNECTED&#10;    }&#10;&#10;    private fun sendAppClosingMessage() {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;app-shutdown&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id&quot;)&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageSync() {&#10;        // Synchrone Version für App-Shutdown&#10;        if (_connectionState.value == ConnectionState.CONNECTED) {&#10;            sendAppClosingMessage()&#10;            Thread.sleep(200) // Etwas länger warten für synchronen Aufruf&#10;        }&#10;    }&#10;&#10;    fun leaveLobbyOnAppClosing() {&#10;        if (lobbyListener == null) {&#10;            Log.w(TAG, &quot;LobbyListener is not set. Cannot leave lobby on app closing.&quot;)&#10;        } else {&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val currentLobby = lobbyListener!!.currentLobby.value&#10;                Log.d(&quot;StompWebSocket&quot;, &quot;checking if in a lobby: current Lobby: $currentLobby&quot;)&#10;                currentLobby?.let {&#10;                    lobbyListener!!.leaveLobby(it.lobbyId)&#10;                        .onSuccess {&#10;                            Log.d(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Successfully left lobby ${currentLobby.lobbyId} during app closing&quot;&#10;                            )&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            Log.e(&#10;                                &quot;StompWebSocket&quot;,&#10;                                &quot;Failed to leave lobby during app closing&quot;,&#10;                                exception&#10;                            )&#10;                        }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendAppClosingMessageWithReason(reason: String) {&#10;        leaveLobbyOnAppClosing()&#10;        playerId?.let { id -&gt;&#10;            val appClosingFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/disconnect\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;app-closing&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;reason&quot;:&quot;$reason&quot;,&quot;timestamp&quot;:&quot;${System.currentTimeMillis()}&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(appClosingFrame)&#10;            Log.d(TAG, &quot;Sent app closing message for player: $id with reason: $reason&quot;)&#10;&#10;            // Kurz warten damit Nachricht gesendet werden kann&#10;            Thread.sleep(150)&#10;        }&#10;    }&#10;&#10;    fun requestOnlinePlayers() {&#10;        playerId?.let { id -&gt;&#10;            val requestFrame = buildString {&#10;                append(&quot;SEND\n&quot;)&#10;                append(&quot;destination:/app/players\n&quot;)&#10;                append(&quot;content-type:application/json\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(&quot;&quot;&quot;{&quot;type&quot;:&quot;request&quot;,&quot;playerId&quot;:&quot;$id&quot;}&quot;&quot;&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            webSocket?.send(requestFrame)&#10;            Log.d(TAG, &quot;Requested online players list&quot;)&#10;        }&#10;    }&#10;&#10;    fun setLobbyMessageHandler(handler: (String) -&gt; Unit) {&#10;        lobbyMessageHandler = handler&#10;    }&#10;&#10;    fun isConnected(): Boolean = _connectionState.value == ConnectionState.CONNECTED&#10;&#10;    // Lobby-spezifische Funktionen&#10;&#10;    fun subscribeToLobby(lobbyId: String) {&#10;        currentLobbyId = lobbyId&#10;&#10;        // Subscribe zu lobby-spezifischen Topics&#10;        val subscribeLobbyFrame = buildString {&#10;            append(&quot;SUBSCRIBE\n&quot;)&#10;            append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;            append(&quot;destination:/topic/lobby/$lobbyId\n&quot;)&#10;            append(&quot;\n&quot;)&#10;            append(MESSAGE_END)&#10;        }&#10;&#10;        webSocket?.send(subscribeLobbyFrame)&#10;        Log.d(TAG, &quot;Subscribed to lobby updates: $lobbyId&quot;)&#10;    }&#10;&#10;    fun unsubscribeFromLobby() {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            val unsubscribeFrame = buildString {&#10;                append(&quot;UNSUBSCRIBE\n&quot;)&#10;                append(&quot;id:sub-lobby-$lobbyId\n&quot;)&#10;                append(&quot;\n&quot;)&#10;                append(MESSAGE_END)&#10;            }&#10;&#10;            Log.d(&#10;                TAG,&#10;                &quot;Sending STOMP unsubscribe frame: ${&#10;                    unsubscribeFrame.replace(&#10;                        MESSAGE_END,&#10;                        &quot;[NULL]&quot;&#10;                    )&#10;                }&quot;&#10;            )&#10;            webSocket?.send(unsubscribeFrame)&#10;            Log.d(TAG, &quot;Unsubscribed from lobby: $lobbyId&quot;)&#10;        }&#10;        currentLobbyId = null&#10;    }&#10;&#10;    fun sendLobbyChat(message: String) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val chatFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/chat\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;chat&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;message&quot;:&quot;$message&quot;}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(chatFrame)&#10;                Log.d(TAG, &quot;Sent lobby chat message: $message&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun sendPlayerReady(ready: Boolean) {&#10;        currentLobbyId?.let { lobbyId -&gt;&#10;            playerId?.let { id -&gt;&#10;                val readyFrame = buildString {&#10;                    append(&quot;SEND\n&quot;)&#10;                    append(&quot;destination:/app/lobby/ready\n&quot;)&#10;                    append(&quot;content-type:application/json\n&quot;)&#10;                    append(&quot;\n&quot;)&#10;                    append(&quot;&quot;&quot;{&quot;type&quot;:&quot;player-ready&quot;,&quot;playerId&quot;:&quot;$id&quot;,&quot;lobbyId&quot;:&quot;$lobbyId&quot;,&quot;ready&quot;:$ready}&quot;&quot;&quot;)&#10;                    append(MESSAGE_END)&#10;                }&#10;&#10;                webSocket?.send(readyFrame)&#10;                Log.d(TAG, &quot;Sent player ready status: $ready&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Legacy-Methoden für Kompatibilität (werden intern umgeleitet)&#10;    fun joinLobby(lobbyId: String) {&#10;        subscribeToLobby(lobbyId)&#10;    }&#10;&#10;    fun leaveLobby() {&#10;        unsubscribeFromLobby()&#10;    }&#10;&#10;    fun sendLobbyMessage(message: String) {&#10;        sendLobbyChat(message)&#10;    }&#10;&#10;    private fun startServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = CoroutineScope(Dispatchers.IO).launch {&#10;            while (isActive &amp;&amp; _connectionState.value == ConnectionState.CONNECTED) {&#10;                // Prüfen, ob der letzte Nachrichtenzeitpunkt zu lange her ist&#10;                val currentTime = System.currentTimeMillis()&#10;                val lastMessageTime = _lastMessageTimestamp.value&#10;&#10;                if (lastMessageTime &gt; 0 &amp;&amp; (currentTime - lastMessageTime) &gt; SERVER_STATUS_TIMEOUT) {&#10;                    // Wenn länger als 10 Sekunden keine Nachricht empfangen wurde, Status auf OFFLINE setzen&#10;                    _serverStatus.value = ServerStatus.OFFLINE&#10;                    Log.d(&#10;                        TAG,&#10;                        &quot;Server status set to OFFLINE due to timeout (no message in ${SERVER_STATUS_TIMEOUT / 1000} seconds)&quot;&#10;                    )&#10;                }&#10;&#10;                delay(1000) // Alle Sekunde prüfen&#10;            }&#10;        }&#10;        Log.d(TAG, &quot;Server status check started&quot;)&#10;    }&#10;&#10;    private fun stopServerStatusCheck() {&#10;        serverStatusCheckJob?.cancel()&#10;        serverStatusCheckJob = null&#10;        Log.d(TAG, &quot;Server status check stopped&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/xml/network_security_config.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;network-security-config&gt;&#10;    &lt;domain-config cleartextTrafficPermitted=&quot;true&quot;&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;localhost&lt;/domain&gt;&#10;        &lt;domain includeSubdomains=&quot;true&quot;&gt;10.0.2.2&lt;/domain&gt;&#10;    &lt;/domain-config&gt;&#10;&lt;/network-security-config&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>